---
title: Synchronized
date: 2018-10-18 16:46:11
tags: [Java]
---

# 前言

Java 中 synchronized 关键字 在 很早以前就已经有了，我还记得自己刚开始学习 Java 的时候，别人问我并发的时候我都是说，加个 synchronized 就好了，温故而知新，现在重新学习 synchronized 关键字。

# 正文

注意的是，synchronized 是**可重入锁**！！

## synchronized 同步基础

Java 中的对象创建时就有了监视器，每个 Java 对象都可以作为锁，

1. 普通同步方法，锁就是当前实力对象(this对象)
2. 静态同步方法，锁是当前Class对象(.class对象)
3. 同步方法块，锁是 synchronized 括号内部配置的对象

所以说，synchronized 锁住的都是对象。

## synchronized 实现原理

Synchronized 代码块的实现是通过监视器实现的。使用 monitorenter 和 monitorexit 这两个指令来实现的，而且这两条指令必须成对出现。

- monitorenter 指令在编译后插入到同步代码块的开始位置

- monitorexit 指令是出入在异常处和结束位置

### Java 对象头

Synchronized 锁是存在 Java对象头里的。
  
- 如果是对象，占用2个字来存储
- 如果是数组，占用3个字来存储

|长度|内容|说明|
|:--:|:-:|:-:|
|32/64bit|Mark Word|存储对象的hashCode或者锁信息|
|32/64bit|Class Metadata Address|存储到对象类型的指针|
|32/64bit|Array length|数组才有的选项，存储数组的长度|

### 锁的升级

Synchronized 锁一共有4种状态，逐次升级。
级别由低到高：

1. 无锁状态
2. 偏向锁
3. 轻量级锁
4. 重量级锁

#### 偏向锁

多数情况下，锁是不存在多线程竞争的，并且一个锁总是由同一个线程获得。偏向锁只是在对象头和 栈帧中记录线程ID，之后只是简单测试对象头中的 Mark Word 里是否记录的是指向当前线程的偏向锁。

- 测试成功，说明线程已经获取了该锁
- 测试失败，继续测试 Mark Word 中偏向锁的标识是否为1:
  - 如果为1，尝试使用CAS 将对象头的偏向锁指向当前线程
  - 如果不为1， 则使用CAS竞争锁，也就是轻量级锁

##### 撤销偏向锁

- 等到竞争出现才释放锁机制
- 需要等到全局安全点  
- 暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着
  - 如果线程不处于活动状态，对象头设置成无锁状态
  - 如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向于其他线程， 要么恢复到无锁或者标记对象不适合作为偏向锁
- 唤醒暂停的线程

##### 关闭偏向锁

- 关闭延迟：-XX: BiasedLockingStartupDelay=0
- 关闭偏向锁： -XX:UseBiasedLocing=false

#### 轻量级锁

- 线程在执行同步块时，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间
- 对象头中的Mark Word 复制到锁记录中，称为 Displaced Mark Word
- 线程尝试使用CAS将对象头中的Mark Word 替换为指向锁记录的指针
- 如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前县城变尝试使用自旋来获取锁

#### 轻量级锁解锁

- 使用原子的CAS操作将 Displaced Mark Word 替换回对象头
- 如果成功，表示没有竞争发生；如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁
- 锁升级成重量级锁，不会恢复到轻量级锁状态

#### 重量级锁

- 不使用自旋锁，不会消耗CPU
- 其他线程试图获取都会阻塞住

# 小结

一开始只是使用偏向锁对锁进行处理，如果出现了竞争，则使用轻量级锁进行处理，轻量级锁进行CAS处理自旋，消耗CPU；如果解锁失败就会膨胀为重量级锁