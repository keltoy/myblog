<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Toy&#39;s Blogs</title>
        <link>http://keltoy.github.io/posts/</link>
        <description>Recent content in Posts on Toy&#39;s Blogs</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Thu, 27 Aug 2020 20:40:45 +0800</lastBuildDate>
        <atom:link href="http://keltoy.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Spark_内存管理</title>
            <link>http://keltoy.github.io/posts/spark_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
            <pubDate>Thu, 27 Aug 2020 20:40:45 +0800</pubDate>
            
            <guid>http://keltoy.github.io/posts/spark_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
            <description>前言 Spark是基于内存的计算引擎，就是说它高效的使用了分布式节点上的内存资源，尽可能多的使用内存，而不是将数据写入磁盘。内存管理机制就是其中的核心Spark 是基于内存进行处理，不用每次计算后写入磁盘，再取出来进行计算，这样就节省了IO时间，所有的临时数据都放在内存中。
Spark管理的内存  系统区，Spark运行自身的代码需要的空间 用户区，udf等代码需要一定的空间来执行 存储区，为了计算速度加快，Spark会将存储的数据放入内存中进行计算，存储区就是为了放入数据使用的 执行区，Spark操作数据的单元是partition，Spark在执行一些shuffle、join、sort、aggregation之类的操作，需要把partition加载到内存进行计算，会用到部分内存  总结 </description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>Spark是基于内存的计算引擎，就是说它高效的使用了分布式节点上的内存资源，尽可能多的使用内存，而不是将数据写入磁盘。内存管理机制就是其中的核心Spark 是基于内存进行处理，不用每次计算后写入磁盘，再取出来进行计算，这样就节省了IO时间，所有的临时数据都放在内存中。</p>
<h1 id="spark管理的内存">Spark管理的内存</h1>
<ul>
<li>系统区，Spark运行自身的代码需要的空间</li>
<li>用户区，udf等代码需要一定的空间来执行</li>
<li>存储区，为了计算速度加快，Spark会将存储的数据放入内存中进行计算，存储区就是为了放入数据使用的</li>
<li>执行区，Spark操作数据的单元是partition，Spark在执行一些shuffle、join、sort、aggregation之类的操作，需要把partition加载到内存进行计算，会用到部分内存</li>
</ul>
<h1 id="总结">总结</h1>
]]></content>
        </item>
        
        <item>
            <title>Kylin_And_Doris</title>
            <link>http://keltoy.github.io/posts/kylin_and_doris/</link>
            <pubDate>Mon, 03 Aug 2020 16:10:51 +0800</pubDate>
            
            <guid>http://keltoy.github.io/posts/kylin_and_doris/</guid>
            <description>[toc]
前言 Kylin 和 Doris 都是 开源OLAP 对比这两款数据库，实际上也是是 MOLAP 和 ROLAP的代表
​ MOLAP (Multidimension OLAP)，存储模式使得分区的聚合和其源数据的复本以多维结构存储在分析服务器计算机上
​ ROLAP (Relational OLAP)，存储模式使得分区的聚合存储在关系数据库的表（在分区数据源中指定）中
​ HOLAP (Hybrid OLAP)，支持所有的三种存储模式。应用存储设计向导，可以选择最适合于分区的存储模式。或者也可使用基于使用的优化向导，以便根据已发送到多维数据集的查询选择存储模式并优化聚合设计。当使用三种存储模式之一时，还可以使用显式定义的筛选来限制读入到分区内的源数据
MOLAP  概述：  这是OLAP分析的传统方式。在MOLAP中，数据存储在一个多维数据集(cube)中，存储并不是在传统的关系型数据库中，而是自定义的格式。
 优势：  卓越的性能：MOLAP cubes为了快速数据检索而构建，具有最佳的slicing dicing操作
可以执行复杂的计算：所有的计算都在创建多维数据表时预先生成。因此，复杂的计算不仅可行，而且迅速
 劣势：  它可以处理的数据量有限：因为所有的计算都是执行在构建的多维数据集上，多维数据集本身不可能包括大量的数据。当然这并不是大数据不能派生出多维数据集。事实上，这是可以的。但是在这种情况下，只有汇总的信息能够包含在多维数据集中。
需要额外的成本：多维数据集技术往往是有专利或现在并不存在在某个组织中。因此，要想采用MOLAP技术，通常是要付出额外的人力和资源成本。
ROLAP  概述：  这种方法依赖于操作存储在关系型数据库中的数据，给传统的OLAP slicing 和 dicing功能。本质上，每个slicing或dicing功能和SQL语句中&amp;quot;WHERE&amp;quot;子句的功能是一样的。
 优势：  可以处理大数据量：ROLAP技术的数据量大小就是底层关系数据库存储的大小。换句话说，ROLAP本身没有对数据量的限制。
可以利用关系型数据库所固有的功能：关系型数据库已经具备非常多的功能。ROLAP技术，由于它是建立在关系型数据库上的，因此可以使用这些功能。
 劣势：  性能可能会很慢：因为每个ROLAP包裹实际上是一个SQL查询（或多个SQL查询）关系数据库，可能会因为底层数据量很大，使得查询的时间很长。
受限于SQL的功能：因为ROLAP技术主要依赖于生成SQL语句查询关系数据库，SQL语句并不能满足所有的需求（举例来说，使用SQL很难执行复杂的计算），ROLAP技术因此受限于SQL所能做的事情。ROLAP厂商已经通过构建工具以减轻这种风险，而且允许用户自定义函数。
HOLAP  概述：  HOLAP技术试图将MOLAP和ROLAP技术的优势结合起来。总体来说，HOLAP利用了多维数据集的技术从而得到更快的性能。
当需要详细信息时，HOLAP可以从多维数据集“穿过”到底层的关系数据库。</description>
            <content type="html"><![CDATA[<p>[toc]</p>
<h1 id="前言">前言</h1>
<p>Kylin 和 Doris 都是 开源OLAP 对比这两款数据库，实际上也是是 MOLAP 和 ROLAP的代表</p>
<p>​    MOLAP (Multidimension OLAP)，存储模式使得分区的聚合和其源数据的复本以多维结构存储在分析服务器计算机上</p>
<p>​    ROLAP (Relational OLAP)，存储模式使得分区的聚合存储在关系数据库的表（在分区数据源中指定）中</p>
<p>​    HOLAP (Hybrid OLAP)，支持所有的三种存储模式。应用存储设计向导，可以选择最适合于分区的存储模式。或者也可使用基于使用的优化向导，以便根据已发送到多维数据集的查询选择存储模式并优化聚合设计。当使用三种存储模式之一时，还可以使用显式定义的筛选来限制读入到分区内的源数据</p>
<h1 id="molap">MOLAP</h1>
<ul>
<li>概述：</li>
</ul>
<p>这是OLAP分析的传统方式。在MOLAP中，数据存储在一个多维数据集(cube)中，存储并不是在传统的关系型数据库中，而是自定义的格式。</p>
<ul>
<li>优势：</li>
</ul>
<p>卓越的性能：MOLAP cubes为了快速数据检索而构建，具有最佳的slicing dicing操作</p>
<p>可以执行复杂的计算：所有的计算都在创建多维数据表时预先生成。因此，复杂的计算不仅可行，而且迅速</p>
<ul>
<li>劣势：</li>
</ul>
<p>它可以处理的数据量有限：因为所有的计算都是执行在构建的多维数据集上，多维数据集本身不可能包括大量的数据。当然这并不是大数据不能派生出多维数据集。事实上，这是可以的。但是在这种情况下，只有汇总的信息能够包含在多维数据集中。</p>
<p>需要额外的成本：多维数据集技术往往是有专利或现在并不存在在某个组织中。因此，要想采用MOLAP技术，通常是要付出额外的人力和资源成本。</p>
<h1 id="rolap">ROLAP</h1>
<ul>
<li>概述：</li>
</ul>
<p>这种方法依赖于操作存储在关系型数据库中的数据，给传统的OLAP slicing 和 dicing功能。本质上，每个slicing或dicing功能和SQL语句中&quot;WHERE&quot;子句的功能是一样的。</p>
<ul>
<li>优势：</li>
</ul>
<p>可以处理大数据量：ROLAP技术的数据量大小就是底层关系数据库存储的大小。换句话说，ROLAP本身没有对数据量的限制。</p>
<p>可以利用关系型数据库所固有的功能：关系型数据库已经具备非常多的功能。ROLAP技术，由于它是建立在关系型数据库上的，因此可以使用这些功能。</p>
<ul>
<li>劣势：</li>
</ul>
<p>性能可能会很慢：因为每个ROLAP包裹实际上是一个SQL查询（或多个SQL查询）关系数据库，可能会因为底层数据量很大，使得查询的时间很长。</p>
<p>受限于SQL的功能：因为ROLAP技术主要依赖于生成SQL语句查询关系数据库，SQL语句并不能满足所有的需求（举例来说，使用SQL很难执行复杂的计算），ROLAP技术因此受限于SQL所能做的事情。ROLAP厂商已经通过构建工具以减轻这种风险，而且允许用户自定义函数。</p>
<h1 id="holap">HOLAP</h1>
<ul>
<li>概述：</li>
</ul>
<p>HOLAP技术试图将MOLAP和ROLAP技术的优势结合起来。总体来说，HOLAP利用了多维数据集的技术从而得到更快的性能。</p>
<p>当需要详细信息时，HOLAP可以从多维数据集“穿过”到底层的关系数据库。</p>
]]></content>
        </item>
        
        <item>
            <title>Sequence Parquet And Avro</title>
            <link>http://keltoy.github.io/posts/sequence-parquet-and-avro/</link>
            <pubDate>Fri, 24 Jul 2020 17:54:40 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/sequence-parquet-and-avro/</guid>
            <description>[toc]
背景 大数据常用文件格式，在hive spark 使用时都需要注意，现在在使用flink 的时候发现格式问题还挺头疼的，准备整理整理，认清楚各个文件格式是怎么一回事
文件格式 Sequence File  sequenceFile文件是Hadoop用来存储二进制形式的[Key,Value]对而设计的一种平面文件(Flat File)。 可以把SequenceFile当做是一个容器，把所有的文件打包到SequenceFile类中可以高效的对小文件进行存储和处理。 SequenceFile文件并不按照其存储的Key进行排序存储，SequenceFile的内部类Writer提供了append功能。 SequenceFile中的Key和Value可以是任意类型Writable或者是自定义Writable。 在存储结构上，SequenceFile主要由一个Header后跟多条Record组成，Header主要包含了Key classname，value classname，存储压缩算法，用户自定义元数据等信息，此外，还包含了一些同步标识，用于快速定位到记录的边界。每条Record以键值对的方式进行存储，用来表示它的字符数组可以一次解析成：记录的长度、Key的长度、Key值和value值，并且Value值的结构取决于该记录是否被压缩。  Sequence File 有3中压缩方式
 无压缩：不启用压缩，那么每个记录就由它的记录长度、键的长度，和键、值组成 记录压缩 ：和无压缩格式基本相同，不同的是值字节是用定义在头部的编码器来压缩的  块压缩：块压缩一次多个记录，因此比记录压缩更紧凑，推荐  Parquet Apache Parquet是一种能够有效存储嵌套数据的列式存储格式。
 Parquet文件由一个文件头（header），一个或多个紧随其后的文件块（block），以及一个用于结尾的文件尾（footer）构成。 Parquet文件的每个文件块负责存储一个行组，行组由列块组成，且一个列块负责存储一列数据。每个列块中的的数据以页为单位。 行组 可以理解为一个个block，这个特性让parquet是可分割的，因此可以被mapreduce split来处理 不论是行组，还是page，都有具体的统计信息，根据这些统计信息可以做很多优化 每个行组由一个个 Column chunk组成，也就是一个个列。Column chunk又细分成一个个page，每个page下就是该列的数据集合。列下面再细分page主要是为了添加索引，page容量设置的小一些可以增加索引的速度，但是设置太小也会导致过多的索引和统计数据，不仅占用空间，还会降低扫描索引的时间。 parquet可以支持嵌套的数据结构，它使用了Dremel的 Striping/Assembly 算法来实现对嵌套型数据结构的打散和重构 parquet的索引和元数据全部放在footer块  Avro avro文件格式大致如下
 header, followed by one or more file data blocks  其中，datablock又可分为
 numEntries：该datablock中的记录条数； blockSize：该datablock的大小； data：存储的数据； sync：同步位  整个avro的文件布局如下：
与Thrift 的区别：</description>
            <content type="html"><![CDATA[<p>[toc]</p>
<h1 id="背景">背景</h1>
<p>大数据常用文件格式，在hive spark 使用时都需要注意，现在在使用flink 的时候发现格式问题还挺头疼的，准备整理整理，认清楚各个文件格式是怎么一回事</p>
<h1 id="文件格式">文件格式</h1>
<h2 id="sequence-file">Sequence File</h2>
<ul>
<li>sequenceFile文件是Hadoop用来存储二进制形式的[Key,Value]对而设计的一种平面文件(Flat File)。</li>
<li>可以把SequenceFile当做是一个容器，把所有的文件打包到SequenceFile类中可以高效的对小文件进行存储和处理。</li>
<li>SequenceFile文件并不按照其存储的Key进行排序存储，SequenceFile的内部类Writer提供了append功能。</li>
<li>SequenceFile中的Key和Value可以是任意类型Writable或者是自定义Writable。</li>
<li>在存储结构上，SequenceFile主要由一个Header后跟多条Record组成，Header主要包含了Key classname，value classname，存储压缩算法，用户自定义元数据等信息，此外，还包含了一些同步标识，用于快速定位到记录的边界。每条Record以键值对的方式进行存储，用来表示它的字符数组可以一次解析成：记录的长度、Key的长度、Key值和value值，并且Value值的结构取决于该记录是否被压缩。</li>
</ul>
<p>Sequence File 有3中压缩方式</p>
<ol>
<li>无压缩：不启用压缩，那么每个记录就由它的记录长度、键的长度，和键、值组成</li>
<li>记录压缩 ：和无压缩格式基本相同，不同的是值字节是用定义在头部的编码器来压缩的 <img src="/2018092711023447.jpeg" alt="2018092711023447"></li>
<li>块压缩：块压缩一次多个记录，因此比记录压缩更紧凑，推荐<img src="/2018092711030968.jpeg" alt="2018092711030968"></li>
</ol>
<h2 id="parquet">Parquet</h2>
<p>Apache Parquet是一种能够有效存储嵌套数据的列式存储格式。</p>
<ul>
<li>Parquet文件由一个文件头（header），一个或多个紧随其后的文件块（block），以及一个用于结尾的文件尾（footer）构成。</li>
<li>Parquet文件的每个文件块负责存储一个行组，行组由列块组成，且一个列块负责存储一列数据。每个列块中的的数据以页为单位。</li>
<li>行组 可以理解为一个个block，这个特性让parquet是可分割的，因此可以被mapreduce split来处理</li>
<li>不论是行组，还是page，都有具体的统计信息，根据这些统计信息可以做很多优化</li>
<li>每个行组由一个个 Column chunk组成，也就是一个个列。Column chunk又细分成一个个page，每个page下就是该列的数据集合。列下面再细分page主要是为了添加索引，page容量设置的小一些可以增加索引的速度，但是设置太小也会导致过多的索引和统计数据，不仅占用空间，还会降低扫描索引的时间。</li>
<li>parquet可以支持嵌套的数据结构，它使用了Dremel的 Striping/Assembly 算法来实现对嵌套型数据结构的打散和重构</li>
<li>parquet的索引和元数据全部放在footer块</li>
</ul>
<p><img src="/image-20200727163014664.png" alt="image-20200727163014664"></p>
<h2 id="avro">Avro</h2>
<p>avro文件格式大致如下</p>
<ol>
<li>header, followed by</li>
<li>one or more file data blocks</li>
</ol>
<p>其中，datablock又可分为</p>
<ol>
<li>numEntries：该datablock中的记录条数；</li>
<li>blockSize：该datablock的大小；</li>
<li>data：存储的数据；</li>
<li>sync：同步位</li>
</ol>
<p>整个avro的文件布局如下：</p>
<p><img src="/image-20200727170432036.png" alt="image-20200727170432036"></p>
<p>与Thrift 的区别：</p>
<p>Avro和Thrift都是跨语言，基于二进制的高性能的通讯中间件. 它们都提供了数据序列化的功能和RPC服务. 总体功能上类似，但是哲学不一样. Thrift出自Facebook用于后台各个服务间的通讯,Thrift的设计强调统一的编程接口的多语言通讯框架. Avro出自Hadoop之父Doug Cutting, 在Thrift已经相当流行的情况下Avro的推出，其目标不仅是提供一套类似Thrift的通讯中间件更是要建立一个新的，标准性的云计算的数据交换和存储的Protocol。 这个和Thrift的理念不同，Thrift认为没有一个完美的方案可以解决所有问题，因此尽量保持一个Neutral框架，插入不同的实现并互相交互。而Avro偏向实用，排斥多种方案带来的 可能的混乱，主张建立一个统一的标准，并不介意采用特定的优化。Avro的创新之处在于融合了显式,declarative的Schema和高效二进制的数据表达，强调数据的自我描述，克服了以往单纯XML或二进制系统的缺陷。Avro对Schema动态加载功能，是Thrift编程接口所不具备的，符合了Hadoop上的Hive/Pig及NOSQL 等既属于ad hoc，又追求性能的应用需求.</p>
<h1 id="总结">总结</h1>
<p>Sequence File 和 Parquet File 实际上只是对于数据的存储压缩等做了限制，而Aveo 实际上也做了对数据的格式的限制</p>
]]></content>
        </item>
        
        <item>
            <title>大数据框架</title>
            <link>http://keltoy.github.io/posts/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/</link>
            <pubDate>Wed, 01 Jul 2020 10:40:25 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/</guid>
            <description>大数据框架 [toc]
背景 做数据处理不能只是出报表，有很多东西还需要去处理，比如用户画像，比如数据分析，比如推荐系统，比如数据仓库。
现在处理数据不像原来，只需要处理离线数据，这样报表也只能出T-1天的数据，很多时候，我们希望能看到实时数据。这样就会出现一些问题：
更新频率，一天、一小时更新，这样可以不使用实时处理，可能体现不了实时的意义；如果都改成流数据处理，更新频率可以到达分钟，秒级，但是数据量不全，缺少历史数据，可能不能保证准确性。因此需要设计一种架构技能满足实时处理，又要保证历史数据准确。
Lambda 框架 Lambda架构的设计为了处理大规模数据时，同时发挥流数据处理和批处理的优势。通过离线批处理提供全面、准确的数据；通过实时流处理提供低延迟的数据，达到平衡延迟、吞吐量和容错性的目的。
Lambda架构包含3层Batch Layer， Speed Layer，Serving Layer
 Batch Layer: 批处理层，对离线的历史数据进行预结算，为了下游能够快速查询想要的结果。由于批处理基于完整的历史数据集因此准确性可以得到保证。批处理可以用Hadoop/Spark/Flink等框架计算 Speed Layer: 加速处理层，处理实时的增量数据，这一层重点在于低延迟。加速层的数据不如批处理那样完整和准确，但是可以填补批处理高延迟导致的数据的空白。加速层可以使用 Storm/Spark streaming/Flink等计算框架 Serving Layer: 合并服务层 合并层将批处理和加速层的的数据合并，输出出来或者提供给下游来分析  IBM 使用的一套Lambda
Lambda 的出现，很好地解决了离线与实时处理二者都能发挥出功效，离线批处理 和 实时数据 都体现了各自的优势，晚上可以跑离线任务，而实时任务一般也是集中在白天，让实时成本可控，且错开了高峰时间
不过随着时代的发展，Lambda 面对当前复杂的业务分析需求逐渐力不从心，暴露出了以下几个问题：
 实时与批量计算结果不一致引起的数据口径不一致 批量计算在晚上计算窗口内无法完成 开发和维护复杂，烟囱式开发没份数据需要至少处理2次 服务器内存大  Kappa框架 Kappa架构 简化了Lambda架构。Kappa架构系统是删除了批处理系统的架构。要取代批处理，数据只需通过流式传输系统快速提供：
那如何用流计算系统对全量数据进行重新计算，步骤如下：
  用Kafka或类似的分布式队列保存数据，需要几天数据量就保存几天。
  当需要全量计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个结果存储中。
  当新的实例完成后，停止老的流计算实例，并把老的一引起结果删除。
  和Lambda架构相比，在Kappa架构下，只有在有必要的时候才会对历史数据进行重复计算，并且实时计算和批处理过程使用的是同一份代码。或许有些人会质疑流式处理对于历史数据的高吞吐量会力不从心，但是这可以通过控制新实例的并发数进行改善。
Kappa架构的核心思想包括以下三点：
  用Kafka或者类似的分布式队列系统保存数据，你需要几天的数据量就保存几天。
  当需要全量重新计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个新的结果存储中。
  当新的实例做完后，停止老的流计算实例，并把老的一些结果删除。
  Iota 框架 在IOT大潮下，智能手机、PC、智能硬件设备的计算能力越来越强，而业务需求要求数据实时响应需求能力也越来越强，过去传统的中心化、非实时化数据处理的思路已经不适应现在的大数据分析需求，我提出新一代的大数据IOTA架构来解决上述问题，整体思路是设定标准数据模型，通过边缘计算技术把所有的计算过程分散在数据产生、计算和查询过程当中，以统一的数据模型贯穿始终，从而提高整体的预算效率，同时满足即时计算的需要，可以使用各种Ad-hoc Query来查询底层数据</description>
            <content type="html"><![CDATA[<h1 id="大数据框架">大数据框架</h1>
<p>[toc]</p>
<h2 id="背景">背景</h2>
<p>做数据处理不能只是出报表，有很多东西还需要去处理，比如用户画像，比如数据分析，比如推荐系统，比如数据仓库。</p>
<p>现在处理数据不像原来，只需要处理离线数据，这样报表也只能出T-1天的数据，很多时候，我们希望能看到实时数据。这样就会出现一些问题：</p>
<p>更新频率，一天、一小时更新，这样可以不使用实时处理，可能体现不了实时的意义；如果都改成流数据处理，更新频率可以到达分钟，秒级，但是数据量不全，缺少历史数据，可能不能保证准确性。因此需要设计一种架构技能满足实时处理，又要保证历史数据准确。</p>
<h2 id="lambda-框架">Lambda 框架</h2>
<p>Lambda架构的设计为了处理大规模数据时，同时发挥流数据处理和批处理的优势。通过离线批处理提供全面、准确的数据；通过实时流处理提供低延迟的数据，达到平衡延迟、吞吐量和容错性的目的。</p>
<p>Lambda架构包含3层Batch Layer， Speed Layer，Serving Layer</p>
<p><img src="/lambda.jpg" alt="lambda"></p>
<ul>
<li>Batch Layer: 批处理层，对离线的历史数据进行预结算，为了下游能够快速查询想要的结果。由于批处理基于完整的历史数据集因此准确性可以得到保证。批处理可以用Hadoop/Spark/Flink等框架计算</li>
<li>Speed Layer: 加速处理层，处理实时的增量数据，这一层重点在于低延迟。加速层的数据不如批处理那样完整和准确，但是可以填补批处理高延迟导致的数据的空白。加速层可以使用 Storm/Spark streaming/Flink等计算框架</li>
<li>Serving Layer: 合并服务层 合并层将批处理和加速层的的数据合并，输出出来或者提供给下游来分析</li>
</ul>
<p><img src="/v2-22ac450d4620a9f7e644d5bb3c065774_720w.jpg" alt="v2-22ac450d4620a9f7e644d5bb3c065774_720w"></p>
<p>IBM 使用的一套Lambda</p>
<p>Lambda 的出现，很好地解决了离线与实时处理二者都能发挥出功效，离线批处理 和 实时数据 都体现了各自的优势，晚上可以跑离线任务，而实时任务一般也是集中在白天，让实时成本可控，且错开了高峰时间</p>
<p>不过随着时代的发展，Lambda 面对当前复杂的业务分析需求逐渐力不从心，暴露出了以下几个问题：</p>
<ol>
<li>实时与批量计算结果不一致引起的数据口径不一致</li>
<li>批量计算在晚上计算窗口内无法完成</li>
<li>开发和维护复杂，烟囱式开发没份数据需要至少处理2次</li>
<li>服务器内存大</li>
</ol>
<h2 id="kappa框架">Kappa框架</h2>
<p><a href="http://milinda.pathirage.org/kappa-architecture.com/">Kappa架构</a> 简化了<a href="http://lambda-architecture.net/">Lambda架构</a>。<a href="http://milinda.pathirage.org/kappa-architecture.com/">Kappa架构</a>系统是删除了批处理系统的架构。要取代批处理，数据只需通过流式传输系统快速提供：</p>
<p><img src="/20190702150038971.png" alt="20190702150038971"></p>
<p>那如何用流计算系统对全量数据进行重新计算，步骤如下：</p>
<ol>
<li>
<p>用Kafka或类似的分布式队列保存数据，需要几天数据量就保存几天。</p>
</li>
<li>
<p>当需要全量计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个结果存储中。</p>
</li>
<li>
<p>当新的实例完成后，停止老的流计算实例，并把老的一引起结果删除。</p>
</li>
</ol>
<p>和Lambda架构相比，在Kappa架构下，只有在有必要的时候才会对历史数据进行重复计算，并且实时计算和批处理过程使用的是同一份代码。或许有些人会质疑流式处理对于历史数据的高吞吐量会力不从心，但是这可以通过控制新实例的并发数进行改善。</p>
<p>Kappa架构的核心思想包括以下三点：</p>
<ul>
<li>
<p>用Kafka或者类似的分布式队列系统保存数据，你需要几天的数据量就保存几天。</p>
</li>
<li>
<p>当需要全量重新计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个新的结果存储中。</p>
</li>
<li>
<p>当新的实例做完后，停止老的流计算实例，并把老的一些结果删除。</p>
</li>
</ul>
<h2 id="iota-框架">Iota 框架</h2>
<p>在IOT大潮下，智能手机、PC、智能硬件设备的计算能力越来越强，而业务需求要求数据实时响应需求能力也越来越强，过去传统的中心化、非实时化数据处理的思路已经不适应现在的大数据分析需求，我提出新一代的大数据IOTA架构来解决上述问题，整体思路是设定标准数据模型，通过边缘计算技术把所有的计算过程分散在数据产生、计算和查询过程当中，以统一的数据模型贯穿始终，从而提高整体的预算效率，同时满足即时计算的需要，可以使用各种Ad-hoc Query来查询底层数据</p>
<h2 id="46858-a76c62b91f0f40a946858-a76c62b91f0f40a9png"><img src="/46858-a76c62b91f0f40a9.png" alt="46858-a76c62b91f0f40a9"></h2>
<p>IOTA整体技术结构分为几部分：</p>
<p>● Common Data Model：贯穿整体业务始终的数据模型，这个模型是整个业务的核心，要保持SDK、cache、历史数据、查询引擎保持一致。对于用户数据分析来讲可以定义为“主-谓-宾”或者“对象-事件”这样的抽象模型来满足各种各样的查询。以大家熟悉的APP用户模型为例，用“主-谓-宾”模型描述就是“X用户 – 事件1 – A页面（2018/4/11 20:00） ”。当然，根据业务需求的不同，也可以使用“产品-事件”、“地点-时间”模型等等。模型本身也可以根据协议（例如 protobuf）来实现SDK端定义，中央存储的方式。此处核心是，从SDK到存储到处理是统一的一个Common Data Model。</p>
<p>● Edge SDKs &amp; Edge Servers：这是数据的采集端，不仅仅是过去的简单的SDK，在复杂的计算情况下，会赋予SDK更复杂的计算，在设备端就转化为形成统一的数据模型来进行传送。例如对于智能Wi-Fi采集的数据，从AC端就变为“X用户的MAC 地址-出现- A楼层（2018/4/11 18:00）”这种主-谓-宾结构，对于摄像头会通过Edge AI Server，转化成为“X的Face特征- 进入- A火车站（2018/4/11 20:00）”。也可以是上面提到的简单的APP或者页面级别的“X用户 – 事件1 – A页面（2018/4/11 20:00） ”，对于APP和H5页面来讲，没有计算工作量，只要求埋点格式即可。</p>
<p>● Real Time Data：实时数据缓存区，这部分是为了达到实时计算的目的，海量数据接收不可能海量实时入历史数据库，那样会出现建立索引延迟、历史数据碎片文件等问题。因此，有一个实时数据缓存区来存储最近几分钟或者几秒钟的数据。这块可以使用Kudu或者Hbase等组件来实现。这部分数据会通过Dumper来合并到历史数据当中。此处的数据模型和SDK端数据模型是保持一致的，都是Common Data Model，例如“主-谓-宾”模型。</p>
<p>● Historical Data：历史数据沉浸区，这部分是保存了大量的历史数据，为了实现Ad-hoc查询，将自动建立相关索引提高整体历史数据查询效率，从而实现秒级复杂查询百亿条数据的反馈。例如可以使用HDFS存储历史数据，此处的数据模型依然SDK端数据模型是保持一致的Common Data Model。</p>
<p>● Dumper：Dumper的主要工作就是把最近几秒或者几分钟的实时数据，根据汇聚规则、建立索引，存储到历史存储结构当中，可以使用map reduce、C、Scala来撰写，把相关的数据从Realtime Data区写入Historical Data区。</p>
<p>● Query Engine：查询引擎，提供统一的对外查询接口和协议（例如SQL JDBC），把Realtime Data和Historical Data合并到一起查询，从而实现对于数据实时的Ad-hoc查询。例如常见的计算引擎可以使用presto、impala、clickhouse等。</p>
<p>● Realtime model feedback：通过Edge computing技术，在边缘端有更多的交互可以做，可以通过在Realtime Data去设定规则来对Edge SDK端进行控制，例如，数据上传的频次降低、语音控制的迅速反馈，某些条件和规则的触发等等。简单的事件处理，将通过本地的IOT端完成，例如，嫌疑犯的识别现在已经有很多摄像头本身带有此功能。</p>
<p>IOTA大数据架构，主要有如下几个特点：</p>
<p>● 去ETL化：ETL和相关开发一直是大数据处理的痛点，IOTA架构通过Common Data Model的设计，专注在某一个具体领域的数据计算，从而可以从SDK端开始计算，中央端只做采集、建立索引和查询，提高整体数据分析的效率。</p>
<p>● Ad-hoc即时查询：鉴于整体的计算流程机制，在手机端、智能IOT事件发生之时，就可以直接传送到云端进入real time data区，可以被前端的Query Engine来查询。此时用户可以使用各种各样的查询，直接查到前几秒发生的事件，而不用在等待ETL或者Streaming的数据研发和处理。</p>
<p>● 边缘计算（Edge-Computing）：将过去统一到中央进行整体计算，分散到数据产生、存储和查询端，数据产生既符合Common Data Model。同时，也给与Realtime model feedback，让客户端传送数据的同时马上进行反馈，而不需要所有事件都要到中央端处理之后再进行下发。</p>
<h2 id="总结">总结</h2>
<p>这就是网上比较常见的3中框架对于目前的工作，可能不能实现其全部，但是这样的一个演进过程，是值得我们学习和指引的</p>
]]></content>
        </item>
        
        <item>
            <title>HBase 个人总结</title>
            <link>http://keltoy.github.io/posts/hbase-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</link>
            <pubDate>Wed, 24 Jun 2020 17:39:30 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/hbase-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</guid>
            <description>思维导图</description>
            <content type="html"><![CDATA[<p><img src="/hbase.png" alt="HBase.png"></p>
<p><a href="/Hbase.emmx">思维导图</a></p>
]]></content>
        </item>
        
        <item>
            <title>jmap jstack jstat</title>
            <link>http://keltoy.github.io/posts/jmap-jstack-jstat/</link>
            <pubDate>Thu, 21 May 2020 16:03:03 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/jmap-jstack-jstat/</guid>
            <description>[toc]
jps (Java Virtual Machine Process) 用来输出JVM 进程状态信息
jps [options] [hostid] 如果不指定 hostid 那么久默认当前服务器
option 命令：
 -q 不输出类名，jar名和传入main方法的参数 -m 输出传入main方法的参数 -l 输出main类或者Jar的权限名 -v 输出传入JVM的参数  jmap（查看内存，对象） 可以输出所有内存中对象的工具，甚至是将VM 中的heap，以二进制输出成文本；打印出某个java进程(pid)内存中的所有对象的情况
jmap [option] pid jmap [option] executable core jmap [option] [service-id@]remote-hostname-or-IP 其中：
 option 选项参数 pid 打印配置信息的进程id executable 产生核心dump的java 可执行文件 core 需要打印配置信息的核心文件 server-id 可选唯一id，如果相同的远程主机上运行了多台调试服务器，可以用来标识服务器 remote-hostname-or-IP 远程调试服务器的主机名或ip  option的取值有：
 &amp;lt;none&amp;gt; 查看进程的内存映像信息 -heap 显示java堆详细信息 -histo[:live] 统计java对象堆的直方图 -clstats 打印类加载器信息 -finalizerinfo 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象 dump:&amp;lt;dump-options&amp;gt; 生成堆转储快照 F: 当-dump没有响应时， 使用 -dump 或者 -histo参数。在这个模式下,live子参数无效.</description>
            <content type="html"><![CDATA[<p>[toc]</p>
<h2 id="jps-java-virtual-machine-process">jps (Java Virtual Machine Process)</h2>
<p>用来输出JVM 进程状态信息</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">jps <span style="color:#f92672">[</span>options<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>hostid<span style="color:#f92672">]</span>
</code></pre></div><p>如果不指定 hostid 那么久默认当前服务器</p>
<p>option 命令：</p>
<ul>
<li>-q 不输出类名，jar名和传入main方法的参数</li>
<li>-m 输出传入main方法的参数</li>
<li>-l 输出main类或者Jar的权限名</li>
<li>-v 输出传入JVM的参数</li>
</ul>
<h2 id="jmap查看内存对象">jmap（查看内存，对象）</h2>
<p>可以输出所有内存中对象的工具，甚至是将VM 中的heap，以二进制输出成文本；打印出某个java进程(pid)内存中的所有对象的情况</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">jmap <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> pid
jmap <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> executable core
jmap <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>service-id@<span style="color:#f92672">]</span>remote-hostname-or-IP

</code></pre></div><p>其中：</p>
<ul>
<li>option 选项参数</li>
<li>pid 打印配置信息的进程id</li>
<li>executable 产生核心dump的java 可执行文件</li>
<li>core 需要打印配置信息的核心文件</li>
<li>server-id 可选唯一id，如果相同的远程主机上运行了多台调试服务器，可以用来标识服务器</li>
<li>remote-hostname-or-IP 远程调试服务器的主机名或ip</li>
</ul>
<p>option的取值有：</p>
<ul>
<li>&lt;none&gt; 查看进程的内存映像信息</li>
<li>-heap 显示java堆详细信息</li>
<li>-histo[:live] 统计java对象堆的直方图</li>
<li>-clstats 打印类加载器信息</li>
<li>-finalizerinfo 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li>
<li>dump:&lt;dump-options&gt; 生成堆转储快照</li>
<li>F: 当-dump没有响应时， 使用 -dump 或者 -histo参数。在这个模式下,live子参数无效.</li>
<li>J&lt;flag&gt; 指定传递给运行jmap的JVM的参数</li>
</ul>
<h2 id="jstack查看线程">jstack（查看线程）</h2>
<p>jstack 能获得运行java程序的java stack 和native stack</p>
<p>与jmap 类似，可以查看进程id中的信息</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">jstack <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> pid
jstack <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> executable core
jstack <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>service-id@<span style="color:#f92672">]</span>remote-hostname-or-IP

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">jstack <span style="color:#f92672">[</span>-l<span style="color:#f92672">]</span> &lt;pid&gt;
        <span style="color:#f92672">(</span>to connect to running process<span style="color:#f92672">)</span> 连接活动线程
    jstack -F <span style="color:#f92672">[</span>-m<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-l<span style="color:#f92672">]</span> &lt;pid&gt;
        <span style="color:#f92672">(</span>to connect to a hung process<span style="color:#f92672">)</span> 连接阻塞线程
    jstack <span style="color:#f92672">[</span>-m<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-l<span style="color:#f92672">]</span> &lt;executable&gt; &lt;core&gt;
        <span style="color:#f92672">(</span>to connect to a core file<span style="color:#f92672">)</span> 连接dump的文件
    jstack <span style="color:#f92672">[</span>-m<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-l<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>server_id@<span style="color:#f92672">]</span>&lt;remote server IP or hostname&gt;
        <span style="color:#f92672">(</span>to connect to a remote debug server<span style="color:#f92672">)</span> 连接远程服务器
</code></pre></div><p>option 的取值</p>
<ul>
<li>-l 长列表，展示关于锁的额外信息</li>
<li>-F 强制线程dump。在jstack &lt;pid&gt; 没有响应时使用（进程挂起/阻塞）</li>
<li>-m 展示java 和 native 线程栈信息（mix模式）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">&#34;JPS event loop&#34; #10 prio=5 os_prio=31 tid=0x00007f9a8b1ba000 nid=0xa903 runnable [0x0000700010178000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.KQueueArrayWrapper.kevent0(Native Method)
	at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:198)
	at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:117)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
	- locked &lt;0x000000079442d0f0&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)
	- locked &lt;0x000000079442d108&gt; (a java.util.Collections$UnmodifiableSet)
	- locked &lt;0x000000079442d0a0&gt; (a sun.nio.ch.KQueueSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
	at io.netty.channel.nio.SelectedSelectionKeySetSelector.select(SelectedSelectionKeySetSelector.java:62)
	at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:824)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:457)
	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- None
</code></pre></div><p>dump 信息说明：</p>
<ul>
<li>&ldquo;JPS event loop&rdquo; 是我们为线程起的名称</li>
<li>daemon 是否是守护线程 存在这个关键字则是守护线程，不存在这个关键字则不是守护线程</li>
<li>prio 是我们为线程设置的优先级</li>
<li>os_prio 操作系统线程的优先级，如果系统不支持系统线程优先级，则os_prio=0</li>
<li>tid Java线程id</li>
<li>nid 线程对应操作系统本地线程id,每一个java线程都有一个对应的操作系统线程</li>
<li>runnable 当前线程处于运行状态，如果是等待状态，会显示 wait on condition</li>
<li>java.lang.Thread.State 线程状态，会详细说明原因
<ul>
<li>
<p>NEW 线程刚刚被创建，也就是已经new过了，但是还没有调用start()方法，jstack命令不会列出处于此状态的线程信息</p>
</li>
<li>
<p>RUNNABLE #java.lang.Thread.State:RUNNABLE 表示这个线程是<strong>可运行的</strong>。一个单核CPU在同一时刻，只能运行一个线程。</p>
</li>
<li>
<p>BLOCKED #java.lang.Thread.State:BLOCKED (on object monitor) 线程处于阻塞状态，正在等待一个monitor lock。通常情况下，是因为本线程与其他线程公用了一个锁。其他在线程正在使用这个锁进入某个synchronized同步方法块或者方法，而本线程进入这个同步代码块也需要这个锁，最终导致本线程处于阻塞状态。</p>
</li>
<li>
<p>WAITING 等待状态，调用以下方法可能会导致一个线程处于等待状态</p>
<ul>
<li>Object.wait 不指定超时时间 # java.lang.Thread.State: WAITING (on object monitor) 对于wait()方法，一个线程处于等待状态，通常是在等待其他线程完成某个操作。本线程调用某个对象的wait()方法，其他线程处于完成之后，调用同一个对象的notify或者notifyAll()方法。Object.wait()方法只能够在同步代码块中调用。调用了wait()方法后，会释放锁。</li>
<li>Thread.join  with no timeout</li>
<li>LockSupport.park #java.lang.Thread.State: WAITING (parking)</li>
</ul>
</li>
<li>
<p>TIMED_WAITING 线程等待指定的事件，对于以下方法的调用，可能会导致线程会处于这个状态</p>
<ul>
<li>Thread.sleep #java.lang.Thread.State: TIMED_WAITING(sleeping)</li>
<li>Object.wait 指定超时时间 #java.lang.Thread.State: TIMED_WAITING (on object monitor)</li>
<li>Thread.join  with timeout</li>
<li>LockSupport.parkNanos #java.lang.Thread.State: TIMED_WAITING (parking)</li>
<li>LockSupport.parkUntil #java.lang.Thread.State: TIMED_WAITING (parking)</li>
</ul>
</li>
<li>
<p>TERMINATED 线程终止</p>
</li>
</ul>
</li>
</ul>
<p>查看进程下有哪些线程(和nid 对应)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cat /proc/&lt;pid&gt;/task
</code></pre></div><p>通过 $$ top -Hp $$ 命令查看进程内所有线程的cpu和内容使用情况</p>
<p>名词解释</p>
<ul>
<li>Monitor</li>
</ul>
<p>在多线程的Java程序中，实现线程之间的同步，就会使用到Monitor。Monitor是Java中用以实现线程之间的互斥与协作的手段，它可以是对象或者类的锁。每个对象都有，有且仅有一个。
每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是Active Thread而其它线程都是Waiting Thread，分别在两个队列 Entry Set和Wait Set里面等候。在Entry Set中等待的线程状态是 Waiting for monitorentry, 而在 Wait Set中等待的线程状态是in Object.wait()</p>
<ul>
<li>Entry Set</li>
</ul>
<p>Entry Set 表示线程通过synchronized要求获取对象的锁。如果对象未被锁住，则进入（The Owner）拥有者，否则在进入区等待；一旦对象所被其他现场释放，则立即参与竞争
Entry Set里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set”队列。对应代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span>obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">.......</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>The Owner</li>
</ul>
<p>The Owner 表示某一线程成功竞争到对象锁</p>
<ul>
<li>Wait Set</li>
</ul>
<p>Wait Set 表示线程通过对象的wait方法，释放对象的锁并在等待区被唤醒</p>
<p>调用修饰
线程在方法调用时，额外的重要操作, 是线程Dump分析的重要信息。修饰上方的方法调用</p>
<p>locked&lt;地址&gt; 目标: 使用synchronized申请对象锁成功，监视器(monitor)的the owner（拥有者）
waiting to lock&lt;地址&gt; 目标: 使用synchronized申请对象锁未成功，在entry set等待
waiting on &lt;地址&gt; 目标: 使用synchronized申请对象锁成功后，释放锁在wait set等待</p>
<p>parking to wait for &lt;地址&gt; 目标: 需要与堆栈中的parking to wait for (atjava.util.concurrent.SynchronousQueue$TransferStack)结合来看。</p>
<ol>
<li>此线程是在等待某个条件的发生，将自己唤醒</li>
<li>SynchronousQueue不是一个队列，其实是线程之间移交信息额机制。当我们吧一个元素放入到 SynchronousQueue中时，必需有另一个线程正在等待接收移交的任务。这就是本线程在等待的条件</li>
</ol>
<h2 id="jstat性能分析">jstat（性能分析）</h2>
<p>主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">jstat -&lt;option&gt; <span style="color:#f92672">[</span>-t<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-h&lt;lines&gt;<span style="color:#f92672">]</span> &lt;vmid&gt; <span style="color:#f92672">[</span>&lt;interval&gt; <span style="color:#f92672">[</span>&lt;count&gt;<span style="color:#f92672">]]</span>
jstat -help | -options
</code></pre></div><p>参数:</p>
<ul>
<li>-option 参数选项</li>
<li>-t 在打印的列加上timestamp列，用于显示系统运行的时间</li>
<li>-h n 设置隔n行显示一个header</li>
<li>vmid 进程pid</li>
<li>interval 执行每次的间隔时间， 单位毫秒</li>
<li>count 指定输出多少次记录</li>
</ul>
<p>option参数都有:</p>
<ol>
<li>-class 显示ClassLoader的相关信息</li>
<li>-compiler 显示JIT编译的相关信息</li>
<li>-gc 显示和gc相关的堆信息</li>
<li>-gccapacity 显示各个代的容量以及使用情况</li>
<li>-gcmetacapacity 显示metaspace(元空间)的大小</li>
<li>-gcnew 显示新生代的信息</li>
<li>-gcnewcapacity 显示新生代大小和使用情况</li>
<li>-gcold 显示老年代的大小</li>
<li>-gcoldcapacity 显示老年代的大小</li>
<li>-gcutil 显示垃圾收集信息</li>
<li>-gccause 显示垃圾收集信息，同时显示最后一次或当前正在发生的垃圾回收的诱因</li>
<li>-printcompilation 输出JIT编译的方法信息</li>
</ol>
<p>class: 显示加载class的数量，及所占空间等信息</p>
<table>
<thead>
<tr>
<th style="text-align:center">Loaded</th>
<th style="text-align:center">Bytes</th>
<th style="text-align:center">Unloaded</th>
<th style="text-align:center">Bytes</th>
<th style="text-align:center">Time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">已经装载的类的数量</td>
<td style="text-align:center">装载类所占用的字节数</td>
<td style="text-align:center">已卸载类的数量</td>
<td style="text-align:center">卸载类的字节数</td>
<td style="text-align:center">装载和卸载类所花费的时间</td>
</tr>
</tbody>
</table>
<p>compiler: 显示VM实时编译(JIT)的数量等信息</p>
<table>
<thead>
<tr>
<th style="text-align:center">Compiled</th>
<th style="text-align:center">Failed</th>
<th style="text-align:center">Invalid</th>
<th style="text-align:center">Time</th>
<th style="text-align:center">FailedType</th>
<th style="text-align:center">FailedMethod</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编译任务执行的数量</td>
<td style="text-align:center">编译任务执行失败的数量</td>
<td style="text-align:center">编译任务执行无效的数量</td>
<td style="text-align:center">编译任务消耗的时间</td>
<td style="text-align:center">最后一个编译失败任务的类型</td>
<td style="text-align:center">最后一个编译失败所在类及方法</td>
</tr>
</tbody>
</table>
<p>gc: 显示gc相关的堆信息，被查看gc的次数、及时间</p>
<p>参数略长，转置一下</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S0C</td>
<td style="text-align:center">年轻代中第一个survivor的容量(字节)</td>
<td style="text-align:center">from</td>
</tr>
<tr>
<td style="text-align:center">S1C</td>
<td style="text-align:center">年轻代中第二个survivor的容量(字节)</td>
<td style="text-align:center">to</td>
</tr>
<tr>
<td style="text-align:center">S0U</td>
<td style="text-align:center">年轻代中第一个survivor目前已使用的空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">S1U</td>
<td style="text-align:center">年轻代中第二个survivor目前已使用的空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">EC</td>
<td style="text-align:center">年轻代中的Eden的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">EU</td>
<td style="text-align:center">年轻代中的Eden目前已使用的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OC</td>
<td style="text-align:center">老年代的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OU</td>
<td style="text-align:center">老年代已使用空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">MC</td>
<td style="text-align:center">metaspace的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">MU</td>
<td style="text-align:center">metaspace目前已使用空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGCT</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGCT</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GCT</td>
<td style="text-align:center">从应用程序启动到采样时gc所用时间</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gccapacity: 显示 VM内存中堆栈的使用大小和占比大小</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NGCMN</td>
<td style="text-align:center">年轻代中初始化(最小)的大小</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">NGCMX</td>
<td style="text-align:center">年轻代的最大容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">NGC</td>
<td style="text-align:center">年轻代的当前容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">S0C</td>
<td style="text-align:center">年轻代中第一个survivor的容量(字节)</td>
<td style="text-align:center">from</td>
</tr>
<tr>
<td style="text-align:center">S1C</td>
<td style="text-align:center">年轻代中第二个survivor的容量(字节)</td>
<td style="text-align:center">to</td>
</tr>
<tr>
<td style="text-align:center">EC</td>
<td style="text-align:center">年轻代中的Eden的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OGCMN</td>
<td style="text-align:center">老年代中初始化(最小)的大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OGCMX</td>
<td style="text-align:center">老年代最大容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OGC</td>
<td style="text-align:center">老年代当前新生成的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OC</td>
<td style="text-align:center">老年代的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OU</td>
<td style="text-align:center">老年代已使用空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">MC</td>
<td style="text-align:center">metaspace的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSMN</td>
<td style="text-align:center">最小压缩类空间大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSMX</td>
<td style="text-align:center">最大压缩类空间大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSC</td>
<td style="text-align:center">当前压缩类空间大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gcmetacapacity: metaspace中对象的信息及占用量</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MCMN</td>
<td style="text-align:center">最小元数据容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">MCMX</td>
<td style="text-align:center">最大元数据容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">MC</td>
<td style="text-align:center">metaspace的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSMN</td>
<td style="text-align:center">最小压缩类空间大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSMX</td>
<td style="text-align:center">最大压缩类空间大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSC</td>
<td style="text-align:center">当前压缩类空间大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGCT</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GCT</td>
<td style="text-align:center">从应用程序启动到采样时gc所用时间</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gcnew: 年轻代对象的信息</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S0C</td>
<td style="text-align:center">年轻代中第一个survivor的容量(字节)</td>
<td style="text-align:center">from</td>
</tr>
<tr>
<td style="text-align:center">S1C</td>
<td style="text-align:center">年轻代中第二个survivor的容量(字节)</td>
<td style="text-align:center">to</td>
</tr>
<tr>
<td style="text-align:center">S0U</td>
<td style="text-align:center">年轻代中第一个survivor目前已使用的空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">S1U</td>
<td style="text-align:center">年轻代中第二个survivor目前已使用的空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">TT</td>
<td style="text-align:center">持有次数限制</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">MTT</td>
<td style="text-align:center">最大持有次数限制</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">DSS</td>
<td style="text-align:center">期望的survivor大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">EC</td>
<td style="text-align:center">年轻代中的Eden的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">EU</td>
<td style="text-align:center">年轻代中的Eden目前已使用的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGCT</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用时间</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gcnewcapacity: 年轻代对象的信息及占用量</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NGCMN</td>
<td style="text-align:center">年轻代中初始化(最小)的大小</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">NGCMX</td>
<td style="text-align:center">年轻代的最大容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">NGC</td>
<td style="text-align:center">年轻代的当前容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">S0C</td>
<td style="text-align:center">年轻代中第一个survivor的容量(字节)</td>
<td style="text-align:center">from</td>
</tr>
<tr>
<td style="text-align:center">S0CMX</td>
<td style="text-align:center">年轻代中第一个survivor的最大容量(字节)</td>
<td style="text-align:center">from</td>
</tr>
<tr>
<td style="text-align:center">S1C</td>
<td style="text-align:center">年轻代中第二个survivor的容量(字节)</td>
<td style="text-align:center">to</td>
</tr>
<tr>
<td style="text-align:center">S1CMX</td>
<td style="text-align:center">年轻代中第二个survivor的最大容量(字节)</td>
<td style="text-align:center">to</td>
</tr>
<tr>
<td style="text-align:center">EC</td>
<td style="text-align:center">年轻代中的Eden的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ECMX</td>
<td style="text-align:center">年轻代中的Eden的最大容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gcold: 老年代对象信息</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MC</td>
<td style="text-align:center">metaspace的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">MU</td>
<td style="text-align:center">metaspace目前已使用空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSC</td>
<td style="text-align:center">压缩类空间大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCSU</td>
<td style="text-align:center">压缩类空间使用大小</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OC</td>
<td style="text-align:center">老年代的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OU</td>
<td style="text-align:center">老年代已使用空间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGCT</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GCT</td>
<td style="text-align:center">从应用程序启动到采样时gc所用时间</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gcoldcapacity: 老年代</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OGCMN</td>
<td style="text-align:center">老年代中初始化(最小)的大小</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">OGCMX</td>
<td style="text-align:center">老年代的最大容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">OGC</td>
<td style="text-align:center">老年代代的当前新生成的容量</td>
<td style="text-align:center">单位字节</td>
</tr>
<tr>
<td style="text-align:center">OC</td>
<td style="text-align:center">老年代的容量</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGCT</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GCT</td>
<td style="text-align:center">从应用程序启动到采样时gc所用时间</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gcutil: 统计gc信息</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S0</td>
<td style="text-align:center">年轻代中第一个survivor已使用的占当前容量的百分比</td>
<td style="text-align:center">from</td>
</tr>
<tr>
<td style="text-align:center">S1C</td>
<td style="text-align:center">年轻代中第二个survivor已使用的占当前容量的百分比</td>
<td style="text-align:center">to</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">年轻代中的Eden已使用的占当前容量百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">老年代已使用的占当前容量的百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">metaspace已使用的占当前容量的百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCS</td>
<td style="text-align:center">压缩类空间已使用的占当前容量百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGCT</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGCT</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GCT</td>
<td style="text-align:center">从应用程序启动到采样时gc所用时间</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>gccause: 统计gc信息，并显示最后一次或当前正在发生的gc诱因</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S0</td>
<td style="text-align:center">年轻代中第一个survivor已使用的占当前容量的百分比</td>
<td style="text-align:center">from</td>
</tr>
<tr>
<td style="text-align:center">S1C</td>
<td style="text-align:center">年轻代中第二个survivor已使用的占当前容量的百分比</td>
<td style="text-align:center">to</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">年轻代中的Eden已使用的占当前容量百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">老年代已使用的占当前容量的百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">metaspace已使用的占当前容量的百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CCS</td>
<td style="text-align:center">压缩类空间已使用的占当前容量百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGC</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">YGCT</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGC</td>
<td style="text-align:center">从应用程序启动到采样时老年代中(full gc)gc所用事件(单位: 秒)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FGCT</td>
<td style="text-align:center">从应用程序启动到采样时年轻代中gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GCT</td>
<td style="text-align:center">从应用程序启动到采样时gc所用时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LGCC</td>
<td style="text-align:center">最后一次GC的原因</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">GCC</td>
<td style="text-align:center">当前GC 原因或没有执行GC(No GC)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>printcompilation: 当前VM 执行的信息</p>
<table>
<thead>
<tr>
<th style="text-align:center">Compiled</th>
<th style="text-align:center">Size</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编译任务的数据</td>
<td style="text-align:center">方法生成字节码的大小</td>
<td style="text-align:center">编译类型</td>
<td style="text-align:center">类名和方法名，用来标识编译的方法，类名使用或作为一个命名空间分隔符。方法名是给定类中的方法，由 -XX:+PrintComplation选项设置的</td>
</tr>
</tbody>
</table>
<h1 id="总结">总结</h1>
<p>有了这几个工具，就可以排查线上的某些问题了</p>
]]></content>
        </item>
        
        <item>
            <title>spark shuffle 和数据倾斜</title>
            <link>http://keltoy.github.io/posts/spark-shuffle-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/</link>
            <pubDate>Tue, 12 May 2020 20:39:43 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/spark-shuffle-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/</guid>
            <description>[toc]
前言 这是复制过来的第二篇文章，专门讲如何处理数据倾斜问题的 原链接
数据倾斜 现象  绝大多数task 执行非常快，但个别task执行极慢。比如，总共有1000个task，997个task都在1分钟之内执行完了，但是剩余两三个task却要一两个小时。这种情况很常见。 原本能够正常执行的Spark作业，某天突然报出OOM（内存溢出）异常，观察异常栈，是我们写的业务代码造成的。这种情况比较少见。  发生原理 数据倾斜的原理很简单：在进行shuffle的时候，必须将各个节点上相同的key拉取到某个节点上的一个task来进行处理，比如按照key进行聚合或join等操作。此时如果某个key对应的数据量特别大的话，就会发生数据倾斜。
比如大部分key对应10条数据，但是个别key却对应了100万条数据，那么大部分task可能就只会分配到10条数据，然后1秒钟就运行完了；但是个别task可能分配到了100万数据，要运行一两个小时。因此，整个Spark作业的运行进度是由运行时间最长的那个task决定的。
因此出现数据倾斜的时候，Spark作业看起来会运行得非常缓慢，甚至可能因为某个task处理的数据量过大导致内存溢出。
下图就是一个很清晰的例子：hello这个key，在三个节点上对应了总共7条数据，这些数据都会被拉取到同一个task中进行处理；而world和you这两个key分别才对应1条数据，所以另外两个task只要分别处理1条数据即可。此时第一个task的运行时间可能是另外两个task的7倍，而整个stage的运行速度也由运行最慢的那个task所决定。
定位代码 数据倾斜只会发生在shuffle过程中。一些常用的并且可能会触发shuffle操作的算子：
 distinct groupByKey reduceByKey aggregateByKey join cogroup repartition等。  出现数据倾斜时，可能就是你的代码中使用了这些算子中的某一个所导致的。
某个task执行特别慢的情况 首先要看的，就是数据倾斜发生在第几个stage中。
可以通过Spark Web UI来查看当前运行到了第几个stage。此外，无论是使用yarn-client模式还是yarn-cluster模式，我们都可以在Spark Web UI上深入看一下当前这个stage各个task分配的数据量，从而进一步确定是不是task分配的数据不均匀导致了数据倾斜。
知道数据倾斜发生在哪一个stage之后，接着我们就需要根据stage划分原理，推算出来发生倾斜的那个stage对应代码中的哪一部分，这部分代码中肯定会有一个shuffle类算子。精准推算stage与代码的对应关系，需要对Spark的源码有深入的理解，这里我们可以介绍一个相对简单实用的推算方法：只要看到Spark代码中出现了一个shuffle类算子或者是Spark SQL的SQL语句中出现了会导致shuffle的语句（比如group by语句），那么就可以判定，以那个地方为界限划分出了前后两个stage。
这里我们就以Spark最基础的入门程序——单词计数来举例，如何用最简单的方法大致推算出一个stage对应的代码。如下示例，在整个代码中，只有一个reduceByKey是会发生shuffle的算子，因此就可以认为，以这个算子为界限，会划分出前后两个stage。
 stage0，主要是执行从textFile到map操作，以及执行shuffle write操作。shuffle write操作，我们可以简单理解为对pairs RDD中的数据进行分区操作，每个task处理的数据中，相同的key会写入同一个磁盘文件内。 stage1，主要是执行从reduceByKey到collect操作，stage1的各个task一开始运行，就会首先执行shuffle read操作。执行shuffle read操作的task，会从stage0的各个task所在节点拉取属于自己处理的那些key，然后对同一个key进行全局性的聚合或join等操作，在这里就是对key的value值进行累加。stage1在执行完reduceByKey算子之后，就计算出了最终的wordCounts RDD，然后会执行collect算子，将所有数据拉取到Driver上，供我们遍历和打印输出。  val conf = new SparkConf() val sc = new SparkContext(conf) val lines = sc.textFile(&amp;#34;hdfs://...&amp;#34;) val words = lines.flatMap(_.split(&amp;#34; &amp;#34;)) val pairs = words.</description>
            <content type="html"><![CDATA[<p>[toc]</p>
<h1 id="前言">前言</h1>
<p>这是复制过来的第二篇文章，专门讲如何处理数据倾斜问题的 <a href="https://tech.meituan.com/2016/05/12/spark-tuning-pro.html">原链接</a></p>
<h1 id="数据倾斜">数据倾斜</h1>
<h2 id="现象">现象</h2>
<ul>
<li>绝大多数task 执行非常快，但个别task执行极慢。比如，总共有1000个task，997个task都在1分钟之内执行完了，但是剩余两三个task却要一两个小时。这种情况很常见。</li>
<li>原本能够正常执行的Spark作业，某天突然报出OOM（内存溢出）异常，观察异常栈，是我们写的业务代码造成的。这种情况比较少见。</li>
</ul>
<h2 id="发生原理">发生原理</h2>
<p>数据倾斜的原理很简单：在进行shuffle的时候，必须将各个节点上相同的key拉取到某个节点上的一个task来进行处理，比如按照key进行聚合或join等操作。此时如果某个key对应的数据量特别大的话，就会发生数据倾斜。</p>
<p>比如大部分key对应10条数据，但是个别key却对应了100万条数据，那么大部分task可能就只会分配到10条数据，然后1秒钟就运行完了；但是个别task可能分配到了100万数据，要运行一两个小时。因此，整个Spark作业的运行进度是由运行时间最长的那个task决定的。</p>
<p>因此出现数据倾斜的时候，Spark作业看起来会运行得非常缓慢，甚至可能因为某个task处理的数据量过大导致内存溢出。</p>
<p>下图就是一个很清晰的例子：hello这个key，在三个节点上对应了总共7条数据，这些数据都会被拉取到同一个task中进行处理；而world和you这两个key分别才对应1条数据，所以另外两个task只要分别处理1条数据即可。此时第一个task的运行时间可能是另外两个task的7倍，而整个stage的运行速度也由运行最慢的那个task所决定。</p>
<p><img src="/b6cbcfd9.png" alt="img"></p>
<h2 id="定位代码">定位代码</h2>
<p>数据倾斜只会发生在shuffle过程中。一些常用的并且可能会触发shuffle操作的算子：</p>
<ul>
<li>distinct</li>
<li>groupByKey</li>
<li>reduceByKey</li>
<li>aggregateByKey</li>
<li>join</li>
<li>cogroup</li>
<li>repartition等。</li>
</ul>
<p>出现数据倾斜时，可能就是你的代码中使用了这些算子中的某一个所导致的。</p>
<h3 id="某个task执行特别慢的情况">某个task执行特别慢的情况</h3>
<p>首先要看的，就是数据倾斜发生在第几个stage中。</p>
<p>可以通过Spark Web UI来查看当前运行到了第几个stage。此外，无论是使用yarn-client模式还是yarn-cluster模式，我们都可以在Spark Web UI上深入看一下当前这个stage各个task分配的数据量，从而进一步确定是不是task分配的数据不均匀导致了数据倾斜。</p>
<p>知道数据倾斜发生在哪一个stage之后，接着我们就需要根据stage划分原理，推算出来发生倾斜的那个stage对应代码中的哪一部分，这部分代码中肯定会有一个shuffle类算子。精准推算stage与代码的对应关系，需要对Spark的源码有深入的理解，这里我们可以介绍一个相对简单实用的推算方法：只要看到Spark代码中出现了一个shuffle类算子或者是Spark SQL的SQL语句中出现了会导致shuffle的语句（比如group by语句），那么就可以判定，以那个地方为界限划分出了前后两个stage。</p>
<p>这里我们就以Spark最基础的入门程序——单词计数来举例，如何用最简单的方法大致推算出一个stage对应的代码。如下示例，在整个代码中，只有一个reduceByKey是会发生shuffle的算子，因此就可以认为，以这个算子为界限，会划分出前后两个stage。</p>
<ul>
<li>stage0，主要是执行从textFile到map操作，以及执行shuffle write操作。shuffle write操作，我们可以简单理解为对pairs RDD中的数据进行分区操作，每个task处理的数据中，相同的key会写入同一个磁盘文件内。</li>
<li>stage1，主要是执行从reduceByKey到collect操作，stage1的各个task一开始运行，就会首先执行shuffle read操作。执行shuffle read操作的task，会从stage0的各个task所在节点拉取属于自己处理的那些key，然后对同一个key进行全局性的聚合或join等操作，在这里就是对key的value值进行累加。stage1在执行完reduceByKey算子之后，就计算出了最终的wordCounts RDD，然后会执行collect算子，将所有数据拉取到Driver上，供我们遍历和打印输出。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#66d9ef">val</span> conf <span style="color:#66d9ef">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SparkConf</span><span style="color:#f92672">()</span>
<span style="color:#66d9ef">val</span> sc <span style="color:#66d9ef">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SparkContext</span><span style="color:#f92672">(</span>conf<span style="color:#f92672">)</span>
 
<span style="color:#66d9ef">val</span> lines <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>textFile<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hdfs://...&#34;</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">val</span> words <span style="color:#66d9ef">=</span> lines<span style="color:#f92672">.</span>flatMap<span style="color:#f92672">(</span><span style="color:#66d9ef">_</span><span style="color:#f92672">.</span>split<span style="color:#f92672">(</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">))</span>
<span style="color:#66d9ef">val</span> pairs <span style="color:#66d9ef">=</span> words<span style="color:#f92672">.</span>map<span style="color:#f92672">((</span><span style="color:#66d9ef">_</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">))</span>
<span style="color:#66d9ef">val</span> wordCounts <span style="color:#66d9ef">=</span> pairs<span style="color:#f92672">.</span>reduceByKey<span style="color:#f92672">(</span><span style="color:#66d9ef">_</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">_</span><span style="color:#f92672">)</span>
 
wordCounts<span style="color:#f92672">.</span>collect<span style="color:#f92672">().</span>foreach<span style="color:#f92672">(</span>println<span style="color:#f92672">(</span><span style="color:#66d9ef">_</span><span style="color:#f92672">))</span>

</code></pre></div><p>通过对单词计数程序的分析，希望能够让大家了解最基本的stage划分的原理，以及stage划分后shuffle操作是如何在两个stage的边界处执行的。然后我们就知道如何快速定位出发生数据倾斜的stage对应代码的哪一个部分了。比如我们在Spark Web UI或者本地log中发现，stage1的某几个task执行得特别慢，判定stage1出现了数据倾斜，那么就可以回到代码中定位出stage1主要包括了reduceByKey这个shuffle类算子，此时基本就可以确定是由reduceByKey算子导致的数据倾斜问题。比如某个单词出现了100万次，其他单词才出现10次，那么stage1的某个task就要处理100万数据，整个stage的速度就会被这个task拖慢。</p>
<h3 id="某个task莫名其妙内存溢出的情况">某个task莫名其妙内存溢出的情况</h3>
<p>这种情况下去定位出问题的代码就比较容易了。我们建议直接看yarn-client模式下本地log的异常栈，或者是通过YARN查看yarn-cluster模式下的log中的异常栈。一般来说，通过异常栈信息就可以定位到你的代码中哪一行发生了内存溢出。然后在那行代码附近找找，一般也会有shuffle类算子，此时很可能就是这个算子导致了数据倾斜。</p>
<p>但是大家要注意的是，不能单纯靠偶然的内存溢出就判定发生了数据倾斜。因为自己编写的代码的bug，以及偶然出现的数据异常，也可能会导致内存溢出。因此还是要按照上面所讲的方法，通过Spark Web UI查看报错的那个stage的各个task的运行时间以及分配的数据量，才能确定是否是由于数据倾斜才导致了这次内存溢出。</p>
<h3 id="查看导致数据倾斜的key的数据分布情况">查看导致数据倾斜的key的数据分布情况</h3>
<p>知道了数据倾斜发生在哪里之后，通常需要分析一下那个执行了shuffle操作并且导致了数据倾斜的RDD/Hive表，查看一下其中key的分布情况。这主要是为之后选择哪一种技术方案提供依据。针对不同的key分布与不同的shuffle算子组合起来的各种情况，可能需要选择不同的技术方案来解决。</p>
<p>此时根据你执行操作的情况不同，可以有很多种查看key分布的方式： 1. 如果是Spark SQL中的group by、join语句导致的数据倾斜，那么就查询一下SQL中使用的表的key分布情况。 2. 如果是对Spark RDD执行shuffle算子导致的数据倾斜，那么可以在Spark作业中加入查看key分布的代码，比如RDD.countByKey()。然后对统计出来的各个key出现的次数，collect/take到客户端打印一下，就可以看到key的分布情况。</p>
<p>举例来说，对于上面所说的单词计数程序，如果确定了是stage1的reduceByKey算子导致了数据倾斜，那么就应该看看进行reduceByKey操作的RDD中的key分布情况，在这个例子中指的就是pairs RDD。如下示例，我们可以先对pairs采样10%的样本数据，然后使用countByKey算子统计出每个key出现的次数，最后在客户端遍历和打印样本数据中各个key的出现次数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#66d9ef">val</span> sampledPairs <span style="color:#66d9ef">=</span> pairs<span style="color:#f92672">.</span>sample<span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">0.1</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">val</span> sampledWordCounts <span style="color:#66d9ef">=</span> sampledPairs<span style="color:#f92672">.</span>countByKey<span style="color:#f92672">()</span>
sampledWordCounts<span style="color:#f92672">.</span>foreach<span style="color:#f92672">(</span>println<span style="color:#f92672">(</span><span style="color:#66d9ef">_</span><span style="color:#f92672">))</span>
</code></pre></div><h1 id="解决倾斜的解决方案">解决倾斜的解决方案</h1>
<h2 id="使用hive-etl-预处理数据">使用Hive ETL 预处理数据</h2>
<p><strong>方案适用场景</strong>：导致数据倾斜的是Hive表。如果该Hive表中的数据本身很不均匀（比如某个key对应了100万数据，其他key才对应了10条数据），而且业务场景需要频繁使用Spark对Hive表执行某个分析操作，那么比较适合使用这种技术方案。</p>
<p><strong>方案实现思路</strong>：此时可以评估一下，是否可以通过Hive来进行数据预处理（即通过Hive ETL预先对数据按照key进行聚合，或者是预先和其他表进行join），然后在Spark作业中针对的数据源就不是原来的Hive表了，而是预处理后的Hive表。此时由于数据已经预先进行过聚合或join操作了，那么在Spark作业中也就不需要使用原先的shuffle类算子执行这类操作了。</p>
<p><strong>方案实现原理</strong>：这种方案从根源上解决了数据倾斜，因为彻底避免了在Spark中执行shuffle类算子，那么肯定就不会有数据倾斜的问题了。但是这里也要提醒一下大家，这种方式属于治标不治本。因为毕竟数据本身就存在分布不均匀的问题，所以Hive ETL中进行group by或者join等shuffle操作时，还是会出现数据倾斜，导致Hive ETL的速度很慢。我们只是把数据倾斜的发生提前到了Hive ETL中，避免Spark程序发生数据倾斜而已。</p>
<p><strong>方案优点</strong>：实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升。</p>
<p><strong>方案缺点</strong>：治标不治本，Hive ETL中还是会发生数据倾斜。</p>
<p><strong>方案实践经验</strong>：在一些Java系统与Spark结合使用的项目中，会出现Java代码频繁调用Spark作业的场景，而且对Spark作业的执行性能要求很高，就比较适合使用这种方案。将数据倾斜提前到上游的Hive ETL，每天仅执行一次，只有那一次是比较慢的，而之后每次Java调用Spark作业时，执行速度都会很快，能够提供更好的用户体验。</p>
<h2 id="过滤少数导致倾斜的key">过滤少数导致倾斜的key</h2>
<p><strong>方案适用场景</strong>：如果发现导致倾斜的key就少数几个，而且对计算本身的影响并不大的话，那么很适合使用这种方案。比如99%的key就对应10条数据，但是只有一个key对应了100万数据，从而导致了数据倾斜。</p>
<p><strong>方案实现思路</strong>：如果我们判断那少数几个数据量特别多的key，对作业的执行和计算结果不是特别重要的话，那么干脆就直接过滤掉那少数几个key。比如，在Spark SQL中可以使用where子句过滤掉这些key或者在Spark Core中对RDD执行filter算子过滤掉这些key。如果需要每次作业执行时，动态判定哪些key的数据量最多然后再进行过滤，那么可以使用sample算子对RDD进行采样，然后计算出每个key的数量，取数据量最多的key过滤掉即可。</p>
<p><strong>方案实现原理</strong>：将导致数据倾斜的key给过滤掉之后，这些key就不会参与计算了，自然不可能产生数据倾斜。</p>
<p><strong>方案优点</strong>：实现简单，而且效果也很好，可以完全规避掉数据倾斜。</p>
<p><strong>方案缺点</strong>：适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</p>
<p><strong>方案实践经验</strong>：在项目中我们也采用过这种方案解决数据倾斜。有一次发现某一天Spark作业在运行的时候突然OOM了，追查之后发现，是Hive表中的某一个key在那天数据异常，导致数据量暴增。因此就采取每次执行前先进行采样，计算出样本中数据量最大的几个key之后，直接在程序中将那些key给过滤掉。</p>
<h2 id="提高shuffle操作的并行度">提高shuffle操作的并行度</h2>
<p><strong>方案适用场景</strong>：如果我们必须要对数据倾斜迎难而上，那么建议优先使用这种方案，因为这是处理数据倾斜最简单的一种方案。</p>
<p><strong>方案实现思路</strong>：在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(1000)，该参数就设置了这个shuffle算子执行时shuffle read task的数量。对于Spark SQL中的shuffle类语句，比如group by、join等，需要设置一个参数，即spark.sql.shuffle.partitions，该参数代表了shuffle read task的并行度，该值默认是200，对于很多场景来说都有点过小。</p>
<p><strong>方案实现原理</strong>：增加shuffle read task的数量，可以让原本分配给一个task的多个key分配给多个task，从而让每个task处理比原来更少的数据。举例来说，如果原本有5个key，每个key对应10条数据，这5个key都是分配给一个task的，那么这个task就要处理50条数据。而增加了shuffle read task以后，每个task就分配到一个key，即每个task就处理10条数据，那么自然每个task的执行时间都会变短了。具体原理如下图所示。</p>
<p><strong>方案优点</strong>：实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。</p>
<p><strong>方案缺点</strong>：只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限。</p>
<p><strong>方案实践经验</strong>：该方案通常无法彻底解决数据倾斜，因为如果出现一些极端情况，比如某个key对应的数据量有100万，那么无论你的task数量增加到多少，这个对应着100万数据的key肯定还是会分配到一个task中去处理，因此注定还是会发生数据倾斜的。所以这种方案只能说是在发现数据倾斜时尝试使用的第一种手段，尝试去用嘴简单的方法缓解数据倾斜而已，或者是和其他方案结合起来使用。</p>
<p><img src="/ce6545e2.png" alt="img"></p>
<h2 id="两阶段聚合局部聚合--全局聚合">两阶段聚合（局部聚合 + 全局聚合）</h2>
<p><strong>方案适用场景</strong>：对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用group by语句进行分组聚合时，比较适用这种方案。</p>
<p><strong>方案实现思路</strong>：这个方案的核心实现思路就是进行两阶段聚合。第一次是局部聚合，先给每个key都打上一个随机数，比如10以内的随机数，此时原先一样的key就变成不一样的了，比如(hello, 1) (hello, 1) (hello, 1) (hello, 1)，就会变成(1_hello, 1) (1_hello, 1) (2_hello, 1) (2_hello, 1)。接着对打上随机数后的数据，执行reduceByKey等聚合操作，进行局部聚合，那么局部聚合结果，就会变成了(1_hello, 2) (2_hello, 2)。然后将各个key的前缀给去掉，就会变成(hello,2)(hello,2)，再次进行全局聚合操作，就可以得到最终结果了，比如(hello, 4)。</p>
<p><strong>方案实现原理</strong>：将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。具体原理见下图。</p>
<p><strong>方案优点</strong>：对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</p>
<p><strong>方案缺点</strong>：仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。</p>
<p><img src="/ed298b30.png" alt="img"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 第一步，给RDD中的每个key都打上一个随机前缀。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> randomPrefixRdd<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Long</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">val</span> random<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Random</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Random</span><span style="color:#f92672">()</span>
  <span style="color:#66d9ef">var</span> prefix<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>nextInt<span style="color:#f92672">(</span><span style="color:#ae81ff">10</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>prefix<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;_&#34;</span><span style="color:#f92672">+</span>tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">,</span> tuple_2<span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>
  
<span style="color:#75715e">// 第二步，对打上随机前缀的key进行局部聚合。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> localAggrRdd<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Long</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> randomPrefixRdd<span style="color:#f92672">.</span>reduceByKey<span style="color:#f92672">((</span>v1<span style="color:#f92672">,</span> v2<span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  v1 <span style="color:#f92672">+</span> v2
<span style="color:#f92672">})</span>
  
<span style="color:#75715e">// 第三步，去除RDD中每个key的随机前缀。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> removedRandomPrefixRdd<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Long</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> localAggrRdd<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">val</span> originalKey<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Long</span> <span style="color:#f92672">=</span> tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">.</span>split<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;_&#34;</span><span style="color:#f92672">)(</span><span style="color:#ae81ff">1</span><span style="color:#f92672">).</span>toLong
  <span style="color:#f92672">(</span>originalKey<span style="color:#f92672">,</span> tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>
  
<span style="color:#75715e">// 第四步，对去除了随机前缀的RDD进行全局聚合。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> globalAggrRdd<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Long</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> removedRandomPrefixRdd<span style="color:#f92672">.</span>reduceByKey<span style="color:#f92672">((</span>v1<span style="color:#f92672">,</span>v2<span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  v1 <span style="color:#f92672">+</span> v2
<span style="color:#f92672">})</span>
</code></pre></div><h2 id="将-reduce-join-转为-map-join">将 reduce join 转为 map join</h2>
<p><strong>方案适用场景</strong>：在对RDD使用join类操作，或者是在Spark SQL中使用join语句时，而且join操作中的一个RDD或表的数据量比较小（比如几百M或者一两G），比较适用此方案。</p>
<p><strong>方案实现思路</strong>：不使用join算子进行连接操作，而使用Broadcast变量与map类算子实现join操作，进而完全规避掉shuffle类的操作，彻底避免数据倾斜的发生和出现。将较小RDD中的数据直接通过collect算子拉取到Driver端的内存中来，然后对其创建一个Broadcast变量；接着对另外一个RDD执行map类算子，在算子函数内，从Broadcast变量中获取较小RDD的全量数据，与当前RDD的每一条数据按照连接key进行比对，如果连接key相同的话，那么就将两个RDD的数据用你需要的方式连接起来。</p>
<p><strong>方案实现原理</strong>：普通的join是会走shuffle过程的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffle read task中再进行join，此时就是reduce join。但是如果一个RDD是比较小的，则可以采用广播小RDD全量数据+map算子来实现与join同样的效果，也就是map join，此时就不会发生shuffle操作，也就不会发生数据倾斜。具体原理如下图所示。</p>
<p><strong>方案优点</strong>：对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。</p>
<p><strong>方案缺点</strong>：适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</p>
<p><img src="/af80b7cb.png" alt="img"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 首先将数据量比较小的RDD的数据，collect到Driver中来。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd1Data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd1<span style="color:#f92672">.</span>collect<span style="color:#f92672">()</span>
<span style="color:#75715e">// 然后使用Spark的广播功能，将小RDD的数据转换成广播变量，这样每个Executor就只有一份RDD的数据。
</span><span style="color:#75715e">// 可以尽可能节省内存空间，并且减少网络传输性能开销。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> <span style="color:#66d9ef">final</span> rdd1DataBroadcast<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Broadcast</span><span style="color:#f92672">[</span><span style="color:#66d9ef">List</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]]</span> <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>broadcast<span style="color:#f92672">(</span>rdd1Data<span style="color:#f92672">)</span>
  
<span style="color:#75715e">// 对另外一个RDD执行map类操作，而不再是join类操作。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> joinedRdd<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#f92672">(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">))]</span> <span style="color:#66d9ef">=</span> rdd2<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">// 在算子函数中，通过广播变量，获取到本地Executor中的rdd1数据。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">val</span> rdd1Data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd1DataBroadcast<span style="color:#f92672">.</span>value                	 <span style="color:#75715e">// 可以将rdd1的数据转换为一个Map，便于后面进行join操作。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">val</span> rdd1DataMap<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Map</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">]()</span>
  <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>data <span style="color:#66d9ef">&lt;-</span> rdd1Data<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    rdd1DataMap<span style="color:#f92672">.</span>put<span style="color:#f92672">(</span>data<span style="color:#f92672">.</span>_1<span style="color:#f92672">,</span> data<span style="color:#f92672">.</span>_2<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
  <span style="color:#75715e">// 获取当前RDD数据的key以及value。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">val</span> key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">=</span> tuple<span style="color:#f92672">.</span>_1
  <span style="color:#66d9ef">val</span> value<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">=</span> tuple<span style="color:#f92672">.</span>_2
  <span style="color:#75715e">// 从rdd1数据Map中，根据key获取到可以join到的数据。
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">val</span> rdd1Value<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Row</span> <span style="color:#f92672">=</span> rdd1DataMap<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>key<span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>value<span style="color:#f92672">,</span> rdd1Value<span style="color:#f92672">)</span>
<span style="color:#f92672">});</span>
  
<span style="color:#75715e">// 这里得提示一下。
</span><span style="color:#75715e">// 上面的做法，仅仅适用于rdd1中的key没有重复，全部是唯一的场景。
</span><span style="color:#75715e">// 如果rdd1中有多个相同的key，那么就得用flatMap类的操作，在进行join的时候不能用map，而是得遍历rdd1所有数据进行join。
</span><span style="color:#75715e">// rdd2中每条数据都可能会返回多条join后的数据。
</span></code></pre></div><h2 id="采样倾斜key并分拆join操作">采样倾斜key并分拆join操作</h2>
<p><strong>方案适用场景</strong>：两个RDD/Hive表进行join的时候，如果数据量都比较大，无法采用“解决方案五”，那么此时可以看一下两个RDD/Hive表中的key分布情况。如果出现数据倾斜，是因为其中某一个RDD/Hive表中的少数几个key的数据量过大，而另一个RDD/Hive表中的所有key都分布比较均匀，那么采用这个解决方案是比较合适的。</p>
<p><strong>方案实现思路</strong>：</p>
<ol>
<li>对包含少数几个数据量过大的key的那个RDD，通过sample算子采样出一份样本来，然后统计一下每个key的数量，计算出来数据量最大的是哪几个key。</li>
<li>然后将这几个key对应的数据从原来的RDD中拆分出来，形成一个单独的RDD，并给每个key都打上n以内的随机数作为前缀，而不会导致倾斜的大部分key形成另外一个RDD。</li>
<li>接着将需要join的另一个RDD，也过滤出来那几个倾斜key对应的数据并形成一个单独的RDD，将每条数据膨胀成n条数据，这n条数据都按顺序附加一个0~n的前缀，不会导致倾斜的大部分key也形成另外一个RDD。</li>
<li>再将附加了随机前缀的独立RDD与另一个膨胀n倍的独立RDD进行join，此时就可以将原先相同的key打散成n份，分散到多个task中去进行join了。</li>
<li>而另外两个普通的RDD就照常join即可。</li>
<li>最后将两次join的结果使用union算子合并起来即可，就是最终的join结果。</li>
</ol>
<p><strong>方案实现原理</strong>：对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key分拆成独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对应的数据就不会集中在少数几个task上，而是分散到多个task进行join了。具体原理见下图。</p>
<p><strong>方案优点</strong>：对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。</p>
<p><strong>方案缺点</strong>：如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。</p>
<p><img src="/61c7dabc.png" alt="img"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 首先从包含了少数几个导致数据倾斜key的rdd1中，采样10%的样本数据。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> sampledRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">String</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">=</span> rdd1<span style="color:#f92672">.</span>sample<span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">0.1</span><span style="color:#f92672">);</span>
  
<span style="color:#75715e">// 对样本数据RDD统计出每个key的出现次数，并按出现次数降序排序。
</span><span style="color:#75715e">// 对降序排序后的数据，取出top 1或者top 100的数据，也就是key最多的前n个数据。
</span><span style="color:#75715e">// 具体取出多少个数据量最多的key，由大家自己决定，我们这里就取1个作为示范。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> mappedSampledRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Long</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> sampledRDD<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">(</span>tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">,</span> <span style="color:#ae81ff">1L</span><span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>
<span style="color:#66d9ef">val</span> countedSampledRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Long</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> mappedSampledRDD<span style="color:#f92672">.</span>reduceByKey<span style="color:#f92672">((</span>v1<span style="color:#f92672">,</span> v2<span style="color:#f92672">)</span> <span style="color:#f92672">=&gt;{</span>
  v1<span style="color:#f92672">+</span>v2
<span style="color:#f92672">})</span>
<span style="color:#66d9ef">val</span> reversedSampledRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">Long</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> countedSampledRDD<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span> 
  <span style="color:#f92672">(</span>tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">,</span> tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>
<span style="color:#66d9ef">val</span> <span style="color:#66d9ef">final</span> skewedUserid<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Long</span> <span style="color:#f92672">=</span> reversedSampledRDD<span style="color:#f92672">.</span>sortByKey<span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">).</span>take<span style="color:#f92672">(</span><span style="color:#ae81ff">1</span><span style="color:#f92672">).</span>get<span style="color:#f92672">(</span><span style="color:#ae81ff">0</span><span style="color:#f92672">).</span>_2<span style="color:#f92672">;</span>
  
<span style="color:#75715e">// 从rdd1中分拆出导致数据倾斜的key，形成独立的RDD。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> skewedRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">String</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd1<span style="color:#f92672">.</span>filter<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">.</span>equals<span style="color:#f92672">(</span>skewedUserid<span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>

<span style="color:#75715e">// 从rdd1中分拆出不导致数据倾斜的普通key，形成独立的RDD。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> commonRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">String</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd1<span style="color:#f92672">.</span>filter<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#f92672">!</span>tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">.</span>equals<span style="color:#f92672">(</span>skewedUserid<span style="color:#f92672">);</span>
<span style="color:#f92672">})</span>
  
<span style="color:#75715e">// rdd2，就是那个所有key的分布相对较为均匀的rdd。
</span><span style="color:#75715e">// 这里将rdd2中，前面获取到的key对应的数据，过滤出来，分拆成单独的rdd，并对rdd中的数据使用flatMap算子都扩容100倍。
</span><span style="color:#75715e">// 对扩容的每条数据，都打上0～100的前缀。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> skewedRdd2<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd2<span style="color:#f92672">.</span>filter<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">.</span>equals<span style="color:#f92672">(</span>skewedUserid<span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>
<span style="color:#f92672">.</span>flatMap<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">val</span> random<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Random</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Random</span><span style="color:#f92672">()</span>
  <span style="color:#66d9ef">val</span> list<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]()</span>
  <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>i <span style="color:#66d9ef">&lt;-</span> <span style="color:#ae81ff">0</span> until <span style="color:#ae81ff">100</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    list<span style="color:#f92672">.</span>add<span style="color:#f92672">((</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">+</span> tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">,</span> tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">));</span>
  <span style="color:#f92672">}</span>
  list
<span style="color:#f92672">})</span>
 
<span style="color:#75715e">// 将rdd1中分拆出来的导致倾斜的key的独立rdd，每条数据都打上100以内的随机前缀。
</span><span style="color:#75715e">// 然后将这个rdd1中分拆出来的独立rdd，与上面rdd2中分拆出来的独立rdd，进行join。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> joinedRDD1<span style="color:#66d9ef">:</span><span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#f92672">(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">))]</span> <span style="color:#66d9ef">=</span> skewedRDD<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">val</span> random<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Random</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Random</span><span style="color:#f92672">();</span>
  <span style="color:#66d9ef">var</span> prefix<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>nextInt<span style="color:#f92672">(</span><span style="color:#ae81ff">100</span><span style="color:#f92672">);</span>
  <span style="color:#f92672">(</span>prefix <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">+</span> tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">,</span> tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">);</span>
<span style="color:#f92672">})</span>
<span style="color:#f92672">.</span>join<span style="color:#f92672">(</span>skewedUserid2infoRDD<span style="color:#f92672">)</span>
<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">val</span> key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Long</span> <span style="color:#f92672">=</span> tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">.</span>split<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;_&#34;</span><span style="color:#f92672">)[</span><span style="color:#960050;background-color:#1e0010">1</span><span style="color:#f92672">].</span>toLong
  <span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>
 
<span style="color:#75715e">// 将rdd1中分拆出来的包含普通key的独立rdd，直接与rdd2进行join。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> joinedRDD2<span style="color:#66d9ef">:</span><span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#f92672">(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">))]</span> <span style="color:#66d9ef">=</span> commonRDD<span style="color:#f92672">.</span>join<span style="color:#f92672">(</span>rdd2<span style="color:#f92672">);</span>
 
<span style="color:#75715e">// 将倾斜key join后的结果与普通key join后的结果，uinon起来。
</span><span style="color:#75715e">// 就是最终的join结果。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> joinedRDD<span style="color:#66d9ef">:</span><span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#f92672">(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">))]</span> <span style="color:#66d9ef">=</span> joinedRDD1<span style="color:#f92672">.</span>union<span style="color:#f92672">(</span>joinedRDD2<span style="color:#f92672">);</span>
</code></pre></div><h2 id="使用随机前缀和扩容rdd进行join">使用随机前缀和扩容RDD进行join</h2>
<p><strong>方案适用场景</strong>：如果在进行join操作时，RDD中有大量的key导致数据倾斜，那么进行分拆key也没什么意义，此时就只能使用最后一种方案来解决问题了。</p>
<p><strong>方案实现思路</strong>：</p>
<ol>
<li>该方案的实现思路基本和“解决方案六”类似，首先查看RDD/Hive表中的数据分布情况，找到那个造成数据倾斜的RDD/Hive表，比如有多个key都对应了超过1万条数据。</li>
<li>然后将该RDD的每条数据都打上一个n以内的随机前缀。</li>
<li>同时对另外一个正常的RDD进行扩容，将每条数据都扩容成n条数据，扩容出来的每条数据都依次打上一个0~n的前缀。</li>
<li>最后将两个处理后的RDD进行join即可。</li>
</ol>
<p><strong>方案实现原理</strong>：将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的“不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。该方案与“解决方案六”的不同之处就在于，上一种方案是尽量只对少数倾斜key对应的数据进行特殊处理，由于处理过程需要扩容RDD，因此上一种方案扩容RDD后对内存的占用并不大；而这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，因此只能对整个RDD进行数据扩容，对内存资源要求很高。</p>
<p><strong>方案优点</strong>：对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。</p>
<p><strong>方案缺点</strong>：该方案更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。</p>
<p><strong>方案实践经验</strong>：曾经开发一个数据需求的时候，发现一个join导致了数据倾斜。优化之前，作业的执行时间大约是60分钟左右；使用该方案优化之后，执行时间缩短到10分钟左右，性能提升了6倍。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 首先将其中一个key分布相对较为均匀的RDD膨胀100倍。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> expandedRDD<span style="color:#66d9ef">:</span><span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd1<span style="color:#f92672">.</span>flatMap<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">val</span> list<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">)]();</span>
  <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>i <span style="color:#66d9ef">&lt;-</span> <span style="color:#ae81ff">0</span> until <span style="color:#ae81ff">100</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    list<span style="color:#f92672">.</span>add<span style="color:#f92672">((</span>i <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">+</span> tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">,</span> tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">));</span>
  <span style="color:#f92672">}</span>
  list
<span style="color:#f92672">}</span>
                                                  <span style="color:#f92672">})</span>
  
<span style="color:#75715e">// 其次，将另一个有数据倾斜key的RDD，每条数据都打上100以内的随机前缀。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> mappedRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">String</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> rdd2<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple <span style="color:#66d9ef">=&gt;</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">val</span> random<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Random</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Random</span><span style="color:#f92672">()</span>
  <span style="color:#66d9ef">var</span> prefix<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>nextInt<span style="color:#f92672">(</span><span style="color:#ae81ff">100</span><span style="color:#f92672">)</span>
  <span style="color:#f92672">(</span>prefix <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">+</span> tuple<span style="color:#f92672">.</span>_1<span style="color:#f92672">,</span> tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">)</span>
<span style="color:#f92672">})</span>
  
<span style="color:#75715e">// 将两个处理后的RDD进行join即可。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> joinedRDD<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">String</span>, <span style="color:#f92672">(</span><span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Row</span><span style="color:#f92672">))]</span> <span style="color:#66d9ef">=</span> mappedRDD<span style="color:#f92672">.</span>join<span style="color:#f92672">(</span>expandedRDD<span style="color:#f92672">)</span>
</code></pre></div><h2 id="多种方案组合使用">多种方案组合使用</h2>
<p>在实践中发现，很多情况下，如果只是处理较为简单的数据倾斜场景，那么使用上述方案中的某一种基本就可以解决。但是如果要处理一个较为复杂的数据倾斜场景，那么可能需要将多种方案组合起来使用。比如说，我们针对出现了多个数据倾斜环节的Spark作业，可以先运用解决方案一和二，预处理一部分数据，并过滤一部分数据来缓解；其次可以对某些shuffle操作提升并行度，优化其性能；最后还可以针对不同的聚合或join操作，选择一种方案来优化其性能。大家需要对这些方案的思路和原理都透彻理解之后，在实践中根据各种不同的情况，灵活运用多种方案，来解决自己的数据倾斜问题。</p>
<h1 id="shufflemanager">ShuffleManager</h1>
<p>大多数Spark作业的性能主要就是消耗在了shuffle环节，因为该环节包含了大量的磁盘IO、序列化、网络数据传输等操作。因此，如果要让作业的性能更上一层楼，就有必要对shuffle过程进行调优。但是也必须提醒大家的是，影响一个Spark作业性能的因素，主要还是代码开发、资源参数以及数据倾斜，shuffle调优只能在整个Spark的性能调优中占到一小部分而已。因此大家务必把握住调优的基本原则，千万不要舍本逐末。下面我们就给大家详细讲解shuffle的原理，以及相关参数的说明，同时给出各个参数的调优建议。</p>
<h2 id="shufflemanager发展概述">ShuffleManager发展概述</h2>
<p>在Spark的源码中，负责shuffle过程的执行、计算和处理的组件主要就是ShuffleManager，也即shuffle管理器。而随着Spark的版本的发展，ShuffleManager也在不断迭代，变得越来越先进。</p>
<p>在Spark 1.2以前，默认的shuffle计算引擎是HashShuffleManager。该ShuffleManager而HashShuffleManager有着一个非常严重的弊端，就是会产生大量的中间磁盘文件，进而由大量的磁盘IO操作影响了性能。</p>
<p>因此在Spark 1.2以后的版本中，默认的ShuffleManager改成了SortShuffleManager。SortShuffleManager相较于HashShuffleManager来说，有了一定的改进。主要就在于，每个Task在进行shuffle操作时，虽然也会产生较多的临时磁盘文件，但是最后会将所有的临时文件合并（merge）成一个磁盘文件，因此每个Task就只有一个磁盘文件。在下一个stage的shuffle read task拉取自己的数据时，只要根据索引读取每个磁盘文件中的部分数据即可。</p>
<p>下面我们详细分析一下HashShuffleManager和SortShuffleManager的原理。</p>
<h2 id="hashshufflemanager运行原理">HashShuffleManager运行原理</h2>
<h3 id="未经优化的hashshufflemanager">未经优化的HashShuffleManager</h3>
<p>下图说明了未经优化的HashShuffleManager的原理。这里我们先明确一个假设前提：每个Executor只有1个CPU core，也就是说，无论这个Executor上分配多少个task线程，同一时间都只能执行一个task线程。</p>
<p>我们先从shuffle write开始说起。shuffle write阶段，主要就是在一个stage结束计算之后，为了下一个stage可以执行shuffle类的算子（比如reduceByKey），而将每个task处理的数据按key进行“分类”。所谓“分类”，就是对相同的key执行hash算法，从而将相同key都写入同一个磁盘文件中，而每一个磁盘文件都只属于下游stage的一个task。在将数据写入磁盘之前，会先将数据写入内存缓冲中，当内存缓冲填满之后，才会溢写到磁盘文件中去。</p>
<p>那么每个执行shuffle write的task，要为下一个stage创建多少个磁盘文件呢？很简单，下一个stage的task有多少个，当前stage的每个task就要创建多少份磁盘文件。比如下一个stage总共有100个task，那么当前stage的每个task都要创建100份磁盘文件。如果当前stage有50个task，总共有10个Executor，每个Executor执行5个Task，那么每个Executor上总共就要创建500个磁盘文件，所有Executor上会创建5000个磁盘文件。由此可见，未经优化的shuffle write操作所产生的磁盘文件的数量是极其惊人的。</p>
<p>接着我们来说说shuffle read。shuffle read，通常就是一个stage刚开始时要做的事情。此时该stage的每一个task就需要将上一个stage的计算结果中的所有相同key，从各个节点上通过网络都拉取到自己所在的节点上，然后进行key的聚合或连接等操作。由于shuffle write的过程中，task给下游stage的每个task都创建了一个磁盘文件，因此shuffle read的过程中，每个task只要从上游stage的所有task所在节点上，拉取属于自己的那一个磁盘文件即可。</p>
<p>shuffle read的拉取过程是一边拉取一边进行聚合的。每个shuffle read task都会有一个自己的buffer缓冲，每次都只能拉取与buffer缓冲相同大小的数据，然后通过内存中的一个Map进行聚合等操作。聚合完一批数据后，再拉取下一批数据，并放到buffer缓冲中进行聚合操作。以此类推，直到最后将所有数据到拉取完，并得到最终的结果。</p>
<p><img src="/%E6%9C%AA%E7%BB%8F%E4%BC%98%E5%8C%96%E7%9A%84hashShuffleManager.png" alt="img"></p>
<h3 id="优化后的hashshufflemanager">优化后的HashShuffleManager</h3>
<p>下图说明了优化后的HashShuffleManager的原理。这里说的优化，是指我们可以设置一个参数，spark.shuffle.consolidateFiles。该参数默认值为false，将其设置为true即可开启优化机制。通常来说，如果我们使用HashShuffleManager，那么都建议开启这个选项。</p>
<p>开启consolidate机制之后，在shuffle write过程中，task就不是为下游stage的每个task创建一个磁盘文件了。此时会出现shuffleFileGroup的概念，每个shuffleFileGroup会对应一批磁盘文件，磁盘文件的数量与下游stage的task数量是相同的。一个Executor上有多少个CPU core，就可以并行执行多少个task。而第一批并行执行的每个task都会创建一个shuffleFileGroup，并将数据写入对应的磁盘文件内。</p>
<p>当Executor的CPU core执行完一批task，接着执行下一批task时，下一批task就会复用之前已有的shuffleFileGroup，包括其中的磁盘文件。也就是说，此时task会将数据写入已有的磁盘文件中，而不会写入新的磁盘文件中。因此，consolidate机制允许不同的task复用同一批磁盘文件，这样就可以有效将多个task的磁盘文件进行一定程度上的合并，从而大幅度减少磁盘文件的数量，进而提升shuffle write的性能。</p>
<p>假设第二个stage有100个task，第一个stage有50个task，总共还是有10个Executor，每个Executor执行5个task。那么原本使用未经优化的HashShuffleManager时，每个Executor会产生500个磁盘文件，所有Executor会产生5000个磁盘文件的。但是此时经过优化之后，每个Executor创建的磁盘文件的数量的计算公式为：CPU core的数量 * 下一个stage的task数量。也就是说，每个Executor此时只会创建100个磁盘文件，所有Executor只会创建1000个磁盘文件。</p>
<p><img src="/%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84hashshufflemanager.png" alt="img"></p>
<h2 id="sortshufflemanager运行原理">SortShuffleManager运行原理</h2>
<p>SortShuffleManager的运行机制主要分成两种，一种是普通运行机制，另一种是bypass运行机制。当shuffle read task的数量小于等于spark.shuffle.sort.bypassMergeThreshold参数的值时（默认为200），就会启用bypass机制。</p>
<h3 id="普通运行机制">普通运行机制</h3>
<p>下图说明了普通的SortShuffleManager的原理。在该模式下，数据会先写入一个内存数据结构中，此时根据不同的shuffle算子，可能选用不同的数据结构。如果是reduceByKey这种聚合类的shuffle算子，那么会选用Map数据结构，一边通过Map进行聚合，一边写入内存；如果是join这种普通的shuffle算子，那么会选用Array数据结构，直接写入内存。接着，每写一条数据进入内存数据结构之后，就会判断一下，是否达到了某个临界阈值。如果达到临界阈值的话，那么就会尝试将内存数据结构中的数据溢写到磁盘，然后清空内存数据结构。</p>
<p>在溢写到磁盘文件之前，会先根据key对内存数据结构中已有的数据进行排序。排序过后，会分批将数据写入磁盘文件。默认的batch数量是10000条，也就是说，排序好的数据，会以每批1万条数据的形式分批写入磁盘文件。写入磁盘文件是通过Java的BufferedOutputStream实现的。BufferedOutputStream是Java的缓冲输出流，首先会将数据缓冲在内存中，当内存缓冲满溢之后再一次写入磁盘文件中，这样可以减少磁盘IO次数，提升性能。</p>
<p>一个task将所有数据写入内存数据结构的过程中，会发生多次磁盘溢写操作，也就会产生多个临时文件。最后会将之前所有的临时磁盘文件都进行合并，这就是merge过程，此时会将之前所有临时磁盘文件中的数据读取出来，然后依次写入最终的磁盘文件之中。此外，由于一个task就只对应一个磁盘文件，也就意味着该task为下游stage的task准备的数据都在这一个文件中，因此还会单独写一份索引文件，其中标识了下游各个task的数据在文件中的start offset与end offset。</p>
<p>SortShuffleManager由于有一个磁盘文件merge的过程，因此大大减少了文件数量。比如第一个stage有50个task，总共有10个Executor，每个Executor执行5个task，而第二个stage有100个task。由于每个task最终只有一个磁盘文件，因此此时每个Executor上只有5个磁盘文件，所有Executor只有50个磁盘文件。</p>
<p><img src="/SortShuffleManager%E6%AD%A3%E5%B8%B8%E6%A8%A1%E5%BC%8F.png" alt="img"></p>
<h3 id="bypass运行机制">bypass运行机制</h3>
<p>下图说明了bypass SortShuffleManager的原理。bypass运行机制的触发条件如下： * shuffle map task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值。 * 不是聚合类的shuffle算子（比如reduceByKey）。</p>
<p>此时task会为每个下游task都创建一个临时磁盘文件，并将数据按key进行hash然后根据key的hash值，将key写入对应的磁盘文件之中。当然，写入磁盘文件时也是先写入内存缓冲，缓冲写满之后再溢写到磁盘文件的。最后，同样会将所有临时磁盘文件都合并成一个磁盘文件，并创建一个单独的索引文件。</p>
<p>该过程的磁盘写机制其实跟未经优化的HashShuffleManager是一模一样的，因为都要创建数量惊人的磁盘文件，只是在最后会做一个磁盘文件的合并而已。因此少量的最终磁盘文件，也让该机制相对未经优化的HashShuffleManager来说，shuffle read的性能会更好。</p>
<p>而该机制与普通SortShuffleManager运行机制的不同在于：第一，磁盘写机制不同；第二，不会进行排序。也就是说，启用该机制的最大好处在于，shuffle write过程中，不需要进行数据的排序操作，也就节省掉了这部分的性能开销。</p>
<p>![img](/sortshufflemanager bypass模式.png)</p>
<h1 id="shuffle相关参数调优">shuffle相关参数调优</h1>
<p>以下是Shffule过程中的一些主要参数，这里详细讲解了各个参数的功能、默认值以及基于实践经验给出的调优建议。</p>
<ul>
<li>
<p>spark.shuffle.file.buffer</p>
<ul>
<li>默认值：32k</li>
<li>参数说明：该参数用于设置shuffle write task的BufferedOutputStream的buffer缓冲大小。将数据写到磁盘文件之前，会先写入buffer缓冲中，待缓冲写满之后，才会溢写到磁盘。</li>
<li>调优建议：如果作业可用的内存资源较为充足的话，可以适当增加这个参数的大小（比如64k），从而减少shuffle write过程中溢写磁盘文件的次数，也就可以减少磁盘IO次数，进而提升性能。在实践中发现，合理调节该参数，性能会有1%~5%的提升。</li>
</ul>
</li>
<li>
<p>spark.reducer.maxSizeInFlight</p>
<ul>
<li>默认值：48m</li>
<li>参数说明：该参数用于设置shuffle read task的buffer缓冲大小，而这个buffer缓冲决定了每次能够拉取多少数据。</li>
<li>调优建议：如果作业可用的内存资源较为充足的话，可以适当增加这个参数的大小（比如96m），从而减少拉取数据的次数，也就可以减少网络传输的次数，进而提升性能。在实践中发现，合理调节该参数，性能会有1%~5%的提升。</li>
</ul>
</li>
<li>
<p>spark.shuffle.io.maxRetries</p>
<ul>
<li>默认值：3</li>
<li>参数说明：shuffle read task从shuffle write task所在节点拉取属于自己的数据时，如果因为网络异常导致拉取失败，是会自动进行重试的。该参数就代表了可以重试的最大次数。如果在指定次数之内拉取还是没有成功，就可能会导致作业执行失败。</li>
<li>调优建议：对于那些包含了特别耗时的shuffle操作的作业，建议增加重试最大次数（比如60次），以避免由于JVM的full gc或者网络不稳定等因素导致的数据拉取失败。在实践中发现，对于针对超大数据量（数十亿~上百亿）的shuffle过程，调节该参数可以大幅度提升稳定性。</li>
</ul>
</li>
<li>
<p>spark.shuffle.io.retryWait</p>
<ul>
<li>默认值：5s</li>
<li>参数说明：具体解释同上，该参数代表了每次重试拉取数据的等待间隔，默认是5s。</li>
<li>调优建议：建议加大间隔时长（比如60s），以增加shuffle操作的稳定性。</li>
</ul>
</li>
<li>
<p>spark.shuffle.memoryFraction</p>
<ul>
<li>默认值：0.2</li>
<li>参数说明：该参数代表了Executor内存中，分配给shuffle read task进行聚合操作的内存比例，默认是20%。</li>
<li>调优建议：在资源参数调优中讲解过这个参数。如果内存充足，而且很少使用持久化操作，建议调高这个比例，给shuffle read的聚合操作更多内存，以避免由于内存不足导致聚合过程中频繁读写磁盘。在实践中发现，合理调节该参数可以将性能提升10%左右。</li>
</ul>
</li>
<li>
<p>spark.shuffle.manager</p>
<ul>
<li>默认值：sort</li>
<li>参数说明：该参数用于设置ShuffleManager的类型。Spark 1.5以后，有三个可选项：hash、sort和tungsten-sort。HashShuffleManager是Spark 1.2以前的默认选项，但是Spark 1.2以及之后的版本默认都是SortShuffleManager了。tungsten-sort与sort类似，但是使用了tungsten计划中的堆外内存管理机制，内存使用效率更高。</li>
<li>调优建议：由于SortShuffleManager默认会对数据进行排序，因此如果你的业务逻辑中需要该排序机制的话，则使用默认的SortShuffleManager就可以；而如果你的业务逻辑不需要对数据进行排序，那么建议参考后面的几个参数调优，通过bypass机制或优化的HashShuffleManager来避免排序操作，同时提供较好的磁盘读写性能。这里要注意的是，tungsten-sort要慎用，因为之前发现了一些相应的bug。</li>
</ul>
</li>
<li>
<p>spark.shuffle.sort.bypassMergeThreshold</p>
<ul>
<li>默认值：200</li>
<li>参数说明：当ShuffleManager为SortShuffleManager时，如果shuffle read task的数量小于这个阈值（默认是200），则shuffle write过程中不会进行排序操作，而是直接按照未经优化的HashShuffleManager的方式去写数据，但是最后会将每个task产生的所有临时磁盘文件都合并成一个文件，并会创建单独的索引文件。</li>
<li>调优建议：当你使用SortShuffleManager时，如果的确不需要排序操作，那么建议将这个参数调大一些，大于shuffle read task的数量。那么此时就会自动启用bypass机制，map-side就不会进行排序了，减少了排序的性能开销。但是这种方式下，依然会产生大量的磁盘文件，因此shuffle write性能有待提高。</li>
</ul>
</li>
<li>
<p>spark.shuffle.consolidateFiles</p>
<ul>
<li>默认值：false</li>
<li>参数说明：如果使用HashShuffleManager，该参数有效。如果设置为true，那么就会开启consolidate机制，会大幅度合并shuffle write的输出文件，对于shuffle read task数量特别多的情况下，这种方法可以极大地减少磁盘IO开销，提升性能。</li>
<li>调优建议：如果的确不需要SortShuffleManager的排序机制，那么除了使用bypass机制，还可以尝试将spark.shffle.manager参数手动指定为hash，使用HashShuffleManager，同时开启consolidate机制。在实践中尝试过，发现其性能比开启了bypass机制的SortShuffleManager要高出10%~30%。</li>
</ul>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>spark调优</title>
            <link>http://keltoy.github.io/posts/spark%E8%B0%83%E4%BC%98/</link>
            <pubDate>Tue, 12 May 2020 15:35:34 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/spark%E8%B0%83%E4%BC%98/</guid>
            <description>Spark 调优 [toc]
前言 发现两篇古老的调优数据，复制一下 原链接
避免创建重复的RDD 通常来说，在开发Spark作业时，
 首先是基于某个数据源创建一个初始RDD 对这个RDD执行算子操作，得到下一个RDD 以此类推，循环上述步骤 得出最终结果  这个过程中通过不同的算子操作(map, reduce等)串起多个RDD,就是 RDD lineage，也就是RDD的血缘关系链
需要注意的是： 对于同一份数据，应该只创建一个RDD，不能创建多个RDD来代表同一个数据
同一份数据创建了多个RDD意味着 spark作业会进行多次重复计算来创建多个代表相同数据的RDD，进而增加了作业的性能开销
// 需要对名为“hello.txt”的HDFS文件进行一次map操作，再进行一次reduce操作。也就是说，需要对一份数据执行两次算子操作。  // 错误的做法：对于同一份数据执行多次算子操作时，创建多个RDD。 // 这里执行了两次textFile方法，针对同一个HDFS文件，创建了两个RDD出来，然后分别对每个RDD都执行了一个算子操作。 // 这种情况下，Spark需要从HDFS上两次加载hello.txt文件的内容，并创建两个单独的RDD；第二次加载HDFS文件以及创建RDD的性能开销，很明显是白白浪费掉的。 val rdd1 = sc.textFile(&amp;#34;hdfs://192.168.0.1:9000/hello.txt&amp;#34;) rdd1.map(...) val rdd2 = sc.textFile(&amp;#34;hdfs://192.168.0.1:9000/hello.txt&amp;#34;) rdd2.reduce(...) // 正确的用法：对于一份数据执行多次算子操作时，只使用一个RDD。 // 这种写法很明显比上一种写法要好多了，因为我们对于同一份数据只创建了一个RDD，然后对这一个RDD执行了多次算子操作。 // 但是要注意到这里为止优化还没有结束，由于rdd1被执行了两次算子操作，第二次执行reduce操作的时候，还会再次从源头处重新计算一次rdd1的数据，因此还是会有重复计算的性能开销。 // 要彻底解决这个问题，必须结合“原则三：对多次使用的RDD进行持久化”，才能保证一个RDD被多次使用时只被计算一次。 val rdd1 = sc.textFile(&amp;#34;hdfs://192.168.0.1:9000/hello.txt&amp;#34;) rdd1.map(...) rdd1.reduce(...) 尽可能复用一个RDD 在不同的数据执行算子操作时，还要尽可能复用一个RDD。数据有重叠、或者有包含的情况下，应该减少RDD的数量，尽可能减少算子的执行次数
// 错误的做法。  // 有一个&amp;lt;Long, String&amp;gt;格式的RDD，即rdd1。 // 接着由于业务需要，对rdd1执行了一个map操作，创建了一个rdd2，而rdd2中的数据仅仅是rdd1中的value值而已，也就是说，rdd2是rdd1的子集。 val rdd1: RDD[(Long, String)] = .</description>
            <content type="html"><![CDATA[<h1 id="spark-调优">Spark 调优</h1>
<p>[toc]</p>
<h2 id="前言">前言</h2>
<p>发现两篇古老的调优数据，复制一下 <a href="https://tech.meituan.com/2016/04/29/spark-tuning-basic.html">原链接</a></p>
<h2 id="避免创建重复的rdd">避免创建重复的RDD</h2>
<p>通常来说，在开发Spark作业时，</p>
<ol>
<li>首先是基于某个数据源创建一个初始RDD</li>
<li>对这个RDD执行算子操作，得到下一个RDD</li>
<li>以此类推，循环上述步骤</li>
<li>得出最终结果</li>
</ol>
<p>这个过程中通过不同的算子操作(map, reduce等)串起多个RDD,就是 RDD lineage，也就是RDD的血缘关系链</p>
<p>需要注意的是： <strong>对于同一份数据，应该只创建一个RDD，不能创建多个RDD来代表同一个数据</strong></p>
<p>同一份数据创建了多个RDD意味着 spark作业会进行多次重复计算来创建多个代表相同数据的RDD，进而增加了作业的性能开销</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 需要对名为“hello.txt”的HDFS文件进行一次map操作，再进行一次reduce操作。也就是说，需要对一份数据执行两次算子操作。
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 错误的做法：对于同一份数据执行多次算子操作时，创建多个RDD。
</span><span style="color:#75715e">// 这里执行了两次textFile方法，针对同一个HDFS文件，创建了两个RDD出来，然后分别对每个RDD都执行了一个算子操作。
</span><span style="color:#75715e">// 这种情况下，Spark需要从HDFS上两次加载hello.txt文件的内容，并创建两个单独的RDD；第二次加载HDFS文件以及创建RDD的性能开销，很明显是白白浪费掉的。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd1 <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>textFile<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hdfs://192.168.0.1:9000/hello.txt&#34;</span><span style="color:#f92672">)</span>
rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(...)</span>
<span style="color:#66d9ef">val</span> rdd2 <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>textFile<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hdfs://192.168.0.1:9000/hello.txt&#34;</span><span style="color:#f92672">)</span>
rdd2<span style="color:#f92672">.</span>reduce<span style="color:#f92672">(...)</span>

<span style="color:#75715e">// 正确的用法：对于一份数据执行多次算子操作时，只使用一个RDD。
</span><span style="color:#75715e">// 这种写法很明显比上一种写法要好多了，因为我们对于同一份数据只创建了一个RDD，然后对这一个RDD执行了多次算子操作。
</span><span style="color:#75715e">// 但是要注意到这里为止优化还没有结束，由于rdd1被执行了两次算子操作，第二次执行reduce操作的时候，还会再次从源头处重新计算一次rdd1的数据，因此还是会有重复计算的性能开销。
</span><span style="color:#75715e">// 要彻底解决这个问题，必须结合“原则三：对多次使用的RDD进行持久化”，才能保证一个RDD被多次使用时只被计算一次。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd1 <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>textFile<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hdfs://192.168.0.1:9000/hello.txt&#34;</span><span style="color:#f92672">)</span>
rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(...)</span>
rdd1<span style="color:#f92672">.</span>reduce<span style="color:#f92672">(...)</span>
</code></pre></div><h3 id="尽可能复用一个rdd">尽可能复用一个RDD</h3>
<p>在不同的数据执行算子操作时，还要尽可能复用一个RDD。数据有重叠、或者有包含的情况下，应该减少RDD的数量，尽可能减少算子的执行次数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 错误的做法。
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 有一个&lt;Long, String&gt;格式的RDD，即rdd1。
</span><span style="color:#75715e">// 接着由于业务需要，对rdd1执行了一个map操作，创建了一个rdd2，而rdd2中的数据仅仅是rdd1中的value值而已，也就是说，rdd2是rdd1的子集。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd1<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">String</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> <span style="color:#f92672">...</span>
<span style="color:#66d9ef">val</span> rdd2<span style="color:#66d9ef">:</span><span style="color:#960050;background-color:#1e0010">[</span><span style="color:#66d9ef">String</span><span style="color:#960050;background-color:#1e0010">]</span><span style="color:#f92672">=</span> rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(...)</span>

<span style="color:#75715e">// 分别对rdd1和rdd2执行了不同的算子操作。
</span><span style="color:#75715e"></span>rdd1<span style="color:#f92672">.</span>reduceByKey<span style="color:#f92672">(...)</span>
rdd2<span style="color:#f92672">.</span>map<span style="color:#f92672">(...)</span>

<span style="color:#75715e">// 正确的做法。
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 上面这个case中，其实rdd1和rdd2的区别无非就是数据格式不同而已，rdd2的数据完全就是rdd1的子集而已，却创建了两个rdd，并对两个rdd都执行了一次算子操作。
</span><span style="color:#75715e">// 此时会因为对rdd1执行map算子来创建rdd2，而多执行一次算子操作，进而增加性能开销。
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 其实在这种情况下完全可以复用同一个RDD。
</span><span style="color:#75715e">// 我们可以使用rdd1，既做reduceByKey操作，也做map操作。
</span><span style="color:#75715e">// 在进行第二个map操作时，只使用每个数据的tuple._2，也就是rdd1中的value值，即可。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd1<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RDD</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Long</span>, <span style="color:#66d9ef">String</span><span style="color:#f92672">)]</span> <span style="color:#66d9ef">=</span> <span style="color:#f92672">...</span>
rdd1<span style="color:#f92672">.</span>reduceByKey<span style="color:#f92672">(...)</span>
rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>tuple<span style="color:#f92672">.</span>_2<span style="color:#f92672">...)</span>

<span style="color:#75715e">// 第二种方式相较于第一种方式而言，很明显减少了一次rdd2的计算开销。
</span><span style="color:#75715e">// 但是到这里为止，优化还没有结束，对rdd1我们还是执行了两次算子操作，rdd1实际上还是会被计算两次。
</span><span style="color:#75715e">// 因此还需要配合“原则三：对多次使用的RDD进行持久化”进行使用，才能保证一个RDD被多次使用时只被计算一次。
</span></code></pre></div><h3 id="对多次使用的rdd进行持久化">对多次使用的RDD进行持久化</h3>
<p>Spark中对于一个RDD执行多次算子，每次对一个RDD执行一个算子操作时，都会重新从源头处计算一遍，计算出RDD来，然后再对这个RDD执行下一个算子操作。这种方式的性能是很差的。
因此对于这种情况，对多次使用的RDD进行持久化。此时Spark就会根据你的持久化策略，将RDD中的数据保存到内存或者磁盘中。以后每次对这个RDD进行算子操作时，都会直接从内存或磁盘中提取持久化的RDD数据，然后执行算子，而不会从源头处重新计算一遍这个RDD，再执行算子操作。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 如果要对一个RDD进行持久化，只要对这个RDD调用cache()和persist()即可。
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 正确的做法。
</span><span style="color:#75715e">// cache()方法表示：使用非序列化的方式将RDD中的数据全部尝试持久化到内存中。
</span><span style="color:#75715e">// 此时再对rdd1执行两次算子操作时，只有在第一次执行map算子时，才会将这个rdd1从源头处计算一次。
</span><span style="color:#75715e">// 第二次执行reduce算子时，就会直接从内存中提取数据进行计算，不会重复计算一个rdd。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd1 <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>textFile<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hdfs://192.168.0.1:9000/hello.txt&#34;</span><span style="color:#f92672">).</span>cache<span style="color:#f92672">()</span>
rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(...)</span>
rdd1<span style="color:#f92672">.</span>reduce<span style="color:#f92672">(...)</span>

<span style="color:#75715e">// persist()方法表示：手动选择持久化级别，并使用指定的方式进行持久化。
</span><span style="color:#75715e">// 比如说，StorageLevel.MEMORY_AND_DISK_SER表示，内存充足时优先持久化到内存中，内存不充足时持久化到磁盘文件中。
</span><span style="color:#75715e">// 而且其中的_SER后缀表示，使用序列化的方式来保存RDD数据，此时RDD中的每个partition都会序列化成一个大的字节数组，然后再持久化到内存或磁盘中。
</span><span style="color:#75715e">// 序列化的方式可以减少持久化的数据对内存/磁盘的占用量，进而避免内存被持久化数据占用过多，从而发生频繁GC。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd1 <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>textFile<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hdfs://192.168.0.1:9000/hello.txt&#34;</span><span style="color:#f92672">).</span>persist<span style="color:#f92672">(</span><span style="color:#a6e22e">StorageLevel</span><span style="color:#f92672">.</span><span style="color:#a6e22e">MEMORY_AND_DISK_SER</span><span style="color:#f92672">)</span>
rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(...)</span>
rdd1<span style="color:#f92672">.</span>reduce<span style="color:#f92672">(...)</span>
</code></pre></div><p>持久化级别</p>
<table>
<thead>
<tr>
<th style="text-align:center">持久化级别</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MEMORY_ONLY</td>
<td style="text-align:center">使用未序列化的Java对象格式，将数据保存在内存中。如果内存不够存放所有的数据，则数据可能就不会进行持久化。那么下次对这个RDD执行算子操作时，那些没有被持久化的数据，需要从源头处重新计算一遍。这是默认的持久化策略，使用cache()方法时，实际就是使用的这种持久化策略。</td>
</tr>
<tr>
<td style="text-align:center">MEMORY_AND_DISK</td>
<td style="text-align:center">使用未序列化的Java对象格式，优先尝试将数据保存在内存中。如果内存不够存放所有的数据，会将数据写入磁盘文件中，下次对这个RDD执行算子时，持久化在磁盘文件中的数据会被读取出来使用。</td>
</tr>
<tr>
<td style="text-align:center">MEMORY_ONLY_SER</td>
<td style="text-align:center">基本含义同MEMORY_ONLY。唯一的区别是，会将RDD中的数据进行序列化，RDD的每个partition会被序列化成一个字节数组。这种方式更加节省内存，从而可以避免持久化的数据占用过多内存导致频繁GC。</td>
</tr>
<tr>
<td style="text-align:center">MEMORY_AND_DISK_SER</td>
<td style="text-align:center">基本含义同MEMORY_AND_DISK。唯一的区别是，会将RDD中的数据进行序列化，RDD的每个partition会被序列化成一个字节数组。这种方式更加节省内存，从而可以避免持久化的数据占用过多内存导致频繁GC。</td>
</tr>
<tr>
<td style="text-align:center">DISK_ONLY</td>
<td style="text-align:center">使用未序列化的Java对象格式，将数据全部写入磁盘文件中。</td>
</tr>
<tr>
<td style="text-align:center">MEMORY_ONLY_2, MEMORY_AND_DISK_2, 等等.</td>
<td style="text-align:center">对于上述任意一种持久化策略，如果加上后缀_2，代表的是将每个持久化的数据，都复制一份副本，并将副本保存到其他节点上。这种基于副本的持久化机制主要用于进行容错。假如某个节点挂掉，节点的内存或磁盘中的持久化数据丢失了，那么后续对RDD计算时还可以使用该数据在其他节点上的副本。如果没有副本的话，就只能将这些数据从源头处重新计算一遍了。</td>
</tr>
</tbody>
</table>
<ol>
<li>默认情况下，性能最高的当然是MEMORY_ONLY，但前提是你的内存必须足够足够大，可以绰绰有余地存放下整个RDD的所有数据。因为不进行序列化与反序列化操作，就避免了这部分的性能开销；对这个RDD的后续算子操作，都是基于纯内存中的数据的操作，不需要从磁盘文件中读取数据，性能也很高；而且不需要复制一份数据副本，并远程传送到其他节点上。但是这里必须要注意的是，在实际的生产环境中，恐怕能够直接用这种策略的场景还是有限的，如果RDD中数据比较多时（比如几十亿），直接用这种持久化级别，会导致JVM的OOM内存溢出异常。</li>
<li>如果使用MEMORY_ONLY级别时发生了内存溢出，那么建议尝试使用MEMORY_ONLY_SER级别。该级别会将RDD数据序列化后再保存在内存中，此时每个partition仅仅是一个字节数组而已，大大减少了对象数量，并降低了内存占用。这种级别比MEMORY_ONLY多出来的性能开销，主要就是序列化与反序列化的开销。但是后续算子可以基于纯内存进行操作，因此性能总体还是比较高的。此外，可能发生的问题同上，如果RDD中的数据量过多的话，还是可能会导致OOM内存溢出的异常。</li>
<li>如果纯内存的级别都无法使用，那么建议使用MEMORY_AND_DISK_SER策略，而不是MEMORY_AND_DISK策略。因为既然到了这一步，就说明RDD的数据量很大，内存无法完全放下。序列化后的数据比较少，可以节省内存和磁盘的空间开销。同时该策略会优先尽量尝试将数据缓存在内存中，内存缓存不下才会写入磁盘。</li>
<li>通常不建议使用DISK_ONLY和后缀为_2的级别：因为完全基于磁盘文件进行数据的读写，会导致性能急剧降低，有时还不如重新计算一次所有RDD。后缀为_2的级别，必须将所有数据都复制一份副本，并发送到其他节点上，数据复制以及网络传输会导致较大的性能开销，除非是要求作业的高可用性，否则不建议使用。</li>
</ol>
<h3 id="尽量避免使用shuffle类算子">尽量避免使用shuffle类算子</h3>
<p>因为Spark作业运行过程中，最消耗性能的地方就是shuffle过程。shuffle过程，简单来说，就是将分布在集群中多个节点上的同一个key，拉取到同一个节点上，进行聚合或join等操作。比如reduceByKey、join等算子，都会触发shuffle操作。</p>
<p>shuffle过程中，各个节点上的相同key都会先写入本地磁盘文件中，然后其他节点需要通过网络传输拉取各个节点上的磁盘文件中的相同key。而且相同key都拉取到同一个节点进行聚合操作时，还有可能会因为一个节点上处理的key过多，导致内存不够存放，进而溢写到磁盘文件中。因此在shuffle过程中，可能会发生大量的磁盘文件读写的IO操作，以及数据的网络传输操作。磁盘IO和网络数据传输也是shuffle性能较差的主要原因。</p>
<p>因此在我们的开发过程中，能避免则尽可能避免使用reduceByKey、join、distinct、repartition等会进行shuffle的算子，尽量使用map类的非shuffle算子。这样的话，没有shuffle操作或者仅有较少shuffle操作的Spark作业，可以大大减少性能开销。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 传统的join操作会导致shuffle操作。
</span><span style="color:#75715e">// 因为两个RDD中，相同的key都需要通过网络拉取到一个节点上，由一个task进行join操作。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd3 <span style="color:#66d9ef">=</span> rdd1<span style="color:#f92672">.</span>join<span style="color:#f92672">(</span>rdd2<span style="color:#f92672">)</span>

<span style="color:#75715e">// Broadcast+map的join操作，不会导致shuffle操作。
</span><span style="color:#75715e">// 使用Broadcast将一个数据量较小的RDD作为广播变量。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd2Data <span style="color:#66d9ef">=</span> rdd2<span style="color:#f92672">.</span>collect<span style="color:#f92672">()</span>
<span style="color:#66d9ef">val</span> rdd2DataBroadcast <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>broadcast<span style="color:#f92672">(</span>rdd2Data<span style="color:#f92672">)</span>

<span style="color:#75715e">// 在rdd1.map算子中，可以从rdd2DataBroadcast中，获取rdd2的所有数据。
</span><span style="color:#75715e">// 然后进行遍历，如果发现rdd2中某条数据的key与rdd1的当前数据的key是相同的，那么就判定可以进行join。
</span><span style="color:#75715e">// 此时就可以根据自己需要的方式，将rdd1当前数据与rdd2中可以连接的数据，拼接在一起（String或Tuple）。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> rdd3 <span style="color:#66d9ef">=</span> rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>rdd2DataBroadcast<span style="color:#f92672">.</span>value<span style="color:#f92672">...)</span>

<span style="color:#75715e">// 注意，以上操作，建议仅仅在rdd2的数据量比较少（比如几百M，或者一两G）的情况下使用。
</span><span style="color:#75715e">// 因为每个Executor的内存中，都会驻留一份rdd2的全量数据。
</span></code></pre></div><h3 id="使用map-side预聚合的shuffle操作">使用map-side预聚合的shuffle操作</h3>
<p>如果因为业务需要，一定要使用shuffle操作，无法用map类的算子来替代，那么尽量使用可以map-side预聚合的算子。</p>
<p>所谓的map-side预聚合，说的是在每个节点本地对相同的key进行一次聚合操作，类似于MapReduce中的本地combiner。map-side预聚合之后，每个节点本地就只会有一条相同的key，因为多条相同的key都被聚合起来了。其他节点在拉取所有节点上的相同key时，就会大大减少需要拉取的数据数量，从而也就减少了磁盘IO以及网络传输开销。通常来说，在可能的情况下，建议使用reduceByKey或者aggregateByKey算子来替代掉groupByKey算子。因为reduceByKey和aggregateByKey算子都会使用用户自定义的函数对每个节点本地的相同key进行预聚合。而groupByKey算子是不会进行预聚合的，全量的数据会在集群的各个节点之间分发和传输，性能相对来说比较差。</p>
<p>比如如下两幅图，就是典型的例子，分别基于reduceByKey和groupByKey进行单词计数。其中第一张图是groupByKey的原理图，可以看到，没有进行任何本地聚合时，所有数据都会在集群节点之间传输；第二张图是reduceByKey的原理图，可以看到，每个节点本地的相同key数据，都进行了预聚合，然后才传输到其他节点上进行全局聚合。</p>
<p><img src="/5ebe0848.png" alt="&hellip;..png">
<img src="/a6c7d4c4.png" alt="老八秘制小汉堡.png"></p>
<h3 id="使用高性能算子">使用高性能算子</h3>
<ul>
<li>使用reduceByKey/aggregateByKey替代groupByKey</li>
</ul>
<p>详情见“原则五：使用map-side预聚合的shuffle操作”。</p>
<ul>
<li>使用mapPartitions替代普通map</li>
</ul>
<p>mapPartitions类的算子，一次函数调用会处理一个partition所有的数据，而不是一次函数调用处理一条，性能相对来说会高一些。但是有的时候，使用mapPartitions会出现OOM（内存溢出）的问题。因为单次函数调用就要处理掉一个partition所有的数据，如果内存不够，垃圾回收时是无法回收掉太多对象的，很可能出现OOM异常。所以使用这类操作时要慎重！</p>
<ul>
<li>使用foreachPartitions替代foreach</li>
</ul>
<p>原理类似于“使用mapPartitions替代map”，也是一次函数调用处理一个partition的所有数据，而不是一次函数调用处理一条数据。在实践中发现，foreachPartitions类的算子，对性能的提升还是很有帮助的。比如在foreach函数中，将RDD中所有数据写MySQL，那么如果是普通的foreach算子，就会一条数据一条数据地写，每次函数调用可能就会创建一个数据库连接，此时就势必会频繁地创建和销毁数据库连接，性能是非常低下；但是如果用foreachPartitions算子一次性处理一个partition的数据，那么对于每个partition，只要创建一个数据库连接即可，然后执行批量插入操作，此时性能是比较高的。实践中发现，对于1万条左右的数据量写MySQL，性能可以提升30%以上。</p>
<ul>
<li>使用filter之后进行coalesce操作</li>
</ul>
<p>通常对一个RDD执行filter算子过滤掉RDD中较多数据后（比如30%以上的数据），建议使用coalesce算子，手动减少RDD的partition数量，将RDD中的数据压缩到更少的partition中去。因为filter之后，RDD的每个partition中都会有很多数据被过滤掉，此时如果照常进行后续的计算，其实每个task处理的partition中的数据量并不是很多，有一点资源浪费，而且此时处理的task越多，可能速度反而越慢。因此用coalesce减少partition数量，将RDD中的数据压缩到更少的partition之后，只要使用更少的task即可处理完所有的partition。在某些场景下，对于性能的提升会有一定的帮助。</p>
<ul>
<li>使用repartitionAndSortWithinPartitions替代repartition与sort类操作</li>
</ul>
<p>repartitionAndSortWithinPartitions是Spark官网推荐的一个算子，官方建议，如果需要在repartition重分区之后，还要进行排序，建议直接使用repartitionAndSortWithinPartitions算子。因为该算子可以一边进行重分区的shuffle操作，一边进行排序。shuffle与sort两个操作同时进行，比先shuffle再sort来说，性能可能是要高的。</p>
<h3 id="广播大变量">广播大变量</h3>
<p>有时在开发过程中，会遇到需要在算子函数中使用外部变量的场景（尤其是大变量，比如100M以上的大集合），那么此时就应该使用Spark的广播（Broadcast）功能来提升性能。</p>
<p>在算子函数中使用到外部变量时，默认情况下，Spark会将该变量复制多个副本，通过网络传输到task中，此时每个task都有一个变量副本。如果变量本身比较大的话（比如100M，甚至1G），那么大量的变量副本在网络中传输的性能开销，以及在各个节点的Executor中占用过多内存导致的频繁GC，都会极大地影响性能。</p>
<p>因此对于上述情况，如果使用的外部变量比较大，建议使用Spark的广播功能，对该变量进行广播。广播后的变量，会保证每个Executor的内存中，只驻留一份变量副本，而Executor中的task执行时共享该Executor中的那份变量副本。这样的话，可以大大减少变量副本的数量，从而减少网络传输的性能开销，并减少对Executor内存的占用开销，降低GC的频率。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 以下代码在算子函数中，使用了外部的变量。
</span><span style="color:#75715e">// 此时没有做任何特殊操作，每个task都会有一份list1的副本。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> list1 <span style="color:#66d9ef">=</span> <span style="color:#f92672">...</span>
rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>list1<span style="color:#f92672">...)</span>

<span style="color:#75715e">// 以下代码将list1封装成了Broadcast类型的广播变量。
</span><span style="color:#75715e">// 在算子函数中，使用广播变量时，首先会判断当前task所在Executor内存中，是否有变量副本。
</span><span style="color:#75715e">// 如果有则直接使用；如果没有则从Driver或者其他Executor节点上远程拉取一份放到本地Executor内存中。
</span><span style="color:#75715e">// 每个Executor内存中，就只会驻留一份广播变量副本。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> list1 <span style="color:#66d9ef">=</span> <span style="color:#f92672">...</span>
<span style="color:#66d9ef">val</span> list1Broadcast <span style="color:#66d9ef">=</span> sc<span style="color:#f92672">.</span>broadcast<span style="color:#f92672">(</span>list1<span style="color:#f92672">)</span>
rdd1<span style="color:#f92672">.</span>map<span style="color:#f92672">(</span>list1Broadcast<span style="color:#f92672">...)</span>
</code></pre></div><h3 id="使用kyro优化序列化性能">使用kyro优化序列化性能</h3>
<p>在Spark中，主要有三个地方涉及到了序列化：</p>
<ul>
<li>在算子函数中使用到外部变量时，该变量会被序列化后进行网络传输</li>
<li>将自定义的类型作为RDD的泛型类型时（比如JavaRDD，Student是自定义类型），所有自定义类型对象，都会进行序列化。因此这种情况下，也要求自定义的类必须实现Serializable接口。</li>
<li>使用可序列化的持久化策略时（比如MEMORY_ONLY_SER），Spark会将RDD中的每个partition都序列化成一个大的字节数组。</li>
</ul>
<p>对于这三种出现的序列化，都可以通过使用Kryo序列化类库来优化序列化和反序列化的性能。Spark默认使用的是Java的序列化机制，也就是ObjectOutputStream / ObjectInputStream API来进行序列化和反序列化</p>
<p>但是Spark同时支持使用Kryo序列化库，Kryo序列化类库的性能比Java序列化类库的性能要高很多。官方介绍，Kryo序列化机制比Java序列化机制，性能高10倍左右。Spark之所以默认没有使用Kryo作为序列化类库，是因为Kryo要求最好要注册所有需要进行序列化的自定义类型，因此对于开发者来说，这种方式比较麻烦</p>
<p>以下是使用Kryo的代码示例，我们只要设置序列化类，再注册要序列化的自定义类型即可（比如算子函数中使用到的外部变量类型、作为RDD泛型类型的自定义类型等）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-scala" data-lang="scala"><span style="color:#75715e">// 创建SparkConf对象。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> conf <span style="color:#66d9ef">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SparkConf</span><span style="color:#f92672">().</span>setMaster<span style="color:#f92672">(...).</span>setAppName<span style="color:#f92672">(...)</span>
<span style="color:#75715e">// 设置序列化器为KryoSerializer。
</span><span style="color:#75715e"></span>conf<span style="color:#f92672">.</span>set<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;spark.serializer&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;org.apache.spark.serializer.KryoSerializer&#34;</span><span style="color:#f92672">)</span>
<span style="color:#75715e">// 注册要序列化的自定义类型。
</span><span style="color:#75715e"></span>conf<span style="color:#f92672">.</span>registerKryoClasses<span style="color:#f92672">(</span><span style="color:#a6e22e">Array</span><span style="color:#f92672">(</span>classOf<span style="color:#f92672">[</span><span style="color:#66d9ef">MyClass1</span><span style="color:#f92672">],</span> classOf<span style="color:#f92672">[</span><span style="color:#66d9ef">MyClass2</span><span style="color:#f92672">]))</span>
</code></pre></div><h3 id="优化数据结构">优化数据结构</h3>
<p>Java中，有三种类型比较耗费内存：</p>
<ul>
<li>对象，每个Java对象都有对象头、引用等额外的信息，因此比较占用内存空间。</li>
<li>字符串，每个字符串内部都有一个字符数组以及长度等额外信息。</li>
<li>集合类型，比如HashMap、LinkedList等，因为集合类型内部通常会使用一些内部类来封装集合元素，比如Map.Entry</li>
</ul>
<p>因此Spark官方建议，在Spark编码实现中，特别是对于算子函数中的代码，尽量不要使用上述三种数据结构，尽量使用字符串替代对象，使用原始类型（比如Int、Long）替代字符串，使用数组替代集合类型，这样尽可能地减少内存占用，从而降低GC频率，提升性能。</p>
<p>但是在实践中发现，要做到该原则其实并不容易。因为我们同时要考虑到代码的可维护性，如果一个代码中，完全没有任何对象抽象，全部是字符串拼接的方式，那么对于后续的代码维护和修改，无疑是一场巨大的灾难。同理，如果所有操作都基于数组实现，而不使用HashMap、LinkedList等集合类型，那么对于我们的编码难度以及代码可维护性，也是一个极大的挑战。因此笔者建议，在可能以及合适的情况下，使用占用内存较少的数据结构，但是前提是要保证代码的可维护性。</p>
<h3 id="运行原理">运行原理</h3>
<p><img src="/1f1ddad5.png" alt="1f1ddad5.png"></p>
<ol>
<li>我们使用spark-submit提交一个Spark作业之后，这个作业就会启动一个对应的Driver进程。</li>
<li>根据你使用的部署模式（deploy-mode）不同，Driver进程可能在本地启动，也可能在集群中某个工作节点上启动。Driver进程本身会根据我们设置的参数，占有一定数量的内存和CPU core。</li>
<li>而Driver进程要做的第一件事情，就是向集群管理器申请运行Spark作业需要使用的资源，这里的资源指的就是Executor进程。</li>
<li>YARN集群管理器会根据我们为Spark作业设置的资源参数，在各个工作节点上，启动一定数量的Executor进程，每个Executor进程都占有一定数量的内存和CPU core。</li>
<li>在申请到了作业执行所需的资源之后，Driver进程就会开始调度和执行我们编写的作业代码了。Driver进程会将我们编写的Spark作业代码分拆为多个stage，每个stage执行一部分代码片段，并为每个stage创建一批task，然后将这些task分配到各个Executor进程中执行。task是最小的计算单元，负责执行一模一样的计算逻辑（也就是我们自己编写的某个代码片段），只是每个task处理的数据不同而已。</li>
<li>一个stage的所有task都执行完毕之后，会在各个节点本地的磁盘文件中写入计算中间结果，然后Driver就会调度运行下一个stage。下一个stage的task的输入数据就是上一个stage输出的中间结果。如此循环往复，直到将我们自己编写的代码逻辑全部执行完，并且计算完所有的数据，得到我们想要的结果为止。</li>
</ol>
<p>Spark是根据shuffle类算子来进行stage的划分。如果我们的代码中执行了某个shuffle类算子（比如reduceByKey、join等），那么就会在该算子处，划分出一个stage界限来。可以大致理解为，shuffle算子执行之前的代码会被划分为一个stage，shuffle算子执行以及之后的代码会被划分为下一个stage。因此一个stage刚开始执行的时候，它的每个task可能都会从上一个stage的task所在的节点，去通过网络传输拉取需要自己处理的所有key，然后对拉取到的所有相同的key使用我们自己编写的算子函数执行聚合操作（比如reduceByKey()算子接收的函数）。这个过程就是shuffle。</p>
<p>当我们在代码中执行了cache/persist等持久化操作时，根据我们选择的持久化级别的不同，每个task计算出来的数据也会保存到Executor进程的内存或者所在节点的磁盘文件中。</p>
<p>因此Executor的内存主要分为三块：第一块是让task执行我们自己编写的代码时使用，默认是占Executor总内存的20%；第二块是让task通过shuffle过程拉取了上一个stage的task的输出后，进行聚合等操作时使用，默认也是占Executor总内存的20%；第三块是让RDD持久化时使用，默认占Executor总内存的60%。</p>
<p>task的执行速度是跟每个Executor进程的CPU core数量有直接关系的。一个CPU core同一时间只能执行一个线程。而每个Executor进程上分配到的多个task，都是以每个task一条线程的方式，多线程并发运行的。如果CPU core数量比较充足，而且分配到的task数量比较合理，那么通常来说，可以比较快速和高效地执行完这些task线程。</p>
<p>以上就是Spark作业的基本运行原理的说明，大家可以结合上图来理解。理解作业基本原理，是我们进行资源参数调优的基本前提。</p>
<h3 id="参数调优">参数调优</h3>
<ul>
<li>
<p>num-executors</p>
<ul>
<li>参数说明：该参数用于设置Spark作业总共要用多少个Executor进程来执行。Driver在向YARN集群管理器申请资源时，YARN集群管理器会尽可能按照你的设置来在集群的各个工作节点上，启动相应数量的Executor进程。这个参数非常之重要，如果不设置的话，默认只会给你启动少量的Executor进程，此时你的Spark作业的运行速度是非常慢的。</li>
<li>参数调优建议：每个Spark作业的运行一般设置50~100个左右的Executor进程比较合适，设置太少或太多的Executor进程都不好。设置的太少，无法充分利用集群资源；设置的太多的话，大部分队列可能无法给予充分的资源</li>
</ul>
</li>
<li>
<p>executor-memory</p>
<ul>
<li>参数说明：该参数用于设置每个Executor进程的内存。Executor内存的大小，很多时候直接决定了Spark作业的性能，而且跟常见的JVM OOM异常，也有直接的关联。</li>
<li>参数调优建议：每个Executor进程的内存设置4G~8G较为合适。但是这只是一个参考值，具体的设置还是得根据不同部门的资源队列来定。可以看看自己团队的资源队列的最大内存限制是多少，num-executors乘以executor-memory，是不能超过队列的最大内存量的。此外，如果你是跟团队里其他人共享这个资源队列，那么申请的内存量最好不要超过资源队列最大总内存的1/3~1/2，避免你自己的Spark作业占用了队列所有的资源，导致别的同学的作业无法运行。</li>
</ul>
</li>
<li>
<p>executor-cores</p>
<ul>
<li>参数说明：该参数用于设置每个Executor进程的CPU core数量。这个参数决定了每个Executor进程并行执行task线程的能力。因为每个CPU core同一时间只能执行一个task线程，因此每个Executor进程的CPU core数量越多，越能够快速地执行完分配给自己的所有task线程。</li>
<li>参数调优建议：Executor的CPU core数量设置为2~4个较为合适。同样得根据不同部门的资源队列来定，可以看看自己的资源队列的最大CPU core限制是多少，再依据设置的Executor数量，来决定每个Executor进程可以分配到几个CPU core。同样建议，如果是跟他人共享这个队列，那么num-executors * executor-cores不要超过队列总CPU core的1/3~1/2左右比较合适，也是避免影响其他同学的作业运行。</li>
</ul>
</li>
<li>
<p>driver-memory</p>
<ul>
<li>参数说明：该参数用于设置Driver进程的内存。</li>
<li>参数调优建议：Driver的内存通常来说不设置，或者设置1G左右应该就够了。唯一需要注意的一点是，如果需要使用collect算子将RDD的数据全部拉取到Driver上进行处理，那么必须确保Driver的内存足够大，否则会出现OOM内存溢出的问题。</li>
</ul>
</li>
<li>
<p>spark.default.parallelism</p>
<ul>
<li>参数说明：该参数用于设置每个stage的默认task数量。这个参数极为重要，如果不设置可能会直接影响你的Spark作业性能。</li>
<li>参数调优建议：Spark作业的默认task数量为500~1000个较为合适。很多同学常犯的一个错误就是不去设置这个参数，那么此时就会导致Spark自己根据底层HDFS的block数量来设置task的数量，默认是一个HDFS block对应一个task。通常来说，Spark默认设置的数量是偏少的（比如就几十个task），如果task数量偏少的话，就会导致你前面设置好的Executor的参数都前功尽弃。试想一下，无论你的Executor进程有多少个，内存和CPU有多大，但是task只有1个或者10个，那么90%的Executor进程可能根本就没有task执行，也就是白白浪费了资源！因此Spark官网建议的设置原则是，设置该参数为num-executors * executor-cores的2~3倍较为合适，比如Executor的总CPU core数量为300个，那么设置1000个task是可以的，此时可以充分地利用Spark集群的资源。</li>
</ul>
</li>
<li>
<p>spark.storage.memoryFraction</p>
<ul>
<li>参数说明：该参数用于设置RDD持久化数据在Executor内存中能占的比例，默认是0.6。也就是说，默认Executor 60%的内存，可以用来保存持久化的RDD数据。根据你选择的不同的持久化策略，如果内存不够时，可能数据就不会持久化，或者数据会写入磁盘。</li>
<li>参数调优建议：如果Spark作业中，有较多的RDD持久化操作，该参数的值可以适当提高一些，保证持久化的数据能够容纳在内存中。避免内存不够缓存所有的数据，导致数据只能写入磁盘中，降低了性能。但是如果Spark作业中的shuffle类操作比较多，而持久化操作比较少，那么这个参数的值适当降低一些比较合适。此外，如果发现作业由于频繁的gc导致运行缓慢（通过spark web ui可以观察到作业的gc耗时），意味着task执行用户代码的内存不够用，那么同样建议调低这个参数的值。</li>
</ul>
</li>
<li>
<p>spark.shuffle.memoryFraction</p>
<ul>
<li>参数说明：该参数用于设置shuffle过程中一个task拉取到上个stage的task的输出后，进行聚合操作时能够使用的Executor内存的比例，默认是0.2。也就是说，Executor默认只有20%的内存用来进行该操作。shuffle操作在进行聚合时，如果发现使用的内存超出了这个20%的限制，那么多余的数据就会溢写到磁盘文件中去，此时就会极大地降低性能。</li>
<li>参数调优建议：如果Spark作业中的RDD持久化操作较少，shuffle操作较多时，建议降低持久化操作的内存占比，提高shuffle操作的内存占比比例，避免shuffle过程中数据过多时内存不够用，必须溢写到磁盘上，降低了性能。此外，如果发现作业由于频繁的gc导致运行缓慢，意味着task执行用户代码的内存不够用，那么同样建议调低这个参数的值。</li>
</ul>
</li>
</ul>
<p>资源参数的调优，没有一个固定的值，需要同学们根据自己的实际情况（包括Spark作业中的shuffle操作数量、RDD持久化操作数量以及spark web ui中显示的作业gc情况），同时参考本篇文章中给出的原理以及调优建议，合理地设置上述参数。</p>
<p>以下是一份spark-submit命令的示例，大家可以参考一下，并根据自己的实际情况进行调节：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./bin/spark-submit <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --master yarn-cluster <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --num-executors <span style="color:#ae81ff">100</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --executor-memory 6G <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --executor-cores <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --driver-memory 1G <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --conf spark.default.parallelism<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --conf spark.storage.memoryFraction<span style="color:#f92672">=</span>0.5 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  --conf spark.shuffle.memoryFraction<span style="color:#f92672">=</span>0.3 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>  
  
  --conf spark.dynamicAllocation.enabled<span style="color:#f92672">=</span> true //开启动态资源分配
  --conf spark.dynamicAllocation.minExecutors<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> //每个Application最小分配的executor数
  --conf spark.dynamicAllocation.maxExecutors<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span> //每个Application最大并发分配的executor数
</code></pre></div><p>如果开启了动态资源分配，那么需要去掉 &ndash;num-executors 的参数，否则动态资源分配不会有效果</p>
]]></content>
        </item>
        
        <item>
            <title>maven plugins</title>
            <link>http://keltoy.github.io/posts/maven-plugins/</link>
            <pubDate>Wed, 15 Apr 2020 22:10:16 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/maven-plugins/</guid>
            <description>maven plugins [toc]
manven-enforcer-plugin 功能 在项目validate的过程时，对项目环境进行检查
原理 enforcer 配置之后会默认在validate 后执行enforcer:enforce，对项目环境进行检查
使用 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-enforcer-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.1&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;!-- 执行实例的id --&amp;gt; &amp;lt;id&amp;gt;default-cli&amp;lt;/id&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;!-- 执行的命令 --&amp;gt; &amp;lt;goal&amp;gt;enforce&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;!-- 执行的阶段 --&amp;gt; &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;!-- 制定的规则 --&amp;gt; &amp;lt;rules&amp;gt; &amp;lt;!-- 制定jdk版本 --&amp;gt; &amp;lt;requireJavaVersion&amp;gt; &amp;lt;!-- 执行失败后的消息提示 --&amp;gt; &amp;lt;message&amp;gt; &amp;lt;![CDATA[You are running an older version of Java. This application requires at least JDK ${java.version}.]]&amp;gt; &amp;lt;/message&amp;gt; &amp;lt;!-- jdk版本规则 --&amp;gt; &amp;lt;version&amp;gt;[${java.version}.0,)&amp;lt;/version&amp;gt; &amp;lt;/requireJavaVersion&amp;gt; &amp;lt;/rules&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.</description>
            <content type="html"><![CDATA[<h1 id="maven-plugins">maven plugins</h1>
<p>[toc]</p>
<h2 id="manven-enforcer-plugin">manven-enforcer-plugin</h2>
<h3 id="功能">功能</h3>
<p>在项目validate的过程时，对项目环境进行检查</p>
<h3 id="原理">原理</h3>
<p>enforcer 配置之后会默认在validate 后执行enforcer:enforce，对项目环境进行检查</p>
<h3 id="使用">使用</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;build&gt;</span>
<span style="color:#f92672">&lt;plugins&gt;</span>
  <span style="color:#f92672">&lt;plugin&gt;</span>
    <span style="color:#f92672">&lt;artifactId&gt;</span>maven-enforcer-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
    <span style="color:#f92672">&lt;version&gt;</span>1.4.1<span style="color:#f92672">&lt;/version&gt;</span>
    <span style="color:#f92672">&lt;executions&gt;</span>
      <span style="color:#f92672">&lt;execution&gt;</span>
        <span style="color:#75715e">&lt;!-- 执行实例的id --&gt;</span>
        <span style="color:#f92672">&lt;id&gt;</span>default-cli<span style="color:#f92672">&lt;/id&gt;</span>
        <span style="color:#f92672">&lt;goals&gt;</span>
        <span style="color:#75715e">&lt;!-- 执行的命令 --&gt;</span>
          <span style="color:#f92672">&lt;goal&gt;</span>enforce<span style="color:#f92672">&lt;/goal&gt;</span>
        <span style="color:#f92672">&lt;/goals&gt;</span>
        <span style="color:#75715e">&lt;!-- 执行的阶段 --&gt;</span>
        <span style="color:#f92672">&lt;phase&gt;</span>validate<span style="color:#f92672">&lt;/phase&gt;</span>
        <span style="color:#f92672">&lt;configuration&gt;</span>
          <span style="color:#75715e">&lt;!-- 制定的规则 --&gt;</span>
          <span style="color:#f92672">&lt;rules&gt;</span>
            <span style="color:#75715e">&lt;!-- 制定jdk版本 --&gt;</span>
            <span style="color:#f92672">&lt;requireJavaVersion&gt;</span>
              <span style="color:#75715e">&lt;!-- 执行失败后的消息提示 --&gt;</span>
              <span style="color:#f92672">&lt;message&gt;</span>
                <span style="color:#75715e">&lt;![CDATA[You are running an older version of Java. This application requires at least JDK ${java.version}.]]&gt;</span>
              <span style="color:#f92672">&lt;/message&gt;</span>
              <span style="color:#75715e">&lt;!-- jdk版本规则 --&gt;</span>
              <span style="color:#f92672">&lt;version&gt;</span>[${java.version}.0,)<span style="color:#f92672">&lt;/version&gt;</span>
            <span style="color:#f92672">&lt;/requireJavaVersion&gt;</span>
          <span style="color:#f92672">&lt;/rules&gt;</span>
        <span style="color:#f92672">&lt;/configuration&gt;</span>
      <span style="color:#f92672">&lt;/execution&gt;</span>
    <span style="color:#f92672">&lt;/executions&gt;</span>
  <span style="color:#f92672">&lt;/plugin&gt;</span>
<span style="color:#f92672">&lt;/plugins&gt;</span>
<span style="color:#f92672">&lt;/build&gt;</span>
<span style="color:#f92672">&lt;properties&gt;</span>
<span style="color:#f92672">&lt;java.version&gt;</span>1.8<span style="color:#f92672">&lt;/java.version&gt;</span>
<span style="color:#f92672">&lt;/properties&gt;</span>

</code></pre></div><p>还有很多检测可以去官网看看内置的规则</p>
<p><a href="http://maven.apache.org/enforcer/enforcer-rules/index.html">Apache Maven Enforcer Built-In Rules – Built-In Rules</a></p>
<h2 id="maven-checkstyle-plugin">maven-checkstyle-plugin</h2>
<h3 id="功能-1">功能</h3>
<p>提交代码之前做一些代码检查</p>
<h3 id="说明">说明</h3>
<ul>
<li>
<p><a href="https://checkstyle.sourceforge.io/sun_style.html">checkstyle – Sun&rsquo;s Java Style</a></p>
</li>
<li>
<p><a href="https://checkstyle.sourceforge.io/google_style.html">checkstyle - Goole Style</a></p>
</li>
</ul>
<h3 id="实现">实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;reporting&gt;</span>
  <span style="color:#f92672">&lt;plugins&gt;</span>
    <span style="color:#f92672">&lt;plugin&gt;</span>
      <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.maven.plugins<span style="color:#f92672">&lt;/groupId&gt;</span>
      <span style="color:#f92672">&lt;artifactId&gt;</span>maven-checkstyle-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
      <span style="color:#f92672">&lt;version&gt;</span>${maven.checkstyle.version}<span style="color:#f92672">&lt;/version&gt;</span>
      <span style="color:#f92672">&lt;configuration&gt;</span>
        <span style="color:#f92672">&lt;configLocation&gt;</span>google_checks.xml<span style="color:#f92672">&lt;/configLocation&gt;</span>
      <span style="color:#f92672">&lt;/configuration&gt;</span>
    <span style="color:#f92672">&lt;/plugin&gt;</span>
  <span style="color:#f92672">&lt;/plugins&gt;</span>
<span style="color:#f92672">&lt;/reporting&gt;</span>
</code></pre></div><h2 id="maven-shade-plugin">maven-shade-plugin</h2>
<h3 id="功能-2">功能</h3>
<ol>
<li>将依赖的jar包打包到当前jar包</li>
<li>对依赖的jar包进行重命名</li>
</ol>
<h3 id="说明-1">说明</h3>
<p>在打包命令后，执行了</p>
<h3 id="实现-1">实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"> <span style="color:#f92672">&lt;build&gt;</span>
    <span style="color:#f92672">&lt;plugins&gt;</span>
      <span style="color:#f92672">&lt;plugin&gt;</span>
        <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.maven.plugins<span style="color:#f92672">&lt;/groupId&gt;</span>
        <span style="color:#f92672">&lt;artifactId&gt;</span>maven-shade-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
        <span style="color:#f92672">&lt;version&gt;</span>3.1.1<span style="color:#f92672">&lt;/version&gt;</span>
        <span style="color:#f92672">&lt;executions&gt;</span>
          <span style="color:#f92672">&lt;execution&gt;</span>
            <span style="color:#f92672">&lt;phase&gt;</span>package<span style="color:#f92672">&lt;/phase&gt;</span>
            <span style="color:#f92672">&lt;goals&gt;</span>
              <span style="color:#f92672">&lt;goal&gt;</span>shade<span style="color:#f92672">&lt;/goal&gt;</span>
            <span style="color:#f92672">&lt;/goals&gt;</span>
            <span style="color:#f92672">&lt;configuration&gt;</span>
              <span style="color:#f92672">&lt;artifactSet&gt;</span>
                <span style="color:#f92672">&lt;excludes&gt;</span>
                  <span style="color:#f92672">&lt;exclude&gt;</span>jmock:*<span style="color:#f92672">&lt;/exclude&gt;</span>
                  <span style="color:#f92672">&lt;exclude&gt;</span>*:xml-apis<span style="color:#f92672">&lt;/exclude&gt;</span>
                  <span style="color:#f92672">&lt;exclude&gt;</span>org.apache.maven:lib:tests<span style="color:#f92672">&lt;/exclude&gt;</span>
                  <span style="color:#f92672">&lt;exclude&gt;</span>log4j:log4j:jar:<span style="color:#f92672">&lt;/exclude&gt;</span>
                <span style="color:#f92672">&lt;/excludes&gt;</span>
                <span style="color:#f92672">&lt;includes&gt;</span>
                    <span style="color:#f92672">&lt;include&gt;</span>junit:junit<span style="color:#f92672">&lt;/include&gt;</span>
                <span style="color:#f92672">&lt;/includes&gt;</span>
              <span style="color:#f92672">&lt;/artifactSet&gt;</span>
            <span style="color:#f92672">&lt;/configuration&gt;</span>
          <span style="color:#f92672">&lt;/execution&gt;</span>
        <span style="color:#f92672">&lt;/executions&gt;</span>
      <span style="color:#f92672">&lt;/plugin&gt;</span>
    <span style="color:#f92672">&lt;/plugins&gt;</span>
  <span style="color:#f92672">&lt;/build&gt;</span>

  <span style="color:#f92672">&lt;build&gt;</span>
    <span style="color:#f92672">&lt;plugins&gt;</span>
      <span style="color:#f92672">&lt;plugin&gt;</span>
        <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.maven.plugins<span style="color:#f92672">&lt;/groupId&gt;</span>
        <span style="color:#f92672">&lt;artifactId&gt;</span>maven-shade-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
        <span style="color:#f92672">&lt;version&gt;</span>3.1.1<span style="color:#f92672">&lt;/version&gt;</span>
        <span style="color:#f92672">&lt;executions&gt;</span>
          <span style="color:#f92672">&lt;execution&gt;</span>
            <span style="color:#f92672">&lt;phase&gt;</span>package<span style="color:#f92672">&lt;/phase&gt;</span>
            <span style="color:#f92672">&lt;goals&gt;</span>
              <span style="color:#f92672">&lt;goal&gt;</span>shade<span style="color:#f92672">&lt;/goal&gt;</span>
            <span style="color:#f92672">&lt;/goals&gt;</span>
            <span style="color:#f92672">&lt;configuration&gt;</span>
              <span style="color:#f92672">&lt;filters&gt;</span>
                <span style="color:#f92672">&lt;filter&gt;</span>
                  <span style="color:#f92672">&lt;artifact&gt;</span>junit:junit<span style="color:#f92672">&lt;/artifact&gt;</span>
                  <span style="color:#f92672">&lt;includes&gt;</span>
                    <span style="color:#f92672">&lt;include&gt;</span>junit/framework/**<span style="color:#f92672">&lt;/include&gt;</span>
                    <span style="color:#f92672">&lt;include&gt;</span>org/junit/**<span style="color:#f92672">&lt;/include&gt;</span>
                  <span style="color:#f92672">&lt;/includes&gt;</span>
                  <span style="color:#f92672">&lt;excludes&gt;</span>
                    <span style="color:#f92672">&lt;exclude&gt;</span>org/junit/experimental/**<span style="color:#f92672">&lt;/exclude&gt;</span>
                    <span style="color:#f92672">&lt;exclude&gt;</span>org/junit/runners/**<span style="color:#f92672">&lt;/exclude&gt;</span>
                  <span style="color:#f92672">&lt;/excludes&gt;</span>
                <span style="color:#f92672">&lt;/filter&gt;</span>
                <span style="color:#f92672">&lt;filter&gt;</span>
                  <span style="color:#f92672">&lt;artifact&gt;</span>*:*<span style="color:#f92672">&lt;/artifact&gt;</span>
                  <span style="color:#f92672">&lt;excludes&gt;</span>
                    <span style="color:#f92672">&lt;exclude&gt;</span>META-INF/*.SF<span style="color:#f92672">&lt;/exclude&gt;</span>
                    <span style="color:#f92672">&lt;exclude&gt;</span>META-INF/*.DSA<span style="color:#f92672">&lt;/exclude&gt;</span>
                    <span style="color:#f92672">&lt;exclude&gt;</span>META-INF/*.RSA<span style="color:#f92672">&lt;/exclude&gt;</span>
                  <span style="color:#f92672">&lt;/excludes&gt;</span>
                <span style="color:#f92672">&lt;/filter&gt;</span>
              <span style="color:#f92672">&lt;/filters&gt;</span>
            <span style="color:#f92672">&lt;/configuration&gt;</span>
          <span style="color:#f92672">&lt;/execution&gt;</span>
        <span style="color:#f92672">&lt;/executions&gt;</span>
      <span style="color:#f92672">&lt;/plugin&gt;</span>
    <span style="color:#f92672">&lt;/plugins&gt;</span>
  <span style="color:#f92672">&lt;/build&gt;</span>
</code></pre></div><h2 id="build-helper-maven-plugin">build-helper-maven-plugin</h2>
<h3 id="功能-3">功能</h3>
<p>添加多个源码目录</p>
<h3 id="实现-2">实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;plugin&gt;</span>
  <span style="color:#f92672">&lt;groupId&gt;</span>org.codehaus.mojo<span style="color:#f92672">&lt;/groupId&gt;</span>
  <span style="color:#f92672">&lt;artifactId&gt;</span>build-helper-maven-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
  <span style="color:#f92672">&lt;executions&gt;</span>
    <span style="color:#75715e">&lt;!-- Add src/main/scala to eclipse build path --&gt;</span>
    <span style="color:#f92672">&lt;execution&gt;</span>
      <span style="color:#f92672">&lt;id&gt;</span>add-source<span style="color:#f92672">&lt;/id&gt;</span>
      <span style="color:#f92672">&lt;phase&gt;</span>generate-sources<span style="color:#f92672">&lt;/phase&gt;</span>
      <span style="color:#f92672">&lt;goals&gt;</span>
        <span style="color:#f92672">&lt;goal&gt;</span>add-source<span style="color:#f92672">&lt;/goal&gt;</span>
      <span style="color:#f92672">&lt;/goals&gt;</span>
      <span style="color:#f92672">&lt;configuration&gt;</span>
        <span style="color:#f92672">&lt;sources&gt;</span>
          <span style="color:#f92672">&lt;source&gt;</span>src/main/scala<span style="color:#f92672">&lt;/source&gt;</span>
        <span style="color:#f92672">&lt;/sources&gt;</span>
      <span style="color:#f92672">&lt;/configuration&gt;</span>
    <span style="color:#f92672">&lt;/execution&gt;</span>
    <span style="color:#75715e">&lt;!-- Add src/test/scala to eclipse build path --&gt;</span>
    <span style="color:#f92672">&lt;execution&gt;</span>
      <span style="color:#f92672">&lt;id&gt;</span>add-test-source<span style="color:#f92672">&lt;/id&gt;</span>
      <span style="color:#f92672">&lt;phase&gt;</span>generate-test-sources<span style="color:#f92672">&lt;/phase&gt;</span>
      <span style="color:#f92672">&lt;goals&gt;</span>
        <span style="color:#f92672">&lt;goal&gt;</span>add-test-source<span style="color:#f92672">&lt;/goal&gt;</span>
      <span style="color:#f92672">&lt;/goals&gt;</span>
      <span style="color:#f92672">&lt;configuration&gt;</span>
        <span style="color:#f92672">&lt;sources&gt;</span>
          <span style="color:#f92672">&lt;source&gt;</span>src/test/scala<span style="color:#f92672">&lt;/source&gt;</span>
        <span style="color:#f92672">&lt;/sources&gt;</span>
      <span style="color:#f92672">&lt;/configuration&gt;</span>
    <span style="color:#f92672">&lt;/execution&gt;</span>
  <span style="color:#f92672">&lt;/executions&gt;</span>
<span style="color:#f92672">&lt;/plugin&gt;</span>
</code></pre></div><h2 id="scalastyle-maven-plugin">scalastyle-maven-plugin</h2>
<h3 id="功能-4">功能</h3>
<p>类似checkstyle，只不过是用在 scala 上的</p>
<h3 id="官网">官网</h3>
<p><a href="https://github.com/scalastyle/scalastyle-maven-plugin">GitHub - scalastyle/scalastyle-maven-plugin: Maven plugin for Scalastyle</a></p>
<h2 id="maven-jar-plugin">maven-jar-plugin</h2>
<h3 id="功能-5">功能</h3>
<p>就是打包执行</p>
<h3 id="样例">样例</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;plugin&gt;</span>
  <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.maven.plugins<span style="color:#f92672">&lt;/groupId&gt;</span>
  <span style="color:#f92672">&lt;artifactId&gt;</span>maven-jar-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
  <span style="color:#f92672">&lt;version&gt;</span>3.3.0<span style="color:#f92672">&lt;/version&gt;</span>
  <span style="color:#f92672">&lt;configuration&gt;</span>
      <span style="color:#f92672">&lt;archive&gt;</span>                           <span style="color:#75715e">&lt;!-- 存档 --&gt;</span>
        <span style="color:#f92672">&lt;addMavenDescriptor/&gt;</span>                 <span style="color:#75715e">&lt;!-- 添加maven 描述 --&gt;</span>
        <span style="color:#f92672">&lt;compress/&gt;</span>                           <span style="color:#75715e">&lt;!-- 压缩 --&gt;</span>
        <span style="color:#f92672">&lt;forced/&gt;</span>
        <span style="color:#f92672">&lt;index/&gt;</span>
        <span style="color:#f92672">&lt;manifest&gt;</span>                            <span style="color:#75715e">&lt;!-- 配置清单（MANIFEST）--&gt;</span>
          <span style="color:#f92672">&lt;addClasspath/&gt;</span>                         <span style="color:#75715e">&lt;!-- 添加到classpath 开关 --&gt;</span>
          <span style="color:#f92672">&lt;addDefaultImplementationEntries/&gt;</span>
          <span style="color:#f92672">&lt;addDefaultSpecificationEntries/&gt;</span>
          <span style="color:#f92672">&lt;addExtensions/&gt;</span>
          <span style="color:#f92672">&lt;classpathLayoutType/&gt;</span>
          <span style="color:#f92672">&lt;classpathMavenRepositoryLayout/&gt;</span>
          <span style="color:#f92672">&lt;classpathPrefix/&gt;</span>                      <span style="color:#75715e">&lt;!-- classpath 前缀 --&gt;</span>
          <span style="color:#f92672">&lt;customClasspathLayout/&gt;</span>
          <span style="color:#f92672">&lt;mainClass/&gt;</span>                            <span style="color:#75715e">&lt;!-- 程序主函数入口 --&gt;</span>
          <span style="color:#f92672">&lt;packageName/&gt;</span>                          <span style="color:#75715e">&lt;!-- 打包名称 --&gt;</span>
          <span style="color:#f92672">&lt;useUniqueVersions/&gt;</span>                    <span style="color:#75715e">&lt;!-- 使用唯一版本 --&gt;</span>
        <span style="color:#f92672">&lt;/manifest&gt;</span>
        <span style="color:#f92672">&lt;manifestEntries&gt;</span>                     <span style="color:#75715e">&lt;!-- 配置清单（MANIFEST）属性 --&gt;</span>
          <span style="color:#f92672">&lt;key&gt;</span>value<span style="color:#f92672">&lt;/key&gt;</span>
        <span style="color:#f92672">&lt;/manifestEntries&gt;</span>
        <span style="color:#f92672">&lt;manifestFile/&gt;</span>                       <span style="color:#75715e">&lt;!-- MANIFEST 文件位置 --&gt;</span>
        <span style="color:#f92672">&lt;manifestSections&gt;</span>
          <span style="color:#f92672">&lt;manifestSection&gt;</span>
            <span style="color:#f92672">&lt;name/&gt;</span>
            <span style="color:#f92672">&lt;manifestEntries&gt;</span>
              <span style="color:#f92672">&lt;key&gt;</span>value<span style="color:#f92672">&lt;/key&gt;</span>
            <span style="color:#f92672">&lt;/manifestEntries&gt;</span>
          <span style="color:#f92672">&lt;manifestSection/&gt;</span>
        <span style="color:#f92672">&lt;/manifestSections&gt;</span>
        <span style="color:#f92672">&lt;pomPropertiesFile/&gt;</span>
      <span style="color:#f92672">&lt;/archive&gt;</span>

      <span style="color:#f92672">&lt;excludes&gt;</span>                          <span style="color:#75715e">&lt;!-- 过滤掉不希望包含在jar中的文件  --&gt;</span>
          <span style="color:#f92672">&lt;exclude/&gt;</span>
      <span style="color:#f92672">&lt;/excludes&gt;</span>

      <span style="color:#f92672">&lt;includes&gt;</span>                          <span style="color:#75715e">&lt;!-- 添加文件到jar中的文件  --&gt;</span>
          <span style="color:#f92672">&lt;include/&gt;</span>
      <span style="color:#f92672">&lt;/includes&gt;</span>
  <span style="color:#f92672">&lt;/configuration&gt;</span>
<span style="color:#f92672">&lt;/plugin&gt;</span>
</code></pre></div><h2 id="maven-assembly-plugin">maven-assembly-plugin</h2>
<h3 id="功能-6">功能</h3>
<p>打包，原来可以有三种方式进行打包</p>
<h3 id="样例-1">样例</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;build&gt;</span>
        <span style="color:#f92672">&lt;plugins&gt;</span>
            <span style="color:#f92672">&lt;plugin&gt;</span>
                <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.maven.plugins<span style="color:#f92672">&lt;/groupId&gt;</span>
                <span style="color:#f92672">&lt;artifactId&gt;</span>maven-assembly-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
                <span style="color:#f92672">&lt;version&gt;</span>${maven-assembly-plugin.version}<span style="color:#f92672">&lt;version&gt;</span>
                <span style="color:#f92672">&lt;executions&gt;</span>
                    <span style="color:#f92672">&lt;execution&gt;</span>
                        <span style="color:#f92672">&lt;id&gt;</span>make-assembly<span style="color:#f92672">&lt;/id&gt;</span>
                        <span style="color:#75715e">&lt;!-- 绑定到package生命周期 --&gt;</span>
                        <span style="color:#f92672">&lt;phase&gt;</span>package<span style="color:#f92672">&lt;/phase&gt;</span>
                        <span style="color:#f92672">&lt;goals&gt;</span>
                            <span style="color:#75715e">&lt;!-- 只运行一次 --&gt;</span>
                            <span style="color:#f92672">&lt;goal&gt;</span>single<span style="color:#f92672">&lt;/goal&gt;</span>
                        <span style="color:#f92672">&lt;/goals&gt;</span>
                    <span style="color:#f92672">&lt;/execution&gt;</span>
                <span style="color:#f92672">&lt;/executions&gt;</span>
                <span style="color:#f92672">&lt;configuration&gt;</span>
                    <span style="color:#75715e">&lt;!-- 配置描述符文件 --&gt;</span>
                    <span style="color:#f92672">&lt;descriptor&gt;</span>src/main/assembly/assembly.xml<span style="color:#f92672">&lt;/descriptor&gt;</span>
                    <span style="color:#75715e">&lt;!-- 也可以使用Maven预配置的描述符
</span><span style="color:#75715e">                    &lt;descriptorRefs&gt;
</span><span style="color:#75715e">                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
</span><span style="color:#75715e">                    &lt;/descriptorRefs&gt; --&gt;</span>
                <span style="color:#f92672">&lt;/configuration&gt;</span>
            <span style="color:#f92672">&lt;/plugin&gt;</span>
        <span style="color:#f92672">&lt;/plugins&gt;</span>
    <span style="color:#f92672">&lt;/build&gt;</span>
</code></pre></div><h3 id="例子">例子</h3>
<p>assembly插件的打包方式是通过descriptor（描述符）来定义的。
Maven预先定义好的描述符有bin，src，project，jar-with-dependencies等。比较常用的是jar-with-dependencies，它是将所有外部依赖JAR都加入生成的JAR包中，比较傻瓜化。
但要真正达到自定义打包的效果，就需要自己写描述符文件，格式为XML。下面是我们的项目中常用的一种配置。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;build&gt;</span>
        <span style="color:#f92672">&lt;plugins&gt;</span>
            <span style="color:#f92672">&lt;plugin&gt;</span>
                <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.maven.plugins<span style="color:#f92672">&lt;/groupId&gt;</span>
                <span style="color:#f92672">&lt;artifactId&gt;</span>maven-assembly-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
                <span style="color:#f92672">&lt;version&gt;</span>${maven-assembly-plugin.version}<span style="color:#f92672">&lt;version&gt;</span>
                <span style="color:#f92672">&lt;executions&gt;</span>
                    <span style="color:#f92672">&lt;execution&gt;</span>
                        <span style="color:#f92672">&lt;id&gt;</span>make-assembly<span style="color:#f92672">&lt;/id&gt;</span>
                        <span style="color:#75715e">&lt;!-- 绑定到package生命周期 --&gt;</span>
                        <span style="color:#f92672">&lt;phase&gt;</span>package<span style="color:#f92672">&lt;/phase&gt;</span>
                        <span style="color:#f92672">&lt;goals&gt;</span>
                            <span style="color:#75715e">&lt;!-- 只运行一次 --&gt;</span>
                            <span style="color:#f92672">&lt;goal&gt;</span>single<span style="color:#f92672">&lt;/goal&gt;</span>
                        <span style="color:#f92672">&lt;/goals&gt;</span>
                    <span style="color:#f92672">&lt;/execution&gt;</span>
                <span style="color:#f92672">&lt;/executions&gt;</span>
                <span style="color:#f92672">&lt;configuration&gt;</span>
                    <span style="color:#75715e">&lt;!-- 配置描述符文件 --&gt;</span>
                    <span style="color:#f92672">&lt;descriptor&gt;</span>src/main/assembly/assembly.xml<span style="color:#f92672">&lt;/descriptor&gt;</span>
                    <span style="color:#75715e">&lt;!-- 也可以使用Maven预配置的描述符
</span><span style="color:#75715e">                    &lt;descriptorRefs&gt;
</span><span style="color:#75715e">                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
</span><span style="color:#75715e">                    &lt;/descriptorRefs&gt; --&gt;</span>
                <span style="color:#f92672">&lt;/configuration&gt;</span>
            <span style="color:#f92672">&lt;/plugin&gt;</span>
        <span style="color:#f92672">&lt;/plugins&gt;</span>
    <span style="color:#f92672">&lt;/build&gt;</span>
</code></pre></div><h3 id="说明-2">说明</h3>
<ol>
<li>
<p>id与formats
formats是assembly插件支持的打包文件格式，有zip、tar、tar.gz、tar.bz2、jar、war。可以同时定义多个format。
id则是添加到打包文件名的标识符，用来做后缀。
也就是说，如果按上面的配置，生成的文件就是artifactId−artifactId−{version}-assembly.tar.gz。</p>
</li>
<li>
<p>fileSets/fileSet
用来设置一组文件在打包时的属性。</p>
</li>
<li>
<p>directory：源目录的路径。</p>
</li>
<li>
<p>includes/excludes：设定包含或排除哪些文件，支持通配符。</p>
</li>
<li>
<p>fileMode：指定该目录下的文件属性，采用Unix八进制描述法，默认值是0644。</p>
</li>
<li>
<p>outputDirectory：生成目录的路径。</p>
</li>
<li>
<p>files/file
与fileSets大致相同，不过是指定单个文件，并且还可以通过destName属性来设置与源文件不同的名称。</p>
</li>
<li>
<p>dependencySets/dependencySet
用来设置工程依赖文件在打包时的属性。也与fileSets大致相同，不过还有两个特殊的配置：</p>
</li>
<li>
<p>unpack：布尔值，false表示将依赖以原来的JAR形式打包，true则表示将依赖解成*.class文件的目录结构打包。</p>
</li>
<li>
<p>scope：表示符合哪个作用范围的依赖会被打包进去。compile与provided都不用管，一般是写runtime。</p>
</li>
</ol>
<p>按照以上配置打包好后，将.tar.gz文件上传到服务器，解压之后就会得到bin、conf、lib等规范化的目录结构，十分方便。</p>
<h2 id="maven-compiler-plugin">maven-compiler-plugin</h2>
<h3 id="功能-7">功能</h3>
<p>编译，编译不是maven 版本的代码</p>
<h3 id="说明-3">说明</h3>
<p>命令mvn的运行需要依赖JDK，Compiler插件默认使用当前运行mvn命令的JDK去编译Java源代码</p>
<h3 id="实例">实例</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;plugin&gt;</span>
  <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.maven.plugins<span style="color:#f92672">&lt;/groupId&gt;</span>
  <span style="color:#f92672">&lt;artifactId&gt;</span>maven-compiler-plugin<span style="color:#f92672">&lt;/artifactId&gt;</span>
  <span style="color:#f92672">&lt;version&gt;</span>3.7.0<span style="color:#f92672">&lt;/version&gt;</span>
  <span style="color:#f92672">&lt;configuration&gt;</span>
    <span style="color:#f92672">&lt;source&gt;</span>1.8<span style="color:#f92672">&lt;/source&gt;</span>
    <span style="color:#f92672">&lt;target&gt;</span>1.8<span style="color:#f92672">&lt;/target&gt;</span>
    <span style="color:#f92672">&lt;fork&gt;</span>true<span style="color:#f92672">&lt;/fork&gt;</span>
    <span style="color:#f92672">&lt;verbose&gt;</span>true<span style="color:#f92672">&lt;/verbose&gt;</span>
    <span style="color:#f92672">&lt;encoding&gt;</span>UTF-8<span style="color:#f92672">&lt;/encoding&gt;</span>
  <span style="color:#f92672">&lt;/configuration&gt;</span>
<span style="color:#f92672">&lt;/plugin&gt;</span>

</code></pre></div><h2 id="打包小结">打包小结</h2>
<ul>
<li>maven-jar-plugin，默认的打包插件，用来打普通的project JAR包；</li>
<li>maven-shade-plugin，用来打可执行JAR包，也就是所谓的fat JAR包；</li>
<li>maven-assembly-plugin，支持自定义的打包结构，也可以定制依赖项等。</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>conda 命令</title>
            <link>http://keltoy.github.io/posts/conda-%E5%91%BD%E4%BB%A4/</link>
            <pubDate>Wed, 08 Apr 2020 13:43:00 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/conda-%E5%91%BD%E4%BB%A4/</guid>
            <description>前言 之前都是使用 pip 和 virtualenv 管理python 的包管理和环境管理，最近体验了一下 jupyterlab， 好多插件的使用都需要安装nodejs，virtualenv 只能管理python 的环境，于是就想到了conda 试试conda 的环境管理能不能，惊喜的发现可以，所以以后的使用应该都迁移到 conda上来了
conda简介 说明原文conda 文档
conda 是开源的跨操作系统的包管理系统和环境管理系统，可以管理多种语言，运行安装都比较简单
conda 包管理 # 添加一个渠道，获取软件包的渠道 常用的有 bioconda, conda-forge, genomedk conda config --add channel # 设置去掉url显示 conda config --set show_channel_urls yes # 渠道列表 conda config --get channels # 搜索包 conda search [-c channel] packagename # 安装包 conda install packagename=versionnumber # 包列表 conda list # 删除包 conda remove packagename conda 环境管理 # 环境列表 conda env --list # 环境信息 conda info --envs # 创建python3环境 conda create -n name python=3 # 激活环境 conda activate environmentname # 退出环境 conda deactivate # 删除环境 conda remove -n environmentname --all </description>
            <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>之前都是使用 pip 和 virtualenv 管理python 的包管理和环境管理，最近体验了一下 jupyterlab， 好多插件的使用都需要安装nodejs，virtualenv 只能管理python 的环境，于是就想到了conda 试试conda 的环境管理能不能，惊喜的发现可以，所以以后的使用应该都迁移到 conda上来了</p>
<h2 id="conda简介">conda简介</h2>
<p>说明原文<a href="https://docs.conda.io/en/latest/">conda 文档</a></p>
<p>conda 是开源的跨操作系统的包管理系统和环境管理系统，可以管理多种语言，运行安装都比较简单</p>
<h2 id="conda-包管理">conda 包管理</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 添加一个渠道，获取软件包的渠道 常用的有 bioconda, conda-forge, genomedk</span>
conda config --add channel 

<span style="color:#75715e"># 设置去掉url显示</span>
conda config --set show_channel_urls yes

<span style="color:#75715e"># 渠道列表</span>
conda config --get channels

<span style="color:#75715e"># 搜索包</span>
conda search <span style="color:#f92672">[</span>-c channel<span style="color:#f92672">]</span> packagename

<span style="color:#75715e"># 安装包</span>
conda install packagename<span style="color:#f92672">=</span>versionnumber

<span style="color:#75715e"># 包列表</span>
conda list

<span style="color:#75715e"># 删除包</span>
conda remove packagename

</code></pre></div><h2 id="conda-环境管理">conda 环境管理</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 环境列表</span>
conda env --list

<span style="color:#75715e"># 环境信息</span>
conda info --envs

<span style="color:#75715e"># 创建python3环境</span>
conda create -n name python<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>

<span style="color:#75715e"># 激活环境</span>
conda activate environmentname

<span style="color:#75715e"># 退出环境</span>
conda deactivate

<span style="color:#75715e"># 删除环境</span>
conda remove -n environmentname --all

</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Shell 的笔记</title>
            <link>http://keltoy.github.io/posts/shell-%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
            <pubDate>Thu, 04 Jul 2019 11:13:56 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/shell-%E7%9A%84%E7%AC%94%E8%AE%B0/</guid>
            <description>Preface 翻开上学的时候破破烂烂的本子，看到刚开始学习 linux 的一些shell 总结，还是将这些记到网上好一些，有些还是挺实用的，我感觉
慢慢更新 &amp;hellip; $[] $(()) expr 这两个括号可以执行基本的算数操作（也就是 + - * / ）
#!/bin/sh bash result=3 r=4 echo $(($r + $result)) echo $[$r + $result] echo `expr 3 + 4`  注意的是空格，赋值语句 = 两边不能有 空格；expr 后的表达式需要 空格
 bc 具体功能就是调用计算器
&amp;#34; 4 * 0.56 &amp;#34;|bc  依然注意 空格 bc 前的|不能跟空格
 标准输入输出    符号 说明     0 stadin 标准输入   1 stadout 标准输出   2 staderr 错误输出   &amp;gt; 覆盖写入重定向   &amp;raquo; 追加写入   &amp;lt; 读取文件    cmd 2&amp;gt;stderr.</description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<p>翻开上学的时候破破烂烂的本子，看到刚开始学习 linux 的一些shell 总结，还是将这些记到网上好一些，有些还是挺实用的，我感觉</p>
<h1 id="慢慢更新-">慢慢更新 &hellip;</h1>
<h2 id="--expr">$[] $(()) expr</h2>
<p>这两个括号可以执行基本的算数操作（也就是 + - * / ）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> <span style="color:#75715e">#!/bin/sh bash</span>
result<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>
r<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
echo <span style="color:#66d9ef">$((</span>$r <span style="color:#f92672">+</span> $result<span style="color:#66d9ef">))</span>
echo $<span style="color:#f92672">[</span>$r + $result<span style="color:#f92672">]</span>
echo <span style="color:#e6db74">`</span>expr <span style="color:#ae81ff">3</span> + 4<span style="color:#e6db74">`</span>
</code></pre></div><blockquote>
<p>注意的是空格，赋值语句 = 两边不能有 空格；expr 后的表达式需要 <strong>空格</strong></p>
</blockquote>
<h2 id="bc">bc</h2>
<p>具体功能就是调用计算器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#e6db74">&#34; 4 * 0.56 &#34;</span>|bc
</code></pre></div><blockquote>
<p>依然注意 <strong>空格</strong> bc 前的|不能跟空格</p>
</blockquote>
<h2 id="标准输入输出">标准输入输出</h2>
<table>
<thead>
<tr>
<th style="text-align:right">符号</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:right">stadin 标准输入</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:right">stadout 标准输出</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:right">staderr 错误输出</td>
</tr>
<tr>
<td style="text-align:right">&gt;</td>
<td style="text-align:right">覆盖写入重定向</td>
</tr>
<tr>
<td style="text-align:right">&raquo;</td>
<td style="text-align:right">追加写入</td>
</tr>
<tr>
<td style="text-align:right">&lt;</td>
<td style="text-align:right">读取文件</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cmd 2&gt;stderr.txt 1&gt;stdout.txt
cmd &gt;output.txt 2&gt;&amp;<span style="color:#ae81ff">1</span>
cmd &amp;&gt; output.txt <span style="color:#75715e">#上面的简写</span>
cat <span style="color:#e6db74">&lt;&lt;EOF &gt;log.txt # 将EOF</span>之前的数据写入log.txt
</code></pre></div><p>除此以外，还有 3,4,5 备用标准输入输出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">exec 3&lt;input.txt
cat &lt;&amp;<span style="color:#ae81ff">3</span> <span style="color:#75715e"># 输出input.txt的数据</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">exec 4&gt;output.txt
echo newline &gt;&amp;<span style="color:#ae81ff">4</span>
cat output.txt <span style="color:#75715e"># 输出newline</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">exec 5&gt;&gt;output.txt
echo append &gt;&amp;<span style="color:#ae81ff">5</span>
cat output.txt <span style="color:#75715e"># 输出的数据会增加append 这一行 </span>
</code></pre></div><h2 id="tee">tee</h2>
<p>输出到文件，标准输入输出还是会输出</p>
<h3 id="参数">参数</h3>
<p>-a: 追加文件</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cat a* | tee out.txt | cat -n
</code></pre></div><p>结果保存到了 out.txt, 不影响后续操作</p>
<h2 id="数组">数组</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">array_var<span style="color:#f92672">=(</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> 5<span style="color:#f92672">)</span>
<span style="color:#75715e"># 或者</span>
array_var<span style="color:#f92672">[</span>0<span style="color:#f92672">]=</span><span style="color:#ae81ff">1</span>
array_var<span style="color:#f92672">[</span>2<span style="color:#f92672">]=</span><span style="color:#ae81ff">3</span>
echo <span style="color:#e6db74">${</span>array_var[0]<span style="color:#e6db74">}</span>
</code></pre></div><p>声明关联数组</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">declare -A ass_array
ass_array<span style="color:#f92672">=([</span>key1<span style="color:#f92672">]=</span>var1 <span style="color:#f92672">[</span>key2<span style="color:#f92672">]]=</span>var2<span style="color:#f92672">)</span>
ass_array<span style="color:#f92672">=[</span>key3<span style="color:#f92672">]=</span>var3
echo <span style="color:#e6db74">${</span>! ass_array[*]<span style="color:#e6db74">}</span> 列出key
echo <span style="color:#e6db74">${</span>! ass_array[@]<span style="color:#e6db74">}</span> 列出key
</code></pre></div><h2 id="-相关">$ 相关</h2>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$$</td>
<td style="text-align:center">shell本身的 pid</td>
</tr>
<tr>
<td style="text-align:center">${CMD}</td>
<td style="text-align:center">执行CMD命令</td>
</tr>
<tr>
<td style="text-align:center">$!</td>
<td style="text-align:center">shell最后运行的后台process的PID</td>
</tr>
<tr>
<td style="text-align:center">$?</td>
<td style="text-align:center">最后运行命令的结束代码(exit(0))</td>
</tr>
<tr>
<td style="text-align:center">$-</td>
<td style="text-align:center">查看 使用set 命令设置的flag</td>
</tr>
<tr>
<td style="text-align:center">$*</td>
<td style="text-align:center">所有的 参数列表 一般 [$*] 表示所有的形参</td>
</tr>
<tr>
<td style="text-align:center">$@</td>
<td style="text-align:center">所有的参数，类似$* 也是 [$@]</td>
</tr>
<tr>
<td style="text-align:center">$#</td>
<td style="text-align:center">添加到shell的参数个数</td>
</tr>
<tr>
<td style="text-align:center">$0</td>
<td style="text-align:center">shell 的文件名</td>
</tr>
<tr>
<td style="text-align:center">$1</td>
<td style="text-align:center">第一个参数</td>
</tr>
<tr>
<td style="text-align:center">${$1:- $2}</td>
<td style="text-align:center">如果$1不为空则使用$1 否则$2</td>
</tr>
</tbody>
</table>
<h2 id="tput">tput</h2>
<p>终端的一些设置</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">tput cols <span style="color:#75715e"># 获取终端列数</span>
tput lnes <span style="color:#75715e"># 获取终端行数</span>
tput longname <span style="color:#75715e"># 打印当前终端名</span>
tput cup <span style="color:#ae81ff">100</span> <span style="color:#ae81ff">100</span> <span style="color:#75715e"># 将光标移动到 100 100</span>
tput setb <span style="color:#f92672">[</span>0-7<span style="color:#f92672">]</span> <span style="color:#75715e"># 设置终端背景色 在zsh 好行不行</span>
tput setf <span style="color:#f92672">[</span>0-7<span style="color:#f92672">]</span> <span style="color:#75715e"># 设置终端前景色 在zsh 好像不行</span>
tput bold <span style="color:#75715e"># 文本样式改为粗体</span>
tput smul <span style="color:#75715e"># 下划线</span>
tput rmul <span style="color:#75715e"># 下划线</span>
tput ed <span style="color:#75715e"># 删除当天光标，位置到行尾</span>
tput rc <span style="color:#75715e"># 恢复光标位置</span>
tput sc <span style="color:#75715e"># 存储光标位置</span>
</code></pre></div><h1 id="set">set</h1>
<p>设置一些参数和环境</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">set -x <span style="color:#75715e"># 执行时显示参数和命令，可以查看</span>
set +x <span style="color:#75715e"># 禁止显示参数和命令</span>
set -v <span style="color:#75715e"># 读取时会显示输入</span>
set +v <span style="color:#75715e"># 读取时禁止显示输入</span>
set -e <span style="color:#75715e"># 如果执行的语句不为true 或者会说返回值不为0 则直接退出 脚本</span>
</code></pre></div><p>也可以写在第一行解释器里</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#1bin/bash -xv</span>
</code></pre></div><h1 id="分隔符-ifs">分隔符 IFS</h1>
<p>使用 IFS 对 分割符对数据分割，例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">data<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;name,sex,rollno,location&#34;</span>
oldIFS<span style="color:#f92672">=</span>$IFS
IFS<span style="color:#f92672">=</span>,
<span style="color:#66d9ef">for</span> item in $data;
<span style="color:#66d9ef">do</span>
echo Item:$item
<span style="color:#66d9ef">done</span>
IFS<span style="color:#f92672">=</span>$oldIFS
</code></pre></div><h2 id="循环">循环</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">for</span> var in list;
...
<span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>i<span style="color:#f92672">=</span>0;i&lt;10;i++<span style="color:#f92672">))</span>
<span style="color:#f92672">{</span>
...
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">while</span> condition
...
<span style="color:#66d9ef">until</span> condition
...
<span style="color:#f92672">{</span>1..50<span style="color:#f92672">}</span> <span style="color:#75715e"># 序列</span>
</code></pre></div><h2 id="read">read</h2>
<p>就是读取，写交互脚本的时候比较常用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">read -n num var <span style="color:#75715e"># 读取num个字符保存到var中</span>
read -s var <span style="color:#75715e"># 不回显信息，经常用作密码</span>
read -p <span style="color:#e6db74">&#34;hint&#34;</span> var <span style="color:#75715e"># 显示提示</span>
read -t timeout var <span style="color:#75715e"># 定时输入，单位：秒</span>
read -d delim_char var <span style="color:#75715e"># 使用界定符结束行</span>
</code></pre></div><h2 id="算数比较---test">算数比较 [ ] test</h2>
<p>注意 括号 和参数之间都有空格</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span> $var -ne <span style="color:#ae81ff">0</span> -a $var2 -gt <span style="color:#ae81ff">2</span> <span style="color:#f92672">]</span> <span style="color:#75715e"># var != 0 and var2 &gt; 2</span>
<span style="color:#f92672">[</span> $var -ne <span style="color:#ae81ff">0</span> -o $var2 -gt <span style="color:#ae81ff">2</span> <span style="color:#f92672">]</span> <span style="color:#75715e"># var != 0 or var2 &gt; 2</span>

</code></pre></div><p>-a: and
-o: or
-f 是否文件或目录存在
-x 是否为可执行文件
-d 目录是否存在
-e 文件是否存在
-c 是否是字符设备文件的路径
-b 是否是块设备文件的路径
-w 是否可写
-r 是否可读
-L 是否是符号链接</p>
<p>另外 test 也有类似的用法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span>$var -eq 0<span style="color:#f92672">]</span>; 
<span style="color:#66d9ef">if</span> test $var -eq <span style="color:#ae81ff">0</span> <span style="color:#75715e"># save as above</span>
</code></pre></div><h2 id="字符串比较--">字符串比较 [[ ]]</h2>
<p>还是注意 括号和参数之间都要有空格</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[[</span> $str1 <span style="color:#f92672">=</span> $str2 <span style="color:#f92672">]]</span>
<span style="color:#f92672">[[</span> $str1 <span style="color:#f92672">==</span> $str2 <span style="color:#f92672">]]</span> <span style="color:#75715e"># same as above</span>

<span style="color:#f92672">[[</span> -z $str <span style="color:#f92672">]]</span> <span style="color:#75715e"># 是否是空字符串</span>
<span style="color:#f92672">[[</span> -n $str <span style="color:#f92672">]]</span> <span style="color:#75715e"># 是否不为空</span>
</code></pre></div><p>= 或 == 相等
!= 不等
&gt; 字母序列大于
&lt; 字母序列小于</p>
<h2 id="cat-拼接">cat 拼接</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">echo <span style="color:#e6db74">&#39;this is a test&#39;</span> | cat - file.txt <span style="color:#75715e"># 输出和文件拼接到一起</span>
cat -s file <span style="color:#75715e"># 删除空行</span>
cat file | tr -s <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#75715e">#移除空白行</span>
cat -T file <span style="color:#75715e">#显示隐藏字符（制表符)</span>
cat -n file <span style="color:#75715e">#打印行号</span>
</code></pre></div><h2 id="find-查找">find 查找</h2>
<p>常用指令</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find base_path <span style="color:#75715e"># 获取base_path下所有的文件和目录</span>

find . -type d -print <span style="color:#75715e"># 获取当前目录下所有子目录并打印出来</span>

find . <span style="color:#ae81ff">\(</span> -name <span style="color:#e6db74">&#34;.txt&#34;</span> -o -name <span style="color:#e6db74">&#34;*.pdf&#34;</span> <span style="color:#ae81ff">\)</span> -print

find . -type f -atime -7 -print <span style="color:#75715e">#访问7天内</span>
find . -type f -atime <span style="color:#ae81ff">7</span> -print <span style="color:#75715e">#访问第7天</span>
find . -type f -atime +7 -print <span style="color:#75715e">#7天之前访问</span>

find . -type f -size +2k <span style="color:#75715e">#大于2k的文件</span>

find . <span style="color:#ae81ff">\(</span> -name <span style="color:#e6db74">&#34;.git&#34;</span> -prune <span style="color:#ae81ff">\)</span> -o <span style="color:#ae81ff">\(</span> -type f -print <span style="color:#ae81ff">\)</span>
</code></pre></div><p>-print 打印
-printo 以\o作为界定符
-type 类型 d: 目录, f: 文件, l: 链接 s: socket c:设备 p: FIFO
-name 名称，可以用 &ldquo;*&rdquo; 表示任意
-iname 忽略大小写
-path &ldquo;xxx&rdquo; 目录下有xxx的
-regex 正则
-iregex 不区分大小写
-atime 访问时间
-mtime 修改（内容）时间
-ctime 更改（meta own ）时间 时间为天
-newer xxx 比xxx修改时间更长的文件
-size 文件大小 b块 c字节 w字 k千字节 M兆 G吉
-delete 删除找到的这些文件或目录
-perm 644 权限
-user root 文件owner是root的
-exec command 执行指令
-prune 忽略
-o or 或者</p>
<p>找到用户是root 并都改成slynux</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find . -type f -user root -exec chown slynux <span style="color:#f92672">{}</span> <span style="color:#ae81ff">\;</span> 
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">-exec ./commands.sh <span style="color:#f92672">{}</span> <span style="color:#ae81ff">\;</span>
-exec printf <span style="color:#e6db74">&#34;xxxx%s&#34;</span> <span style="color:#f92672">{}</span> <span style="color:#ae81ff">\;</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>virtualenv 小记</title>
            <link>http://keltoy.github.io/posts/virtualenv-%E5%B0%8F%E8%AE%B0/</link>
            <pubDate>Mon, 01 Jul 2019 17:15:27 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/virtualenv-%E5%B0%8F%E8%AE%B0/</guid>
            <description>前言 最近想要获取url上的固定每日数据，写到原始脚本里发现程序卡死了，思前想后想再写一个脚本，这样也不用怎么修改之前的脚本。因为在服务器上运行还需要一些权限，所以希望能够使用virtualenv配置一下自己的环境。
开始实践 在服务器上安装 vitualenv, 然后创建环境就可以运行了
pip install virtualenv virtualenv --no-site-packages venv  &amp;ndash;no-site-packages 代表安装虚拟环境的时候不需要任何其他多余的包
 自己对虚拟环境的误解 因为是服务器环境，我发现我并没有root权限不能安装任何python的包。 我就希望将自己笔记本的python 环境打好包，安装到服务器上。 于是我将需要的包和库安装好后，使用virtualenv 配置好，打包传送到服务器上，准备使用virtualenv 开始运行
./venv/bin/activate 服务端的前缀出现了python3 的小括号，感觉目前都比较顺利。 然后查看版本号
python -V 2.7.5 怎么回事？没有变化？应该是变化成了virtualenv 中的 3.7才对 然后调用env中的python 确实是 3.7 于是 更改python 重新运行，发现这个3.7的python 什么包也照得不到。
看来自己对虚拟环境是有所误解
于是检查了一下venv/bin下的 activate 文件，才发现原来这个文件只是做了个映射
VIRTUAL_ENV=&amp;#34;xxx/venv&amp;#34; export VIRTUAL_ENV 所以想让activate 生效， 还需要更改这里的地址。</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>最近想要获取url上的固定每日数据，写到原始脚本里发现程序卡死了，思前想后想再写一个脚本，这样也不用怎么修改之前的脚本。因为在服务器上运行还需要一些权限，所以希望能够使用virtualenv配置一下自己的环境。</p>
<h1 id="开始实践">开始实践</h1>
<p>在服务器上安装 vitualenv, 然后创建环境就可以运行了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pip install virtualenv
virtualenv --no-site-packages venv
</code></pre></div><blockquote>
<p>&ndash;no-site-packages 代表安装虚拟环境的时候不需要任何其他多余的包</p>
</blockquote>
<h1 id="自己对虚拟环境的误解">自己对虚拟环境的误解</h1>
<p>因为是服务器环境，我发现我并没有root权限不能安装任何python的包。
我就希望将自己笔记本的python 环境打好包，安装到服务器上。
于是我将需要的包和库安装好后，使用virtualenv 配置好，打包传送到服务器上，准备使用virtualenv 开始运行</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./venv/bin/activate
</code></pre></div><p>服务端的前缀出现了python3 的小括号，感觉目前都比较顺利。
然后查看版本号</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">python <span style="color:#f92672">-</span>V
<span style="color:#ae81ff">2.7</span><span style="color:#f92672">.</span><span style="color:#ae81ff">5</span>
</code></pre></div><p>怎么回事？没有变化？应该是变化成了virtualenv 中的 3.7才对
然后调用env中的python 确实是 3.7
于是 更改python 重新运行，发现这个3.7的python 什么包也照得不到。</p>
<p>看来自己对虚拟环境是有所误解</p>
<p>于是检查了一下venv/bin下的 activate 文件，才发现原来这个文件只是做了个映射</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">VIRTUAL_ENV<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;xxx/venv&#34;</span>
export VIRTUAL_ENV
</code></pre></div><p>所以想让activate 生效， 还需要更改这里的地址。</p>
]]></content>
        </item>
        
        <item>
            <title>有关Spring注释的一些总结</title>
            <link>http://keltoy.github.io/posts/%E6%9C%89%E5%85%B3spring%E6%B3%A8%E9%87%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</link>
            <pubDate>Tue, 11 Dec 2018 10:50:58 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/%E6%9C%89%E5%85%B3spring%E6%B3%A8%E9%87%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</guid>
            <description>Spring Boot @SpringBootApplication  org.springframework.boot.autoconfigure.SpringBootApplication 项目的引导类 使用 SpringApplication.run(类名.class, args)进行启动，org.springframework.boot.SpringApplication 会返回 ApplicationContext对象  @Bean  使用@Component @Service 或者 @repository 标注一个Java类可以定义一个Bean 使用@Configuration 注解标签来标注一个类，然后在每个要构建的Bean定义一个构造器，在构造器方法上添加@Bean来定义一个Bean  Actuator 在maven中引入
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 然后可以配置
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.micrometer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;micrometer-registry-prometheus&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 默认在 /actuator 里之开启了health和info，需要在 application的配置里面添加
management: endpoints: web: exposure: include: health, info, env, metrics endpoint: health: show-details: always </description>
            <content type="html"><![CDATA[<h1 id="spring-boot">Spring Boot</h1>
<h2 id="springbootapplication">@SpringBootApplication</h2>
<ul>
<li>org.springframework.boot.autoconfigure.SpringBootApplication</li>
<li>项目的引导类</li>
<li>使用 <code>SpringApplication.run(类名.class, args)</code>进行启动，org.springframework.boot.SpringApplication 会返回 ApplicationContext对象</li>
</ul>
<h2 id="bean">@Bean</h2>
<ul>
<li>使用@Component @Service 或者 @repository 标注一个Java类可以定义一个Bean</li>
<li>使用@Configuration 注解标签来标注一个类，然后在每个要构建的Bean定义一个构造器，在构造器方法上添加@Bean来定义一个Bean</li>
</ul>
<h2 id="actuator">Actuator</h2>
<p>在maven中引入</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;dependency&gt;</span>
  <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
  <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-starter-actuator<span style="color:#f92672">&lt;/artifactId&gt;</span>
<span style="color:#f92672">&lt;/dependency&gt;</span>
</code></pre></div><p>然后可以配置</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;dependency&gt;</span>
    <span style="color:#f92672">&lt;groupId&gt;</span>io.micrometer<span style="color:#f92672">&lt;/groupId&gt;</span>
    <span style="color:#f92672">&lt;artifactId&gt;</span>micrometer-registry-prometheus<span style="color:#f92672">&lt;/artifactId&gt;</span>
<span style="color:#f92672">&lt;/dependency&gt;</span>
</code></pre></div><p>默认在 /actuator 里之开启了health和info，需要在 application的配置里面添加</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">management</span>:
  <span style="color:#f92672">endpoints</span>:
    <span style="color:#f92672">web</span>:
      <span style="color:#f92672">exposure</span>:
        <span style="color:#f92672">include</span>: <span style="color:#ae81ff">health, info, env, metrics</span>
  <span style="color:#f92672">endpoint</span>:
    <span style="color:#f92672">health</span>:
      <span style="color:#f92672">show-details</span>: <span style="color:#ae81ff">always</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Synchronized</title>
            <link>http://keltoy.github.io/posts/synchronized/</link>
            <pubDate>Thu, 18 Oct 2018 16:46:11 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/synchronized/</guid>
            <description>前言 Java 中 synchronized 关键字 在 很早以前就已经有了，我还记得自己刚开始学习 Java 的时候，别人问我并发的时候我都是说，加个 synchronized 就好了，温故而知新，现在重新学习 synchronized 关键字。
正文 注意的是，synchronized 是可重入锁！！
synchronized 同步基础 Java 中的对象创建时就有了监视器，每个 Java 对象都可以作为锁，
 普通同步方法，锁就是当前实力对象(this对象) 静态同步方法，锁是当前Class对象(.class对象) 同步方法块，锁是 synchronized 括号内部配置的对象  所以说，synchronized 锁住的都是对象。
synchronized 实现原理 Synchronized 代码块的实现是通过监视器实现的。使用 monitorenter 和 monitorexit 这两个指令来实现的，而且这两条指令必须成对出现。
  monitorenter 指令在编译后插入到同步代码块的开始位置
  monitorexit 指令是出入在异常处和结束位置
  Java 对象头 Synchronized 锁是存在 Java对象头里的。
 如果是对象，占用2个字来存储 如果是数组，占用3个字来存储     长度 内容 说明     32/64bit Mark Word 存储对象的hashCode或者锁信息   32/64bit Class Metadata Address 存储到对象类型的指针   32/64bit Array length 数组才有的选项，存储数组的长度    锁的升级 Synchronized 锁一共有4种状态，逐次升级。 级别由低到高：</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>Java 中 synchronized 关键字 在 很早以前就已经有了，我还记得自己刚开始学习 Java 的时候，别人问我并发的时候我都是说，加个 synchronized 就好了，温故而知新，现在重新学习 synchronized 关键字。</p>
<h1 id="正文">正文</h1>
<p>注意的是，synchronized 是<strong>可重入锁</strong>！！</p>
<h2 id="synchronized-同步基础">synchronized 同步基础</h2>
<p>Java 中的对象创建时就有了监视器，每个 Java 对象都可以作为锁，</p>
<ol>
<li>普通同步方法，锁就是当前实力对象(this对象)</li>
<li>静态同步方法，锁是当前Class对象(.class对象)</li>
<li>同步方法块，锁是 synchronized 括号内部配置的对象</li>
</ol>
<p>所以说，synchronized 锁住的都是对象。</p>
<h2 id="synchronized-实现原理">synchronized 实现原理</h2>
<p>Synchronized 代码块的实现是通过监视器实现的。使用 monitorenter 和 monitorexit 这两个指令来实现的，而且这两条指令必须成对出现。</p>
<ul>
<li>
<p>monitorenter 指令在编译后插入到同步代码块的开始位置</p>
</li>
<li>
<p>monitorexit 指令是出入在异常处和结束位置</p>
</li>
</ul>
<h3 id="java-对象头">Java 对象头</h3>
<p>Synchronized 锁是存在 Java对象头里的。</p>
<ul>
<li>如果是对象，占用2个字来存储</li>
<li>如果是数组，占用3个字来存储</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">长度</th>
<th style="text-align:center">内容</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">32/64bit</td>
<td style="text-align:center">Mark Word</td>
<td style="text-align:center">存储对象的hashCode或者锁信息</td>
</tr>
<tr>
<td style="text-align:center">32/64bit</td>
<td style="text-align:center">Class Metadata Address</td>
<td style="text-align:center">存储到对象类型的指针</td>
</tr>
<tr>
<td style="text-align:center">32/64bit</td>
<td style="text-align:center">Array length</td>
<td style="text-align:center">数组才有的选项，存储数组的长度</td>
</tr>
</tbody>
</table>
<h3 id="锁的升级">锁的升级</h3>
<p>Synchronized 锁一共有4种状态，逐次升级。
级别由低到高：</p>
<ol>
<li>无锁状态</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ol>
<h4 id="偏向锁">偏向锁</h4>
<p>多数情况下，锁是不存在多线程竞争的，并且一个锁总是由同一个线程获得。偏向锁只是在对象头和 栈帧中记录线程ID，之后只是简单测试对象头中的 Mark Word 里是否记录的是指向当前线程的偏向锁。</p>
<ul>
<li>测试成功，说明线程已经获取了该锁</li>
<li>测试失败，继续测试 Mark Word 中偏向锁的标识是否为1:
<ul>
<li>如果为1，尝试使用CAS 将对象头的偏向锁指向当前线程</li>
<li>如果不为1， 则使用CAS竞争锁，也就是轻量级锁</li>
</ul>
</li>
</ul>
<h5 id="撤销偏向锁">撤销偏向锁</h5>
<ul>
<li>等到竞争出现才释放锁机制</li>
<li>需要等到全局安全点  </li>
<li>暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着
<ul>
<li>如果线程不处于活动状态，对象头设置成无锁状态</li>
<li>如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向于其他线程， 要么恢复到无锁或者标记对象不适合作为偏向锁</li>
</ul>
</li>
<li>唤醒暂停的线程</li>
</ul>
<h5 id="关闭偏向锁">关闭偏向锁</h5>
<ul>
<li>关闭延迟：-XX: BiasedLockingStartupDelay=0</li>
<li>关闭偏向锁： -XX:UseBiasedLocing=false</li>
</ul>
<h4 id="轻量级锁">轻量级锁</h4>
<ul>
<li>线程在执行同步块时，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间</li>
<li>对象头中的Mark Word 复制到锁记录中，称为 Displaced Mark Word</li>
<li>线程尝试使用CAS将对象头中的Mark Word 替换为指向锁记录的指针</li>
<li>如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前县城变尝试使用自旋来获取锁</li>
</ul>
<h4 id="轻量级锁解锁">轻量级锁解锁</h4>
<ul>
<li>使用原子的CAS操作将 Displaced Mark Word 替换回对象头</li>
<li>如果成功，表示没有竞争发生；如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</li>
<li>锁升级成重量级锁，不会恢复到轻量级锁状态</li>
</ul>
<h4 id="重量级锁">重量级锁</h4>
<ul>
<li>不使用自旋锁，不会消耗CPU</li>
<li>其他线程试图获取都会阻塞住</li>
</ul>
<h1 id="小结">小结</h1>
<p>一开始只是使用偏向锁对锁进行处理，如果出现了竞争，则使用轻量级锁进行处理，轻量级锁进行CAS处理自旋，消耗CPU；如果解锁失败就会膨胀为重量级锁</p>
]]></content>
        </item>
        
        <item>
            <title>ConcurrentHashMap</title>
            <link>http://keltoy.github.io/posts/concurrenthashmap/</link>
            <pubDate>Tue, 16 Oct 2018 09:31:33 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/concurrenthashmap/</guid>
            <description>前言 重新学习ConcurrentHashMap
正题 使用ConcurrentHashMap的原因  ConcurrentHashMap 是 线程安全且高效的 HashMap 并发编程中使用HashMap可能导致程序死循环 HashTable 效率低下  HashMap 导致死循环 final HashMap&amp;lt;String, String&amp;gt; map = new Hashmap&amp;lt;String, String&amp;gt;(2); Thread t new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &amp;lt; 10000; i++) { new Thread(new Runnable() { @Override public void run() { map.put(UUID.randomUUID().toString(), &amp;#34;&amp;#34;); } }, &amp;#34;ftf&amp;#34;+i).start(); } } }, &amp;#34;ftf&amp;#34;); t.start(); t.join(); 在多线程的情况下，HashMap 的 Entry 链表可能会形成有环形的数据结构，那么 Entry 的 next 节点 就不可能为空，那就有可能无限循环获取 Entry。</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>重新学习ConcurrentHashMap</p>
<h1 id="正题">正题</h1>
<h2 id="使用concurrenthashmap的原因">使用ConcurrentHashMap的原因</h2>
<ul>
<li>ConcurrentHashMap 是 线程安全且高效的 HashMap</li>
<li>并发编程中使用HashMap可能导致程序死循环</li>
<li>HashTable 效率低下</li>
</ul>
<h3 id="hashmap-导致死循环">HashMap 导致死循环</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> HashMap<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Hashmap<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;(</span>2<span style="color:#f92672">);</span>
Thread t <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Thread</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 10000<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#a6e22e">@Override</span>
                <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                    map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>UUID<span style="color:#f92672">.</span><span style="color:#a6e22e">randomUUID</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(),</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">},</span> <span style="color:#e6db74">&#34;ftf&#34;</span><span style="color:#f92672">+</span>i<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">},</span> <span style="color:#e6db74">&#34;ftf&#34;</span><span style="color:#f92672">);</span>
t<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
t<span style="color:#f92672">.</span><span style="color:#a6e22e">join</span><span style="color:#f92672">();</span>
</code></pre></div><p>在多线程的情况下，HashMap 的 Entry 链表可能会形成有环形的数据结构，那么 Entry 的 next 节点 就不可能为空，那就有可能无限循环获取 Entry。</p>
<h3 id="hashtable-效率低下">HashTable 效率低下</h3>
<ul>
<li>HashTable 是使用 synchronized 保证线程安全</li>
<li>线程竞争的情况下，当一个线程访问HashTable，其他的线程会阻塞或者轮询（T1 使用put时，T2 既不能get也不能put）</li>
</ul>
<h2 id="concurrenthashmap-结构">ConcurrentHashMap 结构</h2>
<h3 id="jdk17">JDK1.7</h3>
<p><img src="http://odzz59auo.bkt.clouddn.com/ConcurrentHashMap.jpg" alt="ConcurrentHashMap类图"></p>
<p>也就是说，ConcurrentHashMap 是由Segment数组组成，每个Segment里又包含了许多 HashEntry</p>
<p>Segment 又继承了可重入锁，因此Segment实际上也是可重入锁，所以 ConcurrentHashMap 使用的分段锁能够减少线程之间的竞争</p>
<p>ConcurrentHashmap会对元素的hashCode 进行再一次hash 以减少散列冲突</p>
<h4 id="get">get</h4>
<p>请一定要记清楚，整个get过程是不加锁的，除非读到的值为空才会加锁重读。不使用加锁原因是 get 操作中使用到的共享变量都被定义成了 volatile 变量，例如 Segment 的 count，还有 HashEntry 的 value。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span> <span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
    <span style="color:#75715e">//segmentFor返回一个segment
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> segmentFor<span style="color:#f92672">(</span>hash<span style="color:#f92672">).</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> hash<span style="color:#f92672">)</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
<span style="color:#66d9ef">volatile</span> V value<span style="color:#f92672">;</span>
</code></pre></div><h4 id="put">put</h4>
<p>put 操作必须加锁，否则不能保证共享变量线程安全。1.7中使用的是自旋锁</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> s<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>value <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>hash <span style="color:#f92672">&gt;&gt;&gt;</span> segmentShift<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> segmentMask<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>s <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>UNSAFE<span style="color:#f92672">.</span><span style="color:#a6e22e">getObject</span>          <span style="color:#75715e">// nonvolatile; recheck
</span><span style="color:#75715e"></span>         <span style="color:#f92672">(</span>segments<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;&lt;</span> SSHIFT<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> SBASE<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#75715e">//  in ensureSegment
</span><span style="color:#75715e"></span>        s <span style="color:#f92672">=</span> ensureSegment<span style="color:#f92672">(</span>j<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> hash<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>插入数据的时候需要有2个操作</p>
<ol>
<li>检查Segment里的HashEntry数组是否需要扩容</li>
<li>定位元素位置，将元素放入HashEntry里</li>
</ol>
<p>扩容主要是判断容量是否超过 threshold。扩容操作先执行然后再执行插入，这样的扩容与HashMap有所不同，不会导致无故扩容之后浪费空间。当确定需要扩容后，会先创建一个2倍于当前HashEntry数组，然后插入数据。扩容只会影响当前segment进行扩容，不会影响其他的</p>
<h4 id="size">size</h4>
<p>首先，不能简单使用累加，因为累加的过程中可能会添加删除操作
其次，如果都加锁，那这个过程又非常低效
所以首先用尝试不锁住Segment统计2次，如果结果相同，返回该值，如果不同，再锁住所有的 Segment 进行统计</p>
<h3 id="jdk18">JDK1.8+</h3>
<p>在1.8以及之后的版本，HashMap 和 ConcurrentHashmap 有了较大的改动，
主要改动有：</p>
<ol>
<li>将原有table数组+链表的结构改成了 table数组+链表+红黑树的结构，如果元素达到一定量，原有的数组会改成红黑树来表示。这么改的原因是让数据能够比较平均地分布到散列表中，查询也能够更快，从原有的O(n)降至O(log(n))，提高性能</li>
<li>取消了Segment。取消了Segment也就是取消了重入锁，直接采用 volatile HashEntry来申明变量。这样一来，每个数据都有保障，也减少了冲突的概率</li>
</ol>
<p>ConcurrentHashmap 中，hashCode也有其定义。hashCode 在判断2个对象是否相等，或者容器中判断对象是否相等比较有用（key 为 object的时候，就需要更改equals，也要更改hashCode</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> t<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>t <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Traverser<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Traverser<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>t<span style="color:#f92672">,</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> it<span style="color:#f92672">.</span><span style="color:#a6e22e">advance</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#f92672">)</span>
                h <span style="color:#f92672">+=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">^</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> h<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="get-1">get</h4>
<p>
切记 get 方法是不用加锁的，由于本身的数组已经申明了 volatile，通过 happens before 原理保证了数据不会冲突</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> table<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab<span style="color:#f92672">;</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">,</span> p<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> eh<span style="color:#f92672">;</span> K ek<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> spread<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>tab <span style="color:#f92672">=</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span>
            <span style="color:#f92672">(</span>e <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> h<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>eh <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> h<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">)))</span>
                    <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>eh <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">find</span><span style="color:#f92672">(</span>h<span style="color:#f92672">,</span> key<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> h <span style="color:#f92672">&amp;&amp;</span>
                    <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span>
                    <span style="color:#66d9ef">return</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="put-1">put</h4>
<p>插入操作，除了扩容和插入之外，还需要判断是否需要转换成红黑树。插入的过程可以看到使用了 sychronized 关键字。加上addCount的方法，实际上就是使用了CAS+sychronized共同实现的
另外， sychronized 虽然效率低，但他也是<strong>可重入锁</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">putVal</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> onlyIfAbsent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> value <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> spread<span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">int</span> binCount <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> tab <span style="color:#f92672">=</span> table<span style="color:#f92672">;;)</span> <span style="color:#f92672">{</span>
            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> f<span style="color:#f92672">;</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> fh<span style="color:#f92672">;</span> K fk<span style="color:#f92672">;</span> V fv<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tab <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>
                tab <span style="color:#f92672">=</span> initTable<span style="color:#f92672">();</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>f <span style="color:#f92672">=</span> tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span> hash<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>casTabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">)))</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>                   <span style="color:#75715e">// no lock when adding to empty bin
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>fh <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> MOVED<span style="color:#f92672">)</span>
                tab <span style="color:#f92672">=</span> helpTransfer<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> f<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>onlyIfAbsent <span style="color:#75715e">// check first node without acquiring lock
</span><span style="color:#75715e"></span>                     <span style="color:#f92672">&amp;&amp;</span> fh <span style="color:#f92672">==</span> hash
                     <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">((</span>fk <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>fk <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>fk<span style="color:#f92672">)))</span>
                     <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>fv <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> fv<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                V oldVal <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tabAt<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fh <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            binCount <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> f<span style="color:#f92672">;;</span> <span style="color:#f92672">++</span>binCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                K ek<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span>
                                    <span style="color:#f92672">((</span>ek <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span>
                                     <span style="color:#f92672">(</span>ek <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>ek<span style="color:#f92672">))))</span> <span style="color:#f92672">{</span>
                                    oldVal <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent<span style="color:#f92672">)</span>
                                        e<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                                <span style="color:#f92672">}</span>
                                Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> pred <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                    pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
                                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                                <span style="color:#f92672">}</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> TreeBin<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                            Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">;</span>
                            binCount <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
                            <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">((</span>TreeBin<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>f<span style="color:#f92672">).</span><span style="color:#a6e22e">putTreeVal</span><span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span>
                                                           value<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                                oldVal <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
                                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onlyIfAbsent<span style="color:#f92672">)</span>
                                    p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
                            <span style="color:#f92672">}</span>
                        <span style="color:#f92672">}</span>
                        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>f <span style="color:#66d9ef">instanceof</span> ReservationNode<span style="color:#f92672">)</span>
                            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Recursive update&#34;</span><span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>binCount <span style="color:#f92672">&gt;=</span> TREEIFY_THRESHOLD<span style="color:#f92672">)</span>
                        treeifyBin<span style="color:#f92672">(</span>tab<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldVal <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                        <span style="color:#66d9ef">return</span> oldVal<span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        addCount<span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> binCount<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h4 id="size-1">size</h4>
<p>官方说如果想计数还是使用 mappingCount() 好&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">long</span> n <span style="color:#f92672">=</span> sumCount<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">((</span>n <span style="color:#f92672">&lt;</span> 0L<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span>
            <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span>Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">)</span> <span style="color:#f92672">?</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">:</span>
                <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>n<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">sumCount</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    CounterCell<span style="color:#f92672">[]</span> cs <span style="color:#f92672">=</span> counterCells<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">long</span> sum <span style="color:#f92672">=</span> baseCount<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cs <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>CounterCell c <span style="color:#f92672">:</span> cs<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                sum <span style="color:#f92672">+=</span> c<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> sum<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>counterCells是个全局的变量，表示的是CounterCell类数组。CounterCell是ConcurrentHashmap的内部类，它就是存储一个值。1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据put()或则删除数据remove()时，会通过addCount()方法更新baseCount初始化时counterCells为空，在并发量很高时，如果存在两个线程同时执行CAS修改baseCount值，则失败的线程会继续执行方法体中的逻辑，执行fullAddCount(x, uncontended)方法，这个方法其实就是初始化counterCells，并将x的值插入到counterCell类中，而x值一般也就是1
所以counterCells存储的都是value为1的CounterCell对象，而这些对象是因为在CAS更新baseCounter值时，由于高并发而导致失败，最终将值保存到CounterCell中，放到counterCells里。这也就是为什么sumCount()中需要遍历counterCells数组，sum累加CounterCell.value值了。</p>
<h1 id="小结">小结</h1>
<p>工作一年，感觉技术退步了不少，原来张口就来的东西现在说的结结巴巴，原来提手就写的代码，现在还要想想</p>
]]></content>
        </item>
        
        <item>
            <title>机器学习基本点</title>
            <link>http://keltoy.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%82%B9/</link>
            <pubDate>Fri, 01 Jun 2018 10:09:37 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%82%B9/</guid>
            <description>前言 这是第二遍开始学习机器学习，第一遍都记到本子上，这一次在这里记一次，看看两次记录有哪些异同
三要素 模型  模型可以是条件概率分布 模型可以是决策函数  策略  策略就是考虑按照什么样的规则学习或者选择最优模型。 度量模型的好坏可以使用损失函数和风险函数  损失函数 损失函数度量一次预测的好坏
风险函数 风险函数度量平均意义下模型预测的好坏
损失函数与代价函数的区别  损失函数：用来计算单个样本的误差 代价函数：与损失函数一样也是计算样本误差的，网上说区别是，代价函数是计算训练集上的所有样本的误差平均数（不过这就跟风险函数重复了不是么？） 目标函数：一般来说就是 损失函数 + 正则化项  损失函数 损失函数也分了好几种，通常使用 $L(Y, f(X))$
 0-1损失函数  $$ L(Y, f(X)) =\begin{cases} 1&amp;amp; Y \neq f(X)\
0&amp;amp; Y = f(X) \end{cases} $$
平方损失函数 主要用于最小二乘法  $$ L(Y, f(X)) = {(Y-f(X))}^2 $$
绝对损失函数  $$ L(Y, f(X)) = \vert Y-f(X) \vert $$
对数(似然)损失函数  $$ L(Y, P(Y|X)) = -\log P(Y|X) $$</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>这是第二遍开始学习机器学习，第一遍都记到本子上，这一次在这里记一次，看看两次记录有哪些异同</p>
<h1 id="三要素">三要素</h1>
<h2 id="模型">模型</h2>
<ul>
<li>模型可以是条件概率分布</li>
<li>模型可以是决策函数</li>
</ul>
<h2 id="策略">策略</h2>
<ul>
<li>策略就是考虑按照什么样的规则学习或者选择最优模型。</li>
<li>度量模型的好坏可以使用损失函数和风险函数</li>
</ul>
<h3 id="损失函数">损失函数</h3>
<p>损失函数度量<strong>一次</strong>预测的好坏</p>
<h3 id="风险函数">风险函数</h3>
<p>风险函数度量<strong>平均意义下</strong>模型预测的好坏</p>
<h1 id="损失函数与代价函数的区别">损失函数与代价函数的区别</h1>
<ul>
<li>损失函数：用来计算单个样本的误差</li>
<li>代价函数：与损失函数一样也是计算样本误差的，网上说区别是，代价函数是计算训练集上的所有样本的误差平均数（不过这就跟风险函数重复了不是么？）</li>
<li>目标函数：一般来说就是 损失函数 + 正则化项</li>
</ul>
<h1 id="损失函数-1">损失函数</h1>
<p>损失函数也分了好几种，通常使用 $L(Y, f(X))$</p>
<ol>
<li>0-1损失函数</li>
</ol>
<p>$$
L(Y, f(X)) =\begin{cases}
1&amp;       Y \neq f(X)\<br>
0&amp;       Y = f(X)
\end{cases}
$$</p>
<ol start="2">
<li>平方损失函数
主要用于最小二乘法</li>
</ol>
<p>$$
L(Y, f(X)) = {(Y-f(X))}^2
$$</p>
<ol start="3">
<li>绝对损失函数</li>
</ol>
<p>$$
L(Y, f(X)) = \vert Y-f(X) \vert
$$</p>
<ol start="4">
<li>对数(似然)损失函数</li>
</ol>
<p>$$
L(Y, P(Y|X)) = -\log P(Y|X)
$$</p>
<ol start="5">
<li>铰链损失函数
主要用于SVM</li>
</ol>
<p>$$
L(m_i) = \max(0, 1-m_i(w))
$$</p>
<ol start="6">
<li>互熵函数</li>
</ol>
<p>主要用于逻辑回归 或者 softmax 中</p>
<p>$$
\begin{array}{l}
L(Y, P(Y|X)) = -\log P(Y|X)\<br>
P(y=1|x;\theta) = h_\theta(x)\<br>
P(y=0|x;\theta) = 1 - h_\theta(x)\<br>
p(y|x;\theta) = (h_\theta(x))^y(1-h_\theta(x))^{1-y}
\end{array}
$$</p>
<p>$$
\begin{equation}\begin{split}
L(\theta) &amp;= p(\vec{y}| X;\theta)\<br>
&amp;= \prod_{i=1}^{m}p(y^{(i)}|x^{(i)};\theta)\<br>
&amp;= \prod_{i=1}^{m}(h_{\theta}(x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{1-y^{(i)}}
\end{split}\end{equation}
$$</p>
<p>最大化 $\ell(\theta)$这个$\log$似然函数，就是最小化互熵函数</p>
<p>$$
\begin{equation}\begin{split}
\ell(\theta) &amp;= \log(-L(\theta))\<br>
&amp;= \frac{1}{m}\sum_{i=1}^{m}y^{(i)}\log h(x^{(i)}) + (1-y^{(i)})\log (1-h(x^{(i)}))
\end{split}\end{equation}
$$</p>
<p>其中，</p>
<p>$$
\begin{equation}\begin{split}
h_\theta(x) = \frac{1}{1-\exp({-f(x)})}
\end{split}\end{equation}
$$</p>
<ol start="7">
<li>指数函数
主要用于adaboost</li>
</ol>
<h2 id="风险函数-1">风险函数</h2>
<p>风险函数是损失函数的期望：</p>
<p>$$
R_{exp}(f) = E_{P}[L(Y,f(X))]
$$</p>
<p>由于风险函数无法直接求出，所以可以使用经验损失函数。
经验损失函数 是训练集的平均损失
经验风险最小化，就是最优模型</p>
<p>$$
R_{exp}(f) = E_{P}[L(Y,f(X))]
$$</p>
<h2 id="目标函数">目标函数</h2>
<p>为了防止过拟合,提出结构风险函数  $\lambda$作为参数，权衡经验风险和复杂度 $J(f)$是正则化项</p>
<p>$$
R_{\min}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i, f(x_i)) + \lambda J(f)
$$</p>
<h1 id="总结">总结</h1>
<p>latex 的格式乱了，有时间整理成 图片好了</p>
]]></content>
        </item>
        
        <item>
            <title>Redis 并发小结</title>
            <link>http://keltoy.github.io/posts/redis-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/</link>
            <pubDate>Sat, 29 Apr 2017 12:12:58 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/redis-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/</guid>
            <description>Preface 实习了一段时间，一直没有写东西了，最近清闲了一些，开始总结一些实习上所获取的经验。不是很高深，但是可能经常会用到。
应用场景 比如要在网上买理财产品，每个理财产品都是有限定金额的。这个产品会有一个总金额 totalAmount，每个人都可以买，也不限制买多少，但是所有人的购买金额不能超过这个总金额。这是一个很简单的场景，之前没有接触缓存的时候处理也比较简单。这些用户购买的数据是存到数据库中的，因此可以通过数据库直接控制。
使用数据库锁进行处理 使用数据库的共享锁和排他锁是可以实现数据的同步的。但是我没有实际实验过，所有人都说尽量不要这么去实现，效率会低很多。
共享锁： SELECT ... LOCK IN SHARE MODE; 排他锁： SELECT ... FOR UPDATE; 个人的理解，共享锁(S)和排他锁(X)就是读写锁，这种形式在读多写少的情况下会比较高效。
使用数据库的乐观并发机制 使用乐观并发机制，可以在相应的表中添加一个 version 列，每次在购买前获取一下 version，然后进行购买时检查version是否有变化，如果有变化就不进行处理，如果没有变化，在确保成功后更改 version。
当然，在我所举例的例子中，这个 version 可以直接是 总金额 totalAmount，每次操作的时候都对这个总金额进行改变，如果总金额小于0了，说明不能进行处理，回滚处理，购买不成功
看似是个不错的方法，但是有很多的限制。如果数据库不允许修改，而一开始并没有总金额或者 version 这样的列呢，用 updatedtime 也能够实现，但是据说用时间索引效率会低很多。如果数据库分库分表了，又该如何控制？
使用Redis进行并发控制 setnx setnx 是一个事务操作，会先检查缓存中是否存在，如果不存在则设置，否则不做更改。 这样设计不会出现没有volatile 双重检测出现的那样的问题，不会在判断有无之后，插入数据之前的时间插入另外的数据。那么使用 setnx 的用法就与 mutex非常类似，在插入前 setnx，确认成功之后，进行 del。
setnx key value ... del key 在此之前，我也想过使用 incrby 对数据进行增加和减少，但是，在这种情况下，防不住并发。
一点思考 假设现在需要做一点改变。假设每个人最多只能购买三次，第四次购买就失败。如果这样，如果不允许在数据库中需要添加一个 purchase 的列，怎么使用redis 进行设计？ 同样是使用 setnx，然后在内部再使用一个 incrby 是否就安全了？
消息队列 如果使用消息队列，能够保证数据是一个个到来的，那么是不是也可以保证并发，而且降低了复杂度？但是对于一个简单的需求，使用消息的代价也不小。
Postscript 将传统项目放到分布式架构上，就容易出现问题。分布式的消息传递代价也不小，因此，并发这块一直也很热。</description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<p>实习了一段时间，一直没有写东西了，最近清闲了一些，开始总结一些实习上所获取的经验。不是很高深，但是可能经常会用到。</p>
<h1 id="应用场景">应用场景</h1>
<p>比如要在网上买理财产品，每个理财产品都是有限定金额的。这个产品会有一个总金额 totalAmount，每个人都可以买，也不限制买多少，但是所有人的购买金额不能超过这个总金额。这是一个很简单的场景，之前没有接触缓存的时候处理也比较简单。这些用户购买的数据是存到数据库中的，因此可以通过数据库直接控制。</p>
<h1 id="使用数据库锁进行处理">使用数据库锁进行处理</h1>
<p>使用数据库的共享锁和排他锁是可以实现数据的同步的。但是我没有实际实验过，所有人都说尽量不要这么去实现，效率会低很多。</p>
<pre><code>共享锁： SELECT ... LOCK IN SHARE MODE;

排他锁： SELECT ... FOR UPDATE;

</code></pre><p>个人的理解，共享锁(S)和排他锁(X)就是读写锁，这种形式在读多写少的情况下会比较高效。</p>
<h1 id="使用数据库的乐观并发机制">使用数据库的乐观并发机制</h1>
<p>使用乐观并发机制，可以在相应的表中添加一个 version 列，每次在购买前获取一下 version，然后进行购买时检查version是否有变化，如果有变化就不进行处理，如果没有变化，在确保成功后更改 version。</p>
<p>当然，在我所举例的例子中，这个 version 可以直接是 总金额 totalAmount，每次操作的时候都对这个总金额进行改变，如果总金额小于0了，说明不能进行处理，回滚处理，购买不成功</p>
<p>看似是个不错的方法，但是有很多的限制。如果数据库不允许修改，而一开始并没有总金额或者 version 这样的列呢，用 updatedtime 也能够实现，但是据说用时间索引效率会低很多。如果数据库分库分表了，又该如何控制？</p>
<h1 id="使用redis进行并发控制">使用Redis进行并发控制</h1>
<pre><code>setnx
</code></pre><p>setnx 是一个事务操作，会先检查缓存中是否存在，如果不存在则设置，否则不做更改。
这样设计不会出现没有volatile 双重检测出现的那样的问题，不会在判断有无之后，插入数据之前的时间插入另外的数据。那么使用 setnx 的用法就与 mutex非常类似，在插入前 setnx，确认成功之后，进行 del。</p>
<pre><code>setnx key value
...
del key
</code></pre><p>在此之前，我也想过使用 incrby 对数据进行增加和减少，但是，在这种情况下，防不住并发。</p>
<h1 id="一点思考">一点思考</h1>
<p>假设现在需要做一点改变。假设每个人最多只能购买三次，第四次购买就失败。如果这样，如果不允许在数据库中需要添加一个 purchase 的列，怎么使用redis 进行设计？
同样是使用 setnx，然后在内部再使用一个 incrby 是否就安全了？</p>
<h1 id="消息队列">消息队列</h1>
<p>如果使用消息队列，能够保证数据是一个个到来的，那么是不是也可以保证并发，而且降低了复杂度？但是对于一个简单的需求，使用消息的代价也不小。</p>
<h1 id="postscript">Postscript</h1>
<p>将传统项目放到分布式架构上，就容易出现问题。分布式的消息传递代价也不小，因此，并发这块一直也很热。</p>
]]></content>
        </item>
        
        <item>
            <title>Emacs: org-mode</title>
            <link>http://keltoy.github.io/posts/emacs-org-mode/</link>
            <pubDate>Wed, 18 Jan 2017 11:20:41 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/emacs-org-mode/</guid>
            <description>Time and tide wait for no man
 Preface 已经听了很多人说 org-mode 非常好用，一直不知道怎么用，今天看了看一些文章，发现其实和 markdown 有那么点像，总结总结，想自己做个 GTD。
Org-mode Chapter md 中的章节使用 &amp;ldquo;#&amp;quot;，而 org-mode 中使用 &amp;ldquo;*&amp;quot;。
不过，org-mode 有一些有趣的操作：
 S-tab, toggle 所有的 chapter tab, toggle 当前的 chapter M-left/right, 升级/降级 chapter M-up/down, 调整 chapter 的顺序  List 无序 md 无序队列使用 &amp;ldquo;*&amp;rdquo; 和 &amp;ldquo;+&amp;quot;，而 org-mode 使用 &amp;ldquo;+&amp;rdquo; 和 &amp;ldquo;-&amp;quot;。
注意到的是 md 的间距是不同的：
 这是 &amp;ldquo;*&amp;rdquo; 的第一行 这是第二行   这是 &amp;ldquo;+&amp;rdquo; 的第一行 这是第二行  有序 md 的有序使用的是 &amp;ldquo;1.</description>
            <content type="html"><![CDATA[<blockquote>
<p>Time and tide wait for no man</p>
</blockquote>
<h1 id="preface">Preface</h1>
<p>已经听了很多人说 org-mode 非常好用，一直不知道怎么用，今天看了看一些文章，发现其实和 markdown 有那么点像，总结总结，想自己做个 GTD。</p>
<h1 id="org-mode">Org-mode</h1>
<h2 id="chapter">Chapter</h2>
<p>md 中的章节使用 &ldquo;#&quot;，而 org-mode 中使用 &ldquo;*&quot;。</p>
<p>不过，org-mode 有一些有趣的操作：</p>
<ol>
<li>S-tab, toggle 所有的 chapter</li>
<li>tab, toggle 当前的 chapter</li>
<li>M-left/right, 升级/降级 chapter</li>
<li>M-up/down, 调整 chapter 的顺序</li>
</ol>
<h2 id="list">List</h2>
<h3 id="无序">无序</h3>
<p>md 无序队列使用 &ldquo;*&rdquo; 和 &ldquo;+&quot;，而 org-mode 使用 &ldquo;+&rdquo; 和 &ldquo;-&quot;。</p>
<p>注意到的是 md 的间距是不同的：</p>
<ul>
<li>这是 &ldquo;*&rdquo; 的第一行</li>
<li>这是第二行</li>
</ul>
<ul>
<li>这是 &ldquo;+&rdquo; 的第一行</li>
<li>这是第二行</li>
</ul>
<h3 id="有序">有序</h3>
<p>md 的有序使用的是 &ldquo;1. 2. 3.&rdquo; 这样，而 org-mode 使用的是 &ldquo;1) 2) 3)&rdquo;</p>
<h3 id="其他">其他</h3>
<p>org-mode 提供一种 checkbox 可以检查当前行是否完成，使用 [ ] ，注意括号里面必须有空格：</p>
<pre><code>1) [ ] Task1 [%] # or [/]
    1) [ ] step1
    2) [X] step2
    3) [ ] step3
</code></pre><p>标记 &ldquo;X&rdquo; 使用 org-toggle-checkbox(C-c C-x C-b，至少我的是这样)，</p>
<p>当然也支持 M-up/down/left/right</p>
<p>M-RET 插入同级列表项
M-S-RET 插入带有 checkbox 的列表项</p>
<h2 id="table">Table</h2>
<h2 id="footnotes">Footnotes</h2>
]]></content>
        </item>
        
        <item>
            <title>Question For Nginx Error 500</title>
            <link>http://keltoy.github.io/posts/question-for-nginx-error-500/</link>
            <pubDate>Tue, 10 Jan 2017 12:23:20 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/question-for-nginx-error-500/</guid>
            <description>Preface 前几天服务器到期了，然后重新申请了之后，发现本地的 node 也出了问题，按照网上的方法也修理不好。
于是自己想使用 docker 来重新建。费了一些时间把 docker 实践了，感觉挺费流量的&amp;hellip;不过还好。
昨天，node 自己又好了&amp;hellip;优点莫名其妙，后来想想可能跟 python2.7.x 的版本有关系。
然后重新搭建的时候发现 nginx 启动不了， 返回
500 internal server error  500 internal server error 使用 systemctl status nginx.service 发现，启动之后访问 web 目录访问不了。
网上说跟自己的配置有关系，比如 location 配置的有问题等等。
本人检查了很久没有什么问题，确定分号，拼写都没问题，但是还是会报 500 错误。
Log is key 一筹莫展的时候就想试试各种办法，于是就查询了 /var/log/nginx 下面的错误日志，发现报的错误是
13: Permission denied  难道是权限不够？对于 755 的权限设置应该是没有问题，于是我改成了 777 虽然觉得没什么效果，但是还是试了一试。 果然，没有效果，依旧拒绝。不过可以确定的是，应该是权限的问题。
可能，是用户的问题。带着这个想法我看了一下 nginx.conf 的用户发现
user nginx  试试给个最大的权限 修改成 root
user root  重启一下 nginx
OK！运行成功了。</description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<p>前几天服务器到期了，然后重新申请了之后，发现本地的 node 也出了问题，按照网上的方法也修理不好。</p>
<p>于是自己想使用 docker 来重新建。费了一些时间把 docker 实践了，感觉挺费流量的&hellip;不过还好。</p>
<p>昨天，node 自己又好了&hellip;优点莫名其妙，后来想想可能跟 python2.7.x 的版本有关系。</p>
<p>然后重新搭建的时候发现 nginx 启动不了， 返回</p>
<pre><code>500 internal server error
</code></pre>
<h1 id="500-internal-server-error">500 internal server error</h1>
<p>使用 systemctl status nginx.service 发现，启动之后访问 web 目录访问不了。</p>
<p>网上说跟自己的配置有关系，比如 location 配置的有问题等等。</p>
<p>本人检查了很久没有什么问题，确定分号，拼写都没问题，但是还是会报 500 错误。</p>
<h1 id="log-is-key">Log is key</h1>
<p>一筹莫展的时候就想试试各种办法，于是就查询了 /var/log/nginx 下面的错误日志，发现报的错误是</p>
<pre><code>13: Permission denied
</code></pre>
<p>难道是权限不够？对于 755 的权限设置应该是没有问题，于是我改成了 777 虽然觉得没什么效果，但是还是试了一试。
果然，没有效果，依旧拒绝。不过可以确定的是，应该是权限的问题。</p>
<p>可能，是用户的问题。带着这个想法我看了一下 nginx.conf 的用户发现</p>
<pre><code>user nginx
</code></pre>
<p>试试给个最大的权限 修改成 root</p>
<pre><code>user root
</code></pre>
<p>重启一下 nginx</p>
<p>OK！运行成功了。</p>
<h1 id="postscript">Postscript</h1>
<p>其实这个问题困扰了我很长时间，每次配nginx的时候都会出现这样那样的问题，不过这次解决之后，下一次应该不会再犯了。</p>
]]></content>
        </item>
        
        <item>
            <title>Index For MySQL</title>
            <link>http://keltoy.github.io/posts/index-for-mysql/</link>
            <pubDate>Fri, 30 Dec 2016 23:16:42 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/index-for-mysql/</guid>
            <description>Preface  Beautiful is better than ugly.
 之前被问到索引的分类，被分为唯一性索引和普通索引，有点懵逼。回头再看看，总结一下。
Keys  PRIMARY 主键索引建立主键索引其实跟 UNIQUE 没什么区别 INDEX 普通的索引 UNIQUE 唯一性索引 FULLTEXT 全文索引，这个 innodb 在 MySQL 5.5 之前不支持 SPAIAL 空间索引  这么分其实很混乱，这几个 key 好像不是一个维度的。
Types of Index 在《高性能 MySQL》是这么分的：
 B-Tree 索引 哈希索引 空间数据索引 全文索引 其他索引  </description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<blockquote>
<p>Beautiful is better than ugly.</p>
</blockquote>
<p>之前被问到索引的分类，被分为唯一性索引和普通索引，有点懵逼。回头再看看，总结一下。</p>
<h1 id="keys">Keys</h1>
<ul>
<li>PRIMARY  主键索引建立主键索引其实跟 UNIQUE 没什么区别</li>
<li>INDEX 普通的索引</li>
<li>UNIQUE 唯一性索引</li>
<li>FULLTEXT 全文索引，这个 innodb 在 MySQL 5.5 之前不支持</li>
<li>SPAIAL 空间索引</li>
</ul>
<p>这么分其实很混乱，这几个 key 好像不是一个维度的。</p>
<h1 id="types-of-index">Types of Index</h1>
<p>在《高性能 MySQL》是这么分的：</p>
<ul>
<li>B-Tree 索引</li>
<li>哈希索引</li>
<li>空间数据索引</li>
<li>全文索引</li>
<li>其他索引</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Learning Docker</title>
            <link>http://keltoy.github.io/posts/learning-docker/</link>
            <pubDate>Thu, 15 Dec 2016 23:59:23 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/learning-docker/</guid>
            <description>What Is Docker Docker 是开源的应用容器引擎，开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发不到其他机器上，实现虚拟化。容器完全使用沙箱机制，互相之间不会有任何接口。 Docker 基于LXC的引擎使用 go 开发。
How To Use Docker  构建一个镜像 运行容器  其实可以当作一个虚拟机来使用&amp;hellip;.
Docker Command docker info 查看 docker 的相关信息
docker pull an image or a repository 从远端拉取一个镜像或者仓库 eg:
docker pull busybox  docker run image cmd 运行镜像的一个命令 eg:
docker run busybox /bin/echo Hello Docker  eg: 后台进程方式运行
sample_job=$(docker run -d busybox /bin/sh -c &amp;quot;while true; do echo Docker; sleep 1; done&amp;quot;)  -d 代表 detach</description>
            <content type="html"><![CDATA[<h1 id="what-is-docker">What Is Docker</h1>
<p>Docker 是开源的应用容器引擎，开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发不到其他机器上，实现虚拟化。容器完全使用沙箱机制，互相之间不会有任何接口。
Docker 基于LXC的引擎使用 go 开发。</p>
<h1 id="how-to-use-docker">How To Use Docker</h1>
<ol>
<li>构建一个镜像</li>
<li>运行容器</li>
</ol>
<p>其实可以当作一个虚拟机来使用&hellip;.</p>
<h1 id="docker-command">Docker Command</h1>
<h2 id="docker-info">docker info</h2>
<p>查看 docker 的相关信息</p>
<h2 id="docker-pull-an-image-or-a-repository">docker pull an image or a repository</h2>
<p>从远端拉取一个镜像或者仓库
eg:</p>
<pre><code>docker pull busybox
</code></pre>
<h2 id="docker-run-image-cmd">docker run image cmd</h2>
<p>运行镜像的一个命令
eg:</p>
<pre><code>docker run busybox /bin/echo Hello Docker
</code></pre>
<p>eg: 后台进程方式运行</p>
<pre><code>sample_job=$(docker run -d busybox /bin/sh -c &quot;while true; do echo Docker; sleep 1; done&quot;)
</code></pre>
<p>-d 代表 detach</p>
<h2 id="docker-logs-container">docker logs container</h2>
<p>查看容器状态日志
eg:</p>
<pre><code>docker logs $sample_job
</code></pre>
<h2 id="docker-help">docker help</h2>
<p>由于 docker 没有 man，所以 help 就很重要了</p>
<h2 id="docker-stop-container">docker stop container</h2>
<p>停止容器</p>
<h2 id="docker-restart-container">docker restart container</h2>
<p>重启容器</p>
<h2 id="docker-rm-container">docker rm container</h2>
<p>删除容器</p>
<h2 id="docker-commit-container-image-name">docker commit container image-name</h2>
<p>保存容器为镜像</p>
<h2 id="docker-images">docker images</h2>
<p>查看所有镜像</p>
<h2 id="docker-search-image-name">docker search (image-name)</h2>
<p>搜索镜像</p>
<h2 id="docker-history-image_name">docker history (image_name)</h2>
<p>历史版本</p>
<h2 id="docker-push-image_name">docker push (image_name)</h2>
<p>使用将镜像推送到registry</p>
<h1 id="dockerfile">DockerFile</h1>
<p>使用 DockerFile 自动创建镜像。</p>
<pre><code>INSTRUCTION arguments
</code></pre>
<p>指令不区分大小写，但是命名约定大写</p>
<h2 id="from-image-name">FROM <!-- raw HTML omitted --></h2>
<p>所有的 DockerFile 必须以 FROM 开始,指定镜像基于哪个基础镜像创建。
eg:</p>
<pre><code>FROM ubuntu
</code></pre>
<h2 id="maintainer-author-name">MAINTAINER <!-- raw HTML omitted --></h2>
<p>设置镜像作者</p>
<h2 id="run-command">RUN <!-- raw HTML omitted --></h2>
<p>运行 Shell 或者 Exec 指令</p>
<h2 id="add-src-dest">ADD <!-- raw HTML omitted --> <!-- raw HTML omitted --></h2>
<p>向容器内复制文件指令</p>
<h2 id="cmd-executable-param1-param">CMD [&ldquo;executable&rdquo;, &ldquo;param1&rdquo;, &ldquo;param&rdquo;]</h2>
]]></content>
        </item>
        
        <item>
            <title>Source Code in Java -- Spring IOC - II</title>
            <link>http://keltoy.github.io/posts/source-code-in-java-spring-ioc-ii/</link>
            <pubDate>Thu, 10 Nov 2016 23:09:39 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/source-code-in-java-spring-ioc-ii/</guid>
            <description>Preface  简单来说 IoC 容器的初始化是由 refresh() 方法启动的，这个方法标志着 IoC 容器正式启动。具体来说这个启动包括 BeanDefinition 的 Resource 定位、载入和注册三个基本过程。
 关于这段话我首先不能理解的就是无缘无故出来的这个BeanDefinition，我在浏览这些源码的时候也没看到。因此，为了好好了解 Spring IoC，我还需要进一步查看内部源码和解释。
What is BeanDefinition?  对 IoC 来说，BeanDefinition 就是对依赖反转模式中管理的对象依赖关系的数据抽象。
Spring 通过定义 BeanDefinition 来管理基于 Spring 的应用中的各种对象以及它们之间的相互依赖关系。BeanDefinition 抽象了我们对 Bean 的定义，是让容器起作用的主要数据类型。
 我的理解 BeanDefinition 有点像 Bean 的元数据，又有点像抽象类，又有点像 schema。
Resource location of BeanDefinition 再次拿出来这幅图来讲一下，像 ClassPathXmlApplicationContext 这样的方法定位资源的方式还是使用的 DefaultResourceLoader。而这个 DefaultResourceLoader 实现的是 ResourceLoader 接口：
public interface ResourceLoader { /** Pseudo URL prefix for loading from the class path: &amp;#34;classpath:&amp;#34; */ String CLASSPATH_URL_PREFIX = ResourceUtils.</description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<blockquote>
<p>简单来说 IoC 容器的初始化是由 refresh() 方法启动的，这个方法标志着 IoC 容器正式启动。具体来说这个启动包括 BeanDefinition 的 Resource 定位、载入和注册三个基本过程。</p>
</blockquote>
<p>关于这段话我首先不能理解的就是无缘无故出来的这个BeanDefinition，我在浏览这些源码的时候也没看到。因此，为了好好了解 Spring IoC，我还需要进一步查看内部源码和解释。</p>
<h1 id="what-is-beandefinition">What is BeanDefinition?</h1>
<blockquote>
<p>对 IoC 来说，BeanDefinition 就是对依赖反转模式中管理的对象依赖关系的数据抽象。<br>
Spring 通过定义 BeanDefinition 来管理基于 Spring 的应用中的各种对象以及它们之间的相互依赖关系。BeanDefinition 抽象了我们对 Bean 的定义，是让容器起作用的主要数据类型。</p>
</blockquote>
<p>我的理解 BeanDefinition 有点像 Bean 的元数据，又有点像抽象类，又有点像 schema。</p>
<h1 id="resource-location-of-beandefinition">Resource location of BeanDefinition</h1>
<p><img src="http://odzz59auo.bkt.clouddn.com/ClassPathXmlApplicationContext.png" alt="ClassPathXmlApplicationContext"></p>
<p>再次拿出来这幅图来讲一下，像 ClassPathXmlApplicationContext 这样的方法定位资源的方式还是使用的 DefaultResourceLoader。而这个 DefaultResourceLoader 实现的是 ResourceLoader 接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ResourceLoader</span> <span style="color:#f92672">{</span>

	<span style="color:#75715e">/** Pseudo URL prefix for loading from the class path: &#34;classpath:&#34; */</span>
	String CLASSPATH_URL_PREFIX <span style="color:#f92672">=</span> ResourceUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">CLASSPATH_URL_PREFIX</span><span style="color:#f92672">;</span>


	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Return a Resource handle for the specified resource.
</span><span style="color:#75715e">	 * The handle should always be a reusable resource descriptor,
</span><span style="color:#75715e">	 * allowing for multiple {@link Resource#getInputStream()} calls.
</span><span style="color:#75715e">	 * &lt;p&gt;&lt;ul&gt;
</span><span style="color:#75715e">	 * &lt;li&gt;Must support fully qualified URLs, e.g. &#34;file:C:/test.dat&#34;.
</span><span style="color:#75715e">	 * &lt;li&gt;Must support classpath pseudo-URLs, e.g. &#34;classpath:test.dat&#34;.
</span><span style="color:#75715e">	 * &lt;li&gt;Should support relative file paths, e.g. &#34;WEB-INF/test.dat&#34;.
</span><span style="color:#75715e">	 * (This will be implementation-specific, typically provided by an
</span><span style="color:#75715e">	 * ApplicationContext implementation.)
</span><span style="color:#75715e">	 * &lt;/ul&gt;
</span><span style="color:#75715e">	 * &lt;p&gt;Note that a Resource handle does not imply an existing resource;
</span><span style="color:#75715e">	 * you need to invoke {@link Resource#exists} to check for existence.
</span><span style="color:#75715e">	 * @param location the resource location
</span><span style="color:#75715e">	 * @return a corresponding Resource handle
</span><span style="color:#75715e">	 * @see #CLASSPATH_URL_PREFIX
</span><span style="color:#75715e">	 * @see org.springframework.core.io.Resource#exists
</span><span style="color:#75715e">	 * @see org.springframework.core.io.Resource#getInputStream
</span><span style="color:#75715e">	 */</span>
	Resource <span style="color:#a6e22e">getResource</span><span style="color:#f92672">(</span>String location<span style="color:#f92672">);</span>

	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Expose the ClassLoader used by this ResourceLoader.
</span><span style="color:#75715e">	 * &lt;p&gt;Clients which need to access the ClassLoader directly can do so
</span><span style="color:#75715e">	 * in a uniform manner with the ResourceLoader, rather than relying
</span><span style="color:#75715e">	 * on the thread context ClassLoader.
</span><span style="color:#75715e">	 * @return the ClassLoader (only {@code null} if even the system
</span><span style="color:#75715e">	 * ClassLoader isn&#39;t accessible)
</span><span style="color:#75715e">	 * @see org.springframework.util.ClassUtils#getDefaultClassLoader()
</span><span style="color:#75715e">	 */</span>
	ClassLoader <span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">();</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>其中 CLASSPATH_URL_PREFIX 就是 &ldquo;classpath:&quot;：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String CLASSPATH_URL_PREFIX <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;classpath:&#34;</span><span style="color:#f92672">;</span>
</code></pre></div><p>在 DefaultResourceLoader 中 getClassLoader 的实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Return the ClassLoader to load class path resources with.
</span><span style="color:#75715e">	 * &lt;p&gt;Will get passed to ClassPathResource&#39;s constructor for all
</span><span style="color:#75715e">	 * ClassPathResource objects created by this resource loader.
</span><span style="color:#75715e">	 * @see ClassPathResource
</span><span style="color:#75715e">	 */</span>
	<span style="color:#a6e22e">@Override</span>
	<span style="color:#66d9ef">public</span> ClassLoader <span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">classLoader</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">classLoader</span> <span style="color:#f92672">:</span> ClassUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">getDefaultClassLoader</span><span style="color:#f92672">());</span>
	<span style="color:#f92672">}</span>
</code></pre></div><p>其中，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Return the default ClassLoader to use: typically the thread context
</span><span style="color:#75715e"> * ClassLoader, if available; the ClassLoader that loaded the ClassUtils
</span><span style="color:#75715e"> * class will be used as fallback.
</span><span style="color:#75715e"> * &lt;p&gt;Call this method if you intend to use the thread context ClassLoader
</span><span style="color:#75715e"> * in a scenario where you clearly prefer a non-null ClassLoader reference:
</span><span style="color:#75715e"> * for example, for class path resource loading (but not necessarily for
</span><span style="color:#75715e"> * {@code Class.forName}, which accepts a {@code null} ClassLoader
</span><span style="color:#75715e"> * reference as well).
</span><span style="color:#75715e"> * @return the default ClassLoader (only {@code null} if even the system
</span><span style="color:#75715e"> * ClassLoader isn&#39;t accessible)
</span><span style="color:#75715e"> * @see Thread#getContextClassLoader()
</span><span style="color:#75715e"> * @see ClassLoader#getSystemClassLoader()
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ClassLoader <span style="color:#a6e22e">getDefaultClassLoader</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  ClassLoader cl <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
  <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
    cl <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getContextClassLoader</span><span style="color:#f92672">();</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Cannot access thread context ClassLoader - falling back...
</span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cl <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// No thread context class loader -&gt; use class loader of this class.
</span><span style="color:#75715e"></span>    cl <span style="color:#f92672">=</span> ClassUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getClassLoader</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cl <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">// getClassLoader() returning null indicates the bootstrap ClassLoader
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        cl <span style="color:#f92672">=</span> ClassLoader<span style="color:#f92672">.</span><span style="color:#a6e22e">getSystemClassLoader</span><span style="color:#f92672">();</span>
      <span style="color:#f92672">}</span>
      <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Throwable ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// Cannot access system ClassLoader - oh well, maybe the caller can live with null...
</span><span style="color:#75715e"></span>      <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">return</span> cl<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里就要讲讲了：</p>
<ul>
<li>首先如果当前线程的 ClassLoader 不为空，那么就返回当前 ClassLoader；</li>
<li>如果没有获取到，获取 ClassUtils 的 ClassLoader；</li>
<li>如果还没有获取到，则调用 ClassLoader 获取系统 ClassLoader</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@CallerSensitive</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ClassLoader <span style="color:#a6e22e">getSystemClassLoader</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        initSystemClassLoader<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>scl <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        SecurityManager sm <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">getSecurityManager</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>sm <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            checkClassLoaderPermission<span style="color:#f92672">(</span>scl<span style="color:#f92672">,</span> Reflection<span style="color:#f92672">.</span><span style="color:#a6e22e">getCallerClass</span><span style="color:#f92672">());</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> scl<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>这个就有点复杂了，大致意思应该就是获取系统调用的 ClassLoader。</p>
<p>那么，ClassPathXmlApplicationContext 是如何获取资源的呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Create a new ClassPathXmlApplicationContext with the given parent,
</span><span style="color:#75715e">	 * loading the definitions from the given XML files.
</span><span style="color:#75715e">	 * @param configLocations array of resource locations
</span><span style="color:#75715e">	 * @param refresh whether to automatically refresh the context,
</span><span style="color:#75715e">	 * loading all bean definitions and creating all singletons.
</span><span style="color:#75715e">	 * Alternatively, call refresh manually after further configuring the context.
</span><span style="color:#75715e">	 * @param parent the parent context
</span><span style="color:#75715e">	 * @throws BeansException if context creation failed
</span><span style="color:#75715e">	 * @see #refresh()
</span><span style="color:#75715e">	 */</span>
	<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ClassPathXmlApplicationContext</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> configLocations<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> refresh<span style="color:#f92672">,</span> ApplicationContext parent<span style="color:#f92672">)</span>
			<span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>

		<span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>parent<span style="color:#f92672">);</span>
		setConfigLocations<span style="color:#f92672">(</span>configLocations<span style="color:#f92672">);</span>
		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>refresh<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
			refresh<span style="color:#f92672">();</span>
		<span style="color:#f92672">}</span>
	<span style="color:#f92672">}</span>

</code></pre></div><p>AbstractApplicationContext 中对继承的这个构造方法有了具体的说明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Create a new AbstractApplicationContext with no parent.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AbstractApplicationContext</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">resourcePatternResolver</span> <span style="color:#f92672">=</span> getResourcePatternResolver<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Create a new AbstractApplicationContext with the given parent context.
</span><span style="color:#75715e"> * @param parent the parent context
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AbstractApplicationContext</span><span style="color:#f92672">(</span>ApplicationContext parent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">this</span><span style="color:#f92672">();</span>
  setParent<span style="color:#f92672">(</span>parent<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * {@inheritDoc}
</span><span style="color:#75715e"> * &lt;p&gt;The parent {@linkplain ApplicationContext#getEnvironment() environment} is
</span><span style="color:#75715e"> * {@linkplain ConfigurableEnvironment#merge(ConfigurableEnvironment) merged} with
</span><span style="color:#75715e"> * this (child) application context environment if the parent is non-{@code null} and
</span><span style="color:#75715e"> * its environment is an instance of {@link ConfigurableEnvironment}.
</span><span style="color:#75715e"> * @see ConfigurableEnvironment#merge(ConfigurableEnvironment)
</span><span style="color:#75715e"> */</span>
<span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setParent</span><span style="color:#f92672">(</span>ApplicationContext parent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">parent</span> <span style="color:#f92672">=</span> parent<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>parent <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Environment parentEnvironment <span style="color:#f92672">=</span> parent<span style="color:#f92672">.</span><span style="color:#a6e22e">getEnvironment</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>parentEnvironment <span style="color:#66d9ef">instanceof</span> ConfigurableEnvironment<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      getEnvironment<span style="color:#f92672">().</span><span style="color:#a6e22e">merge</span><span style="color:#f92672">((</span>ConfigurableEnvironment<span style="color:#f92672">)</span> parentEnvironment<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>由此，我们可以看出，创建一个新的 ApplicationContext 的时候，先要定义一下资源模式解析器，设置父类；然后设置配置文件地址，最后还需要 refresh 一下，载入 BeanDefinition。</p>
<blockquote>
<p>通过 IoC 容器的初始化的 refresh 来启动整个调用，使用的 IoC 容器是 DefaultListableBeanFactory。</p>
</blockquote>
<p>虽然这么说，我其实没看出来。这里只能先留下来，等着今后再深入的时候进行。</p>
<h1 id="postscript">Postscript</h1>
<p>写到这里其实发现 要想搞透 Spring 还是挺难的，不能一下子全部消化，我还需一步一步来，慢慢深入。</p>
<h1 id="references">References</h1>
<p>Spring 技术内幕</p>
]]></content>
        </item>
        
        <item>
            <title>Emacs Tutorials</title>
            <link>http://keltoy.github.io/posts/emacs-tutorials/</link>
            <pubDate>Sun, 06 Nov 2016 23:20:48 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/emacs-tutorials/</guid>
            <description>Preface 笔记本上的东西还是要放到网上的，当作一个备份了。一开始学习 emacs 的时候有很多坑要踩，现在好了，基本适应了，以后多用用应该问题不大了。
Emacs    标记 代表按键     C- Control   S- Shift   M- Alt(Option) ／ ESC   RET Return   SPC Space   DEL Backspace(Delete)    总的来说，无论是装逼需要，还是提高效率，Emacs 的学习我个人认为还是挺有用的，慢慢习惯了这个方式之后，其实会发现，想问题的思路被打开了。
几个简单的指令，也是最常用的
   指令 命令名称 说明     M-x execute-extended-command 执行命令   C-u (#)/M-(#) key  重复#次 key   C-g keyboard-quit 停止当前输入   C-x u undo 撤销命令   S-u revert-buffer 撤销上次保存后的所有改动    recover-file 从自动保存文件中恢复    recover-session 恢复此次会话所有文件   &amp;lt;f10&amp;gt; menu-bar-open 打开菜单栏    Help    指令 命令名称 说明     C-h ?</description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<p>笔记本上的东西还是要放到网上的，当作一个备份了。一开始学习 emacs 的时候有很多坑要踩，现在好了，基本适应了，以后多用用应该问题不大了。</p>
<h1 id="emacs">Emacs</h1>
<table>
<thead>
<tr>
<th style="text-align:center">标记</th>
<th style="text-align:center">代表按键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-</td>
<td style="text-align:center">Control</td>
</tr>
<tr>
<td style="text-align:center">S-</td>
<td style="text-align:center">Shift</td>
</tr>
<tr>
<td style="text-align:center">M-</td>
<td style="text-align:center">Alt(Option) ／ ESC</td>
</tr>
<tr>
<td style="text-align:center">RET</td>
<td style="text-align:center">Return</td>
</tr>
<tr>
<td style="text-align:center">SPC</td>
<td style="text-align:center">Space</td>
</tr>
<tr>
<td style="text-align:center">DEL</td>
<td style="text-align:center">Backspace(Delete)</td>
</tr>
</tbody>
</table>
<p>总的来说，无论是装逼需要，还是提高效率，Emacs 的学习我个人认为还是挺有用的，慢慢习惯了这个方式之后，其实会发现，想问题的思路被打开了。</p>
<p>几个简单的指令，也是最常用的</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M-x</td>
<td style="text-align:center">execute-extended-command</td>
<td style="text-align:center">执行命令</td>
</tr>
<tr>
<td style="text-align:center">C-u (#)/M-(#) key</td>
<td style="text-align:center"></td>
<td style="text-align:center">重复#次 key</td>
</tr>
<tr>
<td style="text-align:center">C-g</td>
<td style="text-align:center">keyboard-quit</td>
<td style="text-align:center">停止当前输入</td>
</tr>
<tr>
<td style="text-align:center">C-x u</td>
<td style="text-align:center">undo</td>
<td style="text-align:center">撤销命令</td>
</tr>
<tr>
<td style="text-align:center">S-u</td>
<td style="text-align:center">revert-buffer</td>
<td style="text-align:center">撤销上次保存后的所有改动</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">recover-file</td>
<td style="text-align:center">从自动保存文件中恢复</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">recover-session</td>
<td style="text-align:center">恢复此次会话所有文件</td>
</tr>
<tr>
<td style="text-align:center">&lt;f10&gt;</td>
<td style="text-align:center">menu-bar-open</td>
<td style="text-align:center">打开菜单栏</td>
</tr>
</tbody>
</table>
<h2 id="help">Help</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-h ?</td>
<td style="text-align:center">help-for-help</td>
<td style="text-align:center">如何使用帮助，SPC和DEL滚动，ESC退出</td>
</tr>
<tr>
<td style="text-align:center">C-h t</td>
<td style="text-align:center">help-withtutorial</td>
<td style="text-align:center">快速指南</td>
</tr>
<tr>
<td style="text-align:center">C-h r</td>
<td style="text-align:center">info-emacs-manual</td>
<td style="text-align:center">使用手册</td>
</tr>
<tr>
<td style="text-align:center">C-h i / S-?</td>
<td style="text-align:center">info</td>
<td style="text-align:center">说明</td>
</tr>
<tr>
<td style="text-align:center">C-h a</td>
<td style="text-align:center">apropos-command</td>
<td style="text-align:center">(模糊)搜索指令</td>
</tr>
<tr>
<td style="text-align:center">C-h v</td>
<td style="text-align:center">describe-variable</td>
<td style="text-align:center">查看变量说明</td>
</tr>
<tr>
<td style="text-align:center">C-h f</td>
<td style="text-align:center">describe-function</td>
<td style="text-align:center">查看函数说明</td>
</tr>
<tr>
<td style="text-align:center">C-h m</td>
<td style="text-align:center">describe-mode</td>
<td style="text-align:center">当前mode相关文档</td>
</tr>
<tr>
<td style="text-align:center">C-h k KEYS</td>
<td style="text-align:center">describe-key KEYS</td>
<td style="text-align:center">查看KEYS对应的命令</td>
</tr>
<tr>
<td style="text-align:center">C-h c KEYS</td>
<td style="text-align:center">describe-key-briefly KEYS</td>
<td style="text-align:center">查看KEYS简要说明</td>
</tr>
<tr>
<td style="text-align:center">C-h w</td>
<td style="text-align:center">where-is</td>
<td style="text-align:center">查看命令对应的快捷键</td>
</tr>
<tr>
<td style="text-align:center">C-h b</td>
<td style="text-align:center">describe-bindings</td>
<td style="text-align:center">当前buffer 的所有快捷键</td>
</tr>
<tr>
<td style="text-align:center">KEYS c-h</td>
<td style="text-align:center"></td>
<td style="text-align:center">以KEYS开头的快捷键列表</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">apropos</td>
<td style="text-align:center">查找相关函数，命令，变量，模式等</td>
</tr>
<tr>
<td style="text-align:center">C-h i</td>
<td style="text-align:center">describe-input-method</td>
<td style="text-align:center">查看输入方法</td>
</tr>
</tbody>
</table>
<h2 id="file">File</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-x C-f</td>
<td style="text-align:center">find-file</td>
<td style="text-align:center">打开文件或者目录</td>
</tr>
<tr>
<td style="text-align:center">C-x C-c</td>
<td style="text-align:center">save-buffers-kill-emacs</td>
<td style="text-align:center">保存退出</td>
</tr>
<tr>
<td style="text-align:center">C-x C-z</td>
<td style="text-align:center">suspend-frame</td>
<td style="text-align:center">挂起（最小化）</td>
</tr>
<tr>
<td style="text-align:center">C-x i</td>
<td style="text-align:center">insert-file</td>
<td style="text-align:center">当前光标处插入文件</td>
</tr>
<tr>
<td style="text-align:center">C-x C-v</td>
<td style="text-align:center">find-alternate-file</td>
<td style="text-align:center">关闭当前buffer并打开新文件</td>
</tr>
<tr>
<td style="text-align:center">C-x C-s</td>
<td style="text-align:center">save-buffer</td>
<td style="text-align:center">保存</td>
</tr>
<tr>
<td style="text-align:center">C-x C-w</td>
<td style="text-align:center">write-file</td>
<td style="text-align:center">另存为</td>
</tr>
<tr>
<td style="text-align:center">C-x RET r</td>
<td style="text-align:center">revert-buffer-file-coding-system</td>
<td style="text-align:center">以指定编码读取文件</td>
</tr>
<tr>
<td style="text-align:center">C-x RET f</td>
<td style="text-align:center">set-buffer-file-coding-system</td>
<td style="text-align:center">以指定编码保存文件</td>
</tr>
<tr>
<td style="text-align:center">C-x d</td>
<td style="text-align:center">dired</td>
<td style="text-align:center">进入目录列表模式</td>
</tr>
<tr>
<td style="text-align:center">C-x C-d</td>
<td style="text-align:center">list-directory</td>
<td style="text-align:center">获取文件列表（简洁）</td>
</tr>
</tbody>
</table>
<h2 id="cursor">Cursor</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-f</td>
<td style="text-align:center">forward-char</td>
<td style="text-align:center">字符前进</td>
</tr>
<tr>
<td style="text-align:center">C-b</td>
<td style="text-align:center">backward-char</td>
<td style="text-align:center">字符后退</td>
</tr>
<tr>
<td style="text-align:center">M-f</td>
<td style="text-align:center">forward-word</td>
<td style="text-align:center">单词前进</td>
</tr>
<tr>
<td style="text-align:center">M-b</td>
<td style="text-align:center">backward-word</td>
<td style="text-align:center">单词后退</td>
</tr>
<tr>
<td style="text-align:center">M-e</td>
<td style="text-align:center">forward-sentence</td>
<td style="text-align:center">句子前进</td>
</tr>
<tr>
<td style="text-align:center">M-a</td>
<td style="text-align:center">backward-sentence</td>
<td style="text-align:center">句子后退</td>
</tr>
<tr>
<td style="text-align:center">C-a</td>
<td style="text-align:center">move-beginning-of-line</td>
<td style="text-align:center">移动到行首</td>
</tr>
<tr>
<td style="text-align:center">C-e</td>
<td style="text-align:center">move-end-of-line</td>
<td style="text-align:center">移动到行尾</td>
</tr>
<tr>
<td style="text-align:center">M-}</td>
<td style="text-align:center">forward-paragraph</td>
<td style="text-align:center">移动到段尾</td>
</tr>
<tr>
<td style="text-align:center">M-{</td>
<td style="text-align:center">backward-paragraph</td>
<td style="text-align:center">移动到段首</td>
</tr>
<tr>
<td style="text-align:center">M-&lt;</td>
<td style="text-align:center">beginning-of-buffer</td>
<td style="text-align:center">buffer首</td>
</tr>
<tr>
<td style="text-align:center">M-&gt;</td>
<td style="text-align:center">end-of-buffer</td>
<td style="text-align:center">buffer尾</td>
</tr>
<tr>
<td style="text-align:center">C-p</td>
<td style="text-align:center">previous-line</td>
<td style="text-align:center">上一行</td>
</tr>
<tr>
<td style="text-align:center">C-n</td>
<td style="text-align:center">next-line</td>
<td style="text-align:center">下一行</td>
</tr>
<tr>
<td style="text-align:center">M-v</td>
<td style="text-align:center">scroll-down-command</td>
<td style="text-align:center">下翻页</td>
</tr>
<tr>
<td style="text-align:center">C-v</td>
<td style="text-align:center">scroll-up-command</td>
<td style="text-align:center">上翻页</td>
</tr>
<tr>
<td style="text-align:center">M-g M-g</td>
<td style="text-align:center">goto-line</td>
<td style="text-align:center">跳转到指定行</td>
</tr>
<tr>
<td style="text-align:center">C-M-l</td>
<td style="text-align:center">reposition-window</td>
<td style="text-align:center">当前行到页面顶端／中间</td>
</tr>
<tr>
<td style="text-align:center">C-M-o</td>
<td style="text-align:center">split-line</td>
<td style="text-align:center">切割行</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">recenter</td>
<td style="text-align:center">到当前页面中间行</td>
</tr>
</tbody>
</table>
<h2 id="cut-del-copy-and-paste">Cut, Del, Copy and Paste</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-d</td>
<td style="text-align:center">delete-char</td>
<td style="text-align:center">删除字符</td>
</tr>
<tr>
<td style="text-align:center">DEL</td>
<td style="text-align:center">backward-delete-char-untabify</td>
<td style="text-align:center">后退删除</td>
</tr>
<tr>
<td style="text-align:center">M-d</td>
<td style="text-align:center">kill-word</td>
<td style="text-align:center">从光标处删除词</td>
</tr>
<tr>
<td style="text-align:center">M-DEL</td>
<td style="text-align:center">backward-kill-word</td>
<td style="text-align:center">删除词首到光标处</td>
</tr>
<tr>
<td style="text-align:center">C-k</td>
<td style="text-align:center">kill-line</td>
<td style="text-align:center">删除行</td>
</tr>
<tr>
<td style="text-align:center">M-k</td>
<td style="text-align:center">kill-sentence</td>
<td style="text-align:center">删除句子</td>
</tr>
<tr>
<td style="text-align:center">C-S-Backspace</td>
<td style="text-align:center">kill-whole-line</td>
<td style="text-align:center">删除整行（目前还没有找到Backspace）</td>
</tr>
<tr>
<td style="text-align:center">C-@</td>
<td style="text-align:center">set-mark-command</td>
<td style="text-align:center">选中区域</td>
</tr>
<tr>
<td style="text-align:center">C-x C-x</td>
<td style="text-align:center">exchange-point-and-mark</td>
<td style="text-align:center">交换 mark 点</td>
</tr>
<tr>
<td style="text-align:center">C-w</td>
<td style="text-align:center">kill-region</td>
<td style="text-align:center">剪切</td>
</tr>
<tr>
<td style="text-align:center">M-w</td>
<td style="text-align:center">kill-ring-save</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">C-y</td>
<td style="text-align:center">yank</td>
<td style="text-align:center">粘贴</td>
</tr>
<tr>
<td style="text-align:center">M-y</td>
<td style="text-align:center">yank-pop</td>
<td style="text-align:center">粘贴更早内容</td>
</tr>
<tr>
<td style="text-align:center">C-x r k</td>
<td style="text-align:center">kill-rectangle</td>
<td style="text-align:center">列模式剪切</td>
</tr>
<tr>
<td style="text-align:center">C-x r y</td>
<td style="text-align:center">yank-rectangle</td>
<td style="text-align:center">列模式粘贴</td>
</tr>
<tr>
<td style="text-align:center">C-x r o</td>
<td style="text-align:center">open-rectangle</td>
<td style="text-align:center">列模式插入</td>
</tr>
<tr>
<td style="text-align:center">C-x r c</td>
<td style="text-align:center">clear-rectangle</td>
<td style="text-align:center">列模式清空，变空白</td>
</tr>
<tr>
<td style="text-align:center">C-x r t</td>
<td style="text-align:center">string-rectangle</td>
<td style="text-align:center">列模式填充</td>
</tr>
<tr>
<td style="text-align:center">C-x r d</td>
<td style="text-align:center">delete-rectangle</td>
<td style="text-align:center">列模式删除</td>
</tr>
</tbody>
</table>
<h2 id="buffer">Buffer</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-x C-b</td>
<td style="text-align:center">list-buffers</td>
<td style="text-align:center">查看 buffer</td>
</tr>
<tr>
<td style="text-align:center">C-x b</td>
<td style="text-align:center">switch-to-buffer</td>
<td style="text-align:center">切换／新建 buffer</td>
</tr>
<tr>
<td style="text-align:center">C-x LEFT/Right</td>
<td style="text-align:center">previous-buffer/next-buffer</td>
<td style="text-align:center">切换 buffer</td>
</tr>
<tr>
<td style="text-align:center">C-x k</td>
<td style="text-align:center">kill-buffer</td>
<td style="text-align:center">关闭 buffer</td>
</tr>
<tr>
<td style="text-align:center">C-x s</td>
<td style="text-align:center">save-some-buffers</td>
<td style="text-align:center">保存所有 buffer</td>
</tr>
</tbody>
</table>
<h2 id="window">window</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-x 2</td>
<td style="text-align:center">split-window-below</td>
<td style="text-align:center">水平分割</td>
</tr>
<tr>
<td style="text-align:center">C-x 3</td>
<td style="text-align:center">split-window-right</td>
<td style="text-align:center">竖直分割</td>
</tr>
<tr>
<td style="text-align:center">C-x 1</td>
<td style="text-align:center">delete-other-windows</td>
<td style="text-align:center">关闭其他所有 window</td>
</tr>
<tr>
<td style="text-align:center">C-x 0</td>
<td style="text-align:center">delete-window</td>
<td style="text-align:center">关闭当前 window</td>
</tr>
<tr>
<td style="text-align:center">C-x o</td>
<td style="text-align:center">other-window</td>
<td style="text-align:center">切换 window</td>
</tr>
<tr>
<td style="text-align:center">C-M-v</td>
<td style="text-align:center">scroll-other-window</td>
<td style="text-align:center">滚动其他 windown</td>
</tr>
<tr>
<td style="text-align:center">C-x ^</td>
<td style="text-align:center">enlarge-window</td>
<td style="text-align:center">扩大 window</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">shrink-window</td>
<td style="text-align:center">缩小 window</td>
</tr>
<tr>
<td style="text-align:center">C-x 4 f</td>
<td style="text-align:center">find-file-other-window</td>
<td style="text-align:center">在其他 window 中打开文件</td>
</tr>
<tr>
<td style="text-align:center">C-x 4 0</td>
<td style="text-align:center">kill-buffer-and-window</td>
<td style="text-align:center">关闭当前 buffer 和 window</td>
</tr>
<tr>
<td style="text-align:center">C-x 5 2</td>
<td style="text-align:center">make-frame-command</td>
<td style="text-align:center">新建 frame</td>
</tr>
<tr>
<td style="text-align:center">C-x 5 f</td>
<td style="text-align:center">find-file-other-frame</td>
<td style="text-align:center">在其他 frame中打开文件</td>
</tr>
<tr>
<td style="text-align:center">C-x 5 o</td>
<td style="text-align:center">other-frame</td>
<td style="text-align:center">切换其他 frame</td>
</tr>
<tr>
<td style="text-align:center">C-x 5 o</td>
<td style="text-align:center">delete-frame</td>
<td style="text-align:center">关闭当前 frame</td>
</tr>
</tbody>
</table>
<h2 id="undo-redo">Undo, Redo</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-/</td>
<td style="text-align:center">undo</td>
<td style="text-align:center">撤销一次</td>
</tr>
<tr>
<td style="text-align:center">C-_</td>
<td style="text-align:center">undo</td>
<td style="text-align:center">撤销一次</td>
</tr>
</tbody>
</table>
<h2 id="search-replace">Search, Replace</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C-s</td>
<td style="text-align:center">isearch-forward</td>
<td style="text-align:center">向前搜索</td>
</tr>
<tr>
<td style="text-align:center">C-M-s</td>
<td style="text-align:center">isearch-forward-regexp</td>
<td style="text-align:center">向前正则搜索</td>
</tr>
<tr>
<td style="text-align:center">C-r</td>
<td style="text-align:center">isearch-backword</td>
<td style="text-align:center">向后搜索</td>
</tr>
<tr>
<td style="text-align:center">C-M-r</td>
<td style="text-align:center">isearch-backward-regexp</td>
<td style="text-align:center">向后正则搜索</td>
</tr>
<tr>
<td style="text-align:center">M-%</td>
<td style="text-align:center">query-replace</td>
<td style="text-align:center">替换（SPC,DEL 控制）</td>
</tr>
<tr>
<td style="text-align:center">C-M-%</td>
<td style="text-align:center">query-replace-regexp</td>
<td style="text-align:center">正则替换</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">查找指令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">行首</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">行尾</td>
</tr>
<tr>
<td style="text-align:center">\&lt;</td>
<td style="text-align:center">词首</td>
</tr>
<tr>
<td style="text-align:center">\&gt;</td>
<td style="text-align:center">词尾</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">替换指令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">仅替换当前匹配并退出</td>
</tr>
<tr>
<td style="text-align:center">,</td>
<td style="text-align:center">替换，暂停</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">替换以下所有匹配</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">回到上一个匹配</td>
</tr>
<tr>
<td style="text-align:center">RET/q</td>
<td style="text-align:center">退出</td>
</tr>
</tbody>
</table>
<h2 id="other">Other</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">命令名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M-c</td>
<td style="text-align:center"></td>
<td style="text-align:center">字母大写</td>
</tr>
<tr>
<td style="text-align:center">M-! cmd</td>
<td style="text-align:center"></td>
<td style="text-align:center">执行cmd shell指令</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">shell</td>
<td style="text-align:center">打开 shell</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">term</td>
<td style="text-align:center">执行shell</td>
</tr>
</tbody>
</table>
]]></content>
        </item>
        
        <item>
            <title>Source Code in Java -- Spring IoC</title>
            <link>http://keltoy.github.io/posts/source-code-in-java-spring-ioc/</link>
            <pubDate>Wed, 02 Nov 2016 23:46:46 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/source-code-in-java-spring-ioc/</guid>
            <description>Preface Spring 的源码在网上基本上都被研究透了，我之前的理解实际上也是基于书本和基于一些项目。既然是阅读源码，那么 Spring 的源码是不得不看的。
Spring IoC 设计 网上找的一张图，和书上的一样，先拿过来用了：
挺多的，但是不复杂，从名字就可以看出来每个类或者接口。
 这个接口系统是以 BeanFactory 和 ApplicationContext 为核心的。
 因此主要也是介绍这两个接口。
BeanFactory  提供的是最基本的 IoC 容器功能 可以使用转义符“&amp;amp;”获取FactoryBean 设计的 getBean 方法是使用 IoC 容器的主要方法。  对于这个转义符，我没弄明白，书上是这么介绍的：
 用户使用容器时，可以使用转义符“&amp;amp;”来得到 FactoryBean 本身，用来区分通过容器来获取 FactoryBean 产生的对象和获取 FacoryBean 产生的对象和获取 FactoryBean 本身。
 简单来说，就是加上“&amp;amp;”之后获取的是 FactoryBean，而不是 FactoryBean 产生的对象。
需要注意的是 BeanFactory 是 IoC容器或者对象工厂，FactoryBean 是 Bean。
public interface BeanFactory { /** * Used to dereference a {@link FactoryBean} instance and distinguish it from * beans &amp;lt;i&amp;gt;created&amp;lt;/i&amp;gt; by the FactoryBean.</description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<p>Spring 的源码在网上基本上都被研究透了，我之前的理解实际上也是基于书本和基于一些项目。既然是阅读源码，那么 Spring 的源码是不得不看的。</p>
<h1 id="spring-ioc-设计">Spring IoC 设计</h1>
<p>网上找的一张图，和书上的一样，先拿过来用了：</p>
<p><img src="http://odzz59auo.bkt.clouddn.com/Spring.png" alt="Spring IoC 容器"></p>
<p>挺多的，但是不复杂，从名字就可以看出来每个类或者接口。</p>
<blockquote>
<p>这个接口系统是以 BeanFactory 和 ApplicationContext 为核心的。</p>
</blockquote>
<p>因此主要也是介绍这两个接口。</p>
<h2 id="beanfactory">BeanFactory</h2>
<ul>
<li>提供的是最基本的 IoC 容器功能</li>
<li>可以使用转义符“&amp;”获取FactoryBean</li>
<li>设计的 getBean 方法是使用 IoC 容器的主要方法。</li>
</ul>
<p>对于这个转义符，我没弄明白，书上是这么介绍的：</p>
<blockquote>
<p>用户使用容器时，可以使用转义符“&amp;”来得到 FactoryBean 本身，用来区分通过容器来获取 FactoryBean 产生的对象和获取 FacoryBean 产生的对象和获取 FactoryBean 本身。</p>
</blockquote>
<p>简单来说，就是加上“&amp;”之后获取的是 FactoryBean，而不是 FactoryBean 产生的对象。</p>
<p>需要注意的是 BeanFactory 是 IoC容器或者对象工厂，FactoryBean 是 Bean。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">BeanFactory</span> <span style="color:#f92672">{</span>

	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Used to dereference a {@link FactoryBean} instance and distinguish it from
</span><span style="color:#75715e">	 * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named
</span><span style="color:#75715e">	 * {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject}
</span><span style="color:#75715e">	 * will return the factory, not the instance returned by the factory.
</span><span style="color:#75715e">	 */</span>
	String FACTORY_BEAN_PREFIX <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&amp;&#34;</span><span style="color:#f92672">;</span>


	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Return an instance, which may be shared or independent, of the specified bean.
</span><span style="color:#75715e">	 * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the
</span><span style="color:#75715e">	 * Singleton or Prototype design pattern. Callers may retain references to
</span><span style="color:#75715e">	 * returned objects in the case of Singleton beans.
</span><span style="color:#75715e">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.
</span><span style="color:#75715e">	 * Will ask the parent factory if the bean cannot be found in this factory instance.
</span><span style="color:#75715e">	 * @param name the name of the bean to retrieve
</span><span style="color:#75715e">	 * @return an instance of the bean
</span><span style="color:#75715e">	 * @throws NoSuchBeanDefinitionException if there is no bean definition
</span><span style="color:#75715e">	 * with the specified name
</span><span style="color:#75715e">	 * @throws BeansException if the bean could not be obtained
</span><span style="color:#75715e">	 */</span>
	Object <span style="color:#a6e22e">getBean</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> BeansException<span style="color:#f92672">;</span>

	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Return an instance, which may be shared or independent, of the specified bean.
</span><span style="color:#75715e">	 * &lt;p&gt;Behaves the same as {@link #getBean(String)}, but provides a measure of type
</span><span style="color:#75715e">	 * safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the
</span><span style="color:#75715e">	 * required type. This means that ClassCastException can&#39;t be thrown on casting
</span><span style="color:#75715e">	 * the result correctly, as can happen with {@link #getBean(String)}.
</span><span style="color:#75715e">	 * &lt;p&gt;Translates aliases back to the corresponding canonical bean name.
</span><span style="color:#75715e">	 * Will ask the parent factory if the bean cannot be found in this factory instance.
</span><span style="color:#75715e">	 * @param name the name of the bean to retrieve
</span><span style="color:#75715e">	 * @param requiredType type the bean must match. Can be an interface or superclass
</span><span style="color:#75715e">	 * of the actual class, or {@code null} for any match. For example, if the value
</span><span style="color:#75715e">	 * is {@code Object.class}, this method will succeed whatever the class of the
</span><span style="color:#75715e">	 * returned instance.
</span><span style="color:#75715e">	 * @return an instance of the bean
</span><span style="color:#75715e">	 * @throws NoSuchBeanDefinitionException if there is no such bean definition
</span><span style="color:#75715e">	 * @throws BeanNotOfRequiredTypeException if the bean is not of the required type
</span><span style="color:#75715e">	 * @throws BeansException if the bean could not be created
</span><span style="color:#75715e">	 */</span>
	<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> T <span style="color:#a6e22e">getBean</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span> Class<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> requiredType<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> BeansException<span style="color:#f92672">;</span>
  <span style="color:#f92672">...</span>

</code></pre></div><p>这里截取一些源代码，实际上 getBean 还有很多，BeanFactory 只是一个接口，因此只有常量和方法的声明。
然后废话一句，虽然不影响学习，但是 XmlBeanFactory 早已被弃用了。</p>
<h2 id="applicationcontext">ApplicationContext</h2>
<ul>
<li>除了基本功能，还提供附加服务</li>
<li>支持不同的信息源</li>
<li>访问资源</li>
<li>支持应用事件</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Central interface to provide configuration for an application.
</span><span style="color:#75715e"> * This is read-only while the application is running, but may be
</span><span style="color:#75715e"> * reloaded if the implementation supports this.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;p&gt;An ApplicationContext provides:
</span><span style="color:#75715e"> * &lt;ul&gt;
</span><span style="color:#75715e"> * &lt;li&gt;Bean factory methods for accessing application components.
</span><span style="color:#75715e"> * Inherited from {@link org.springframework.beans.factory.ListableBeanFactory}.
</span><span style="color:#75715e"> * &lt;li&gt;The ability to load file resources in a generic fashion.
</span><span style="color:#75715e"> * Inherited from the {@link org.springframework.core.io.ResourceLoader} interface.
</span><span style="color:#75715e"> * &lt;li&gt;The ability to publish events to registered listeners.
</span><span style="color:#75715e"> * Inherited from the {@link ApplicationEventPublisher} interface.
</span><span style="color:#75715e"> * &lt;li&gt;The ability to resolve messages, supporting internationalization.
</span><span style="color:#75715e"> * Inherited from the {@link MessageSource} interface.
</span><span style="color:#75715e"> * &lt;li&gt;Inheritance from a parent context. Definitions in a descendant context
</span><span style="color:#75715e"> * will always take priority. This means, for example, that a single parent
</span><span style="color:#75715e"> * context can be used by an entire web application, while each servlet has
</span><span style="color:#75715e"> * its own child context that is independent of that of any other servlet.
</span><span style="color:#75715e"> * &lt;/ul&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;p&gt;In addition to standard {@link org.springframework.beans.factory.BeanFactory}
</span><span style="color:#75715e"> * lifecycle capabilities, ApplicationContext implementations detect and invoke
</span><span style="color:#75715e"> * {@link ApplicationContextAware} beans as well as {@link ResourceLoaderAware},
</span><span style="color:#75715e"> * {@link ApplicationEventPublisherAware} and {@link MessageSourceAware} beans.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @author Rod Johnson
</span><span style="color:#75715e"> * @author Juergen Hoeller
</span><span style="color:#75715e"> * @see ConfigurableApplicationContext
</span><span style="color:#75715e"> * @see org.springframework.beans.factory.BeanFactory
</span><span style="color:#75715e"> * @see org.springframework.core.io.ResourceLoader
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ApplicationContext</span> <span style="color:#66d9ef">extends</span> EnvironmentCapable<span style="color:#f92672">,</span> ListableBeanFactory<span style="color:#f92672">,</span> HierarchicalBeanFactory<span style="color:#f92672">,</span> MessageSource<span style="color:#f92672">,</span> ApplicationEventPublisher<span style="color:#f92672">,</span> ResourcePatternResolver
</code></pre></div><p>ApplicationContext 也是一个接口，从 extends 的接口就可以看出来，这些附加的信息是基于这些接口来实现的。
MessageSource 支持不同的信息源， ApplicationEventPublisher 支持应用事件，
ResourcePatternResolver 支持访问资源。</p>
<p>注意到该几口还支持 getAutowireCapableBeanFactory()。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	String <span style="color:#a6e22e">getId</span><span style="color:#f92672">();</span>
	String <span style="color:#a6e22e">getApplicationName</span><span style="color:#f92672">();</span>
	String <span style="color:#a6e22e">getDisplayName</span><span style="color:#f92672">();</span>
	<span style="color:#66d9ef">long</span> <span style="color:#a6e22e">getStartupDate</span><span style="color:#f92672">();</span>
	ApplicationContext <span style="color:#a6e22e">getParent</span><span style="color:#f92672">();</span>
	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Expose AutowireCapableBeanFactory functionality for this context.
</span><span style="color:#75715e">	 * &lt;p&gt;This is not typically used by application code, except for the purpose of
</span><span style="color:#75715e">	 * initializing bean instances that live outside of the application context,
</span><span style="color:#75715e">	 * applying the Spring bean lifecycle (fully or partly) to them.
</span><span style="color:#75715e">	 * &lt;p&gt;Alternatively, the internal BeanFactory exposed by the
</span><span style="color:#75715e">	 * {@link ConfigurableApplicationContext} interface offers access to the
</span><span style="color:#75715e">	 * {@link AutowireCapableBeanFactory} interface too. The present method mainly
</span><span style="color:#75715e">	 * serves as a convenient, specific facility on the ApplicationContext interface.
</span><span style="color:#75715e">	 * &lt;p&gt;&lt;b&gt;NOTE: As of 4.2, this method will consistently throw IllegalStateException
</span><span style="color:#75715e">	 * after the application context has been closed.&lt;/b&gt; In current Spring Framework
</span><span style="color:#75715e">	 * versions, only refreshable application contexts behave that way; as of 4.2,
</span><span style="color:#75715e">	 * all application context implementations will be required to comply.
</span><span style="color:#75715e">	 * @return the AutowireCapableBeanFactory for this context
</span><span style="color:#75715e">	 * @throws IllegalStateException if the context does not support the
</span><span style="color:#75715e">	 * {@link AutowireCapableBeanFactory} interface, or does not hold an
</span><span style="color:#75715e">	 * autowire-capable bean factory yet (e.g. if {@code refresh()} has
</span><span style="color:#75715e">	 * never been called), or if the context has been closed already
</span><span style="color:#75715e">	 * @see ConfigurableApplicationContext#refresh()
</span><span style="color:#75715e">	 * @see ConfigurableApplicationContext#getBeanFactory()
</span><span style="color:#75715e">	 */</span>
	AutowireCapableBeanFactory <span style="color:#a6e22e">getAutowireCapableBeanFactory</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IllegalStateException<span style="color:#f92672">;</span>
</code></pre></div><h2 id="classpathxmlapplicationcontext">ClassPathXmlApplicationContext</h2>
<p>测试的时候最常用的就是 ClassPathXmlApplicationContext 这个方法了。 从源代码可以了解到 ClassPathXmlApplicationContext 的关系</p>
<p><img src="http://odzz59auo.bkt.clouddn.com/ClassPathXmlApplicationContext.png" alt="ClassPathXmlApplicationContext"></p>
<p>可以看出，ClassPathXmlApplicationContext 和 ApplicationContext 有关系的。
ClassPathXmlApplicationContext 中有很多构造方法，但实际上调用的只有两个，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Create a new ClassPathXmlApplicationContext with the given parent,
</span><span style="color:#75715e"> * loading the definitions from the given XML files.
</span><span style="color:#75715e"> * @param configLocations array of resource locations
</span><span style="color:#75715e"> * @param refresh whether to automatically refresh the context,
</span><span style="color:#75715e"> * loading all bean definitions and creating all singletons.
</span><span style="color:#75715e"> * Alternatively, call refresh manually after further configuring the context.
</span><span style="color:#75715e"> * @param parent the parent context
</span><span style="color:#75715e"> * @throws BeansException if context creation failed
</span><span style="color:#75715e"> * @see #refresh()
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ClassPathXmlApplicationContext</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> configLocations<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> refresh<span style="color:#f92672">,</span> ApplicationContext parent<span style="color:#f92672">)</span>
		<span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>

	<span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>parent<span style="color:#f92672">);</span>
	setConfigLocations<span style="color:#f92672">(</span>configLocations<span style="color:#f92672">);</span>
	<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>refresh<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		refresh<span style="color:#f92672">();</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Create a new ClassPathXmlApplicationContext with the given parent,
</span><span style="color:#75715e"> * loading the definitions from the given XML files and automatically
</span><span style="color:#75715e"> * refreshing the context.
</span><span style="color:#75715e"> * @param paths array of relative (or absolute) paths within the class path
</span><span style="color:#75715e"> * @param clazz the class to load resources with (basis for the given paths)
</span><span style="color:#75715e"> * @param parent the parent context
</span><span style="color:#75715e"> * @throws BeansException if context creation failed
</span><span style="color:#75715e"> * @see org.springframework.core.io.ClassPathResource#ClassPathResource(String, Class)
</span><span style="color:#75715e"> * @see org.springframework.context.support.GenericApplicationContext
</span><span style="color:#75715e"> * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ClassPathXmlApplicationContext</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> paths<span style="color:#f92672">,</span> Class<span style="color:#f92672">&lt;?&gt;</span> clazz<span style="color:#f92672">,</span> ApplicationContext parent<span style="color:#f92672">)</span>
		<span style="color:#66d9ef">throws</span> BeansException <span style="color:#f92672">{</span>

	<span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>parent<span style="color:#f92672">);</span>
	Assert<span style="color:#f92672">.</span><span style="color:#a6e22e">notNull</span><span style="color:#f92672">(</span>paths<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Path array must not be null&#34;</span><span style="color:#f92672">);</span>
	Assert<span style="color:#f92672">.</span><span style="color:#a6e22e">notNull</span><span style="color:#f92672">(</span>clazz<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Class argument must not be null&#34;</span><span style="color:#f92672">);</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">configResources</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Resource<span style="color:#f92672">[</span>paths<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
	<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> paths<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">configResources</span><span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ClassPathResource<span style="color:#f92672">(</span>paths<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> clazz<span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>
	refresh<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>其中，super(parent) 设置了 parent，不过一般都是 null，还有获取访问资源，通过 AbstractApplicationContext 设置：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Create a new AbstractApplicationContext with no parent.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AbstractApplicationContext</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">resourcePatternResolver</span> <span style="color:#f92672">=</span> getResourcePatternResolver<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Create a new AbstractApplicationContext with the given parent context.
</span><span style="color:#75715e"> * @param parent the parent context
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AbstractApplicationContext</span><span style="color:#f92672">(</span>ApplicationContext parent<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">this</span><span style="color:#f92672">();</span>
	setParent<span style="color:#f92672">(</span>parent<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>setConfigLocations() 在 AbstractRefreshableConfigApplicationContext 的定义，设置配置地址：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Set the config locations for this application context in init-param style,
</span><span style="color:#75715e">	 * i.e. with distinct locations separated by commas, semicolons or whitespace.
</span><span style="color:#75715e">	 * &lt;p&gt;If not set, the implementation may use a default as appropriate.
</span><span style="color:#75715e">	 */</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setConfigLocation</span><span style="color:#f92672">(</span>String location<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		setConfigLocations<span style="color:#f92672">(</span>StringUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">tokenizeToStringArray</span><span style="color:#f92672">(</span>location<span style="color:#f92672">,</span> CONFIG_LOCATION_DELIMITERS<span style="color:#f92672">));</span>
	<span style="color:#f92672">}</span>

	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Set the config locations for this application context.
</span><span style="color:#75715e">	 * &lt;p&gt;If not set, the implementation may use a default as appropriate.
</span><span style="color:#75715e">	 */</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setConfigLocations</span><span style="color:#f92672">(</span>String<span style="color:#f92672">...</span> locations<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>locations <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
			Assert<span style="color:#f92672">.</span><span style="color:#a6e22e">noNullElements</span><span style="color:#f92672">(</span>locations<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Config locations must not be null&#34;</span><span style="color:#f92672">);</span>
			<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">configLocations</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>locations<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
			<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> locations<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
				<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">configLocations</span><span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> resolvePath<span style="color:#f92672">(</span>locations<span style="color:#f92672">[</span>i<span style="color:#f92672">]).</span><span style="color:#a6e22e">trim</span><span style="color:#f92672">();</span>
			<span style="color:#f92672">}</span>
		<span style="color:#f92672">}</span>
		<span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
			<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">configLocations</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
		<span style="color:#f92672">}</span>
	<span style="color:#f92672">}</span>
</code></pre></div><p>实际上，在另一个方法中，也设置了configLocations。
refresh() 方法。</p>
<blockquote>
<p>这个方法的作用是创建加载Spring容器配置（包括.xml配置，property文件和数据库模式等）</p>
</blockquote>
<h1 id="初始化-ioc-容器">初始化 IoC 容器</h1>
<p>从之前的源码中也能看出来，初始化的过程都是在 refresh 这个方法中实现的。
在 AbstractApplicationContext override：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Override</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">refresh</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> BeansException<span style="color:#f92672">,</span> IllegalStateException <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">startupShutdownMonitor</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
			<span style="color:#75715e">// Prepare this context for refreshing.
</span><span style="color:#75715e"></span>			prepareRefresh<span style="color:#f92672">();</span>
			<span style="color:#75715e">// Tell the subclass to refresh the internal bean factory.
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// 主要创建一个beanFactory，加载配置文件中的beanDefinition
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 通过 String[] configLocations = getConfigLocations()获取资源路径，然后加载beanDefinition
</span><span style="color:#75715e"></span>			ConfigurableListableBeanFactory beanFactory <span style="color:#f92672">=</span> obtainFreshBeanFactory<span style="color:#f92672">();</span>
			<span style="color:#75715e">// Prepare the bean factory for use in this context.
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// 给beanFactory注册一些标准组建，如ClassLoader，StandardEnvironment，BeanProcess
</span><span style="color:#75715e"></span>			prepareBeanFactory<span style="color:#f92672">(</span>beanFactory<span style="color:#f92672">);</span>
			<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
				<span style="color:#75715e">// Allows post-processing of the bean factory in context subclasses.
</span><span style="color:#75715e"></span>				postProcessBeanFactory<span style="color:#f92672">(</span>beanFactory<span style="color:#f92672">);</span>
				<span style="color:#75715e">// Invoke factory processors registered as beans in the context.
</span><span style="color:#75715e"></span>				invokeBeanFactoryPostProcessors<span style="color:#f92672">(</span>beanFactory<span style="color:#f92672">);</span>
				<span style="color:#75715e">// Register bean processors that intercept bean creation.
</span><span style="color:#75715e"></span>				registerBeanPostProcessors<span style="color:#f92672">(</span>beanFactory<span style="color:#f92672">);</span>
				<span style="color:#75715e">// Initialize message source for this context.
</span><span style="color:#75715e"></span>				initMessageSource<span style="color:#f92672">();</span>
				<span style="color:#75715e">// Initialize event multicaster for this context.
</span><span style="color:#75715e"></span>				initApplicationEventMulticaster<span style="color:#f92672">();</span>
				<span style="color:#75715e">// Initialize other special beans in specific context subclasses.
</span><span style="color:#75715e"></span>				onRefresh<span style="color:#f92672">();</span>
				<span style="color:#75715e">// Check for listener beans and register them.
</span><span style="color:#75715e"></span>				registerListeners<span style="color:#f92672">();</span>
				<span style="color:#75715e">// Instantiate all remaining (non-lazy-init) singletons.
</span><span style="color:#75715e"></span>				finishBeanFactoryInitialization<span style="color:#f92672">(</span>beanFactory<span style="color:#f92672">);</span>
				<span style="color:#75715e">// Last step: publish corresponding event.
</span><span style="color:#75715e"></span>				finishRefresh<span style="color:#f92672">();</span>
			<span style="color:#f92672">}</span>
			<span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>BeansException ex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
				<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logger<span style="color:#f92672">.</span><span style="color:#a6e22e">isWarnEnabled</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
					logger<span style="color:#f92672">.</span><span style="color:#a6e22e">warn</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Exception encountered during context initialization - &#34;</span> <span style="color:#f92672">+</span>
							<span style="color:#e6db74">&#34;cancelling refresh attempt: &#34;</span> <span style="color:#f92672">+</span> ex<span style="color:#f92672">);</span>
				<span style="color:#f92672">}</span>
				<span style="color:#75715e">// Destroy already created singletons to avoid dangling resources.
</span><span style="color:#75715e"></span>				destroyBeans<span style="color:#f92672">();</span>
				<span style="color:#75715e">// Reset &#39;active&#39; flag.
</span><span style="color:#75715e"></span>				cancelRefresh<span style="color:#f92672">(</span>ex<span style="color:#f92672">);</span>
				<span style="color:#75715e">// Propagate exception to caller.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">throw</span> ex<span style="color:#f92672">;</span>
			<span style="color:#f92672">}</span>
			<span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
				<span style="color:#75715e">// Reset common introspection caches in Spring&#39;s core, since we
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// might not ever need metadata for singleton beans anymore...
</span><span style="color:#75715e"></span>				resetCommonCaches<span style="color:#f92672">();</span>
			<span style="color:#f92672">}</span>
		<span style="color:#f92672">}</span>
	<span style="color:#f92672">}</span>
	<span style="color:#75715e">/**
</span><span style="color:#75715e">	 * Prepare this context for refreshing, setting its startup date and
</span><span style="color:#75715e">	 * active flag as well as performing any initialization of property sources.
</span><span style="color:#75715e">	 */</span>
	<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">prepareRefresh</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">startupDate</span> <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">closed</span><span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">active</span><span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>logger<span style="color:#f92672">.</span><span style="color:#a6e22e">isInfoEnabled</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
			logger<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Refreshing &#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
		<span style="color:#f92672">}</span>
		<span style="color:#75715e">// Initialize any placeholder property sources in the context environment
</span><span style="color:#75715e"></span>		initPropertySources<span style="color:#f92672">();</span>
		<span style="color:#75715e">// Validate that all properties marked as required are resolvable
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// see ConfigurablePropertyResolver#setRequiredProperties
</span><span style="color:#75715e"></span>		getEnvironment<span style="color:#f92672">().</span><span style="color:#a6e22e">validateRequiredProperties</span><span style="color:#f92672">();</span>
		<span style="color:#75715e">// Allow for the collection of early ApplicationEvents,
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// to be published once the multicaster is available...
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">earlyApplicationEvents</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedHashSet<span style="color:#f92672">&lt;</span>ApplicationEvent<span style="color:#f92672">&gt;();</span>
	<span style="color:#f92672">}</span>
</code></pre></div><p>主要说明可以参考<a href="http://blog.csdn.net/bubaxiu/article/details/41380683">这个博客</a>，本人还是需要再深入。</p>
<p>书上说， IoC 容器的启动分为三个过程的实现：</p>
<ul>
<li>BeanDefinition 的 Resource 定位</li>
<li>BeanDefinition 的 Resource 载入</li>
<li>BeanDefinition 的 Resource 注册</li>
</ul>
<blockquote>
<p>第一个过程是 Resource 定位过程。 这个 Resource 定位指的是 BeanDefinition 的资源定位，它由 ResourceLoader 通过统一的 Resource 接口来完成，这个 Resource 对各种形式的 BeanDefinition 的使用都提供了统一的接口。</p>
</blockquote>
<p>比如 FileSystemResource、ClassPathResource 等等。</p>
<blockquote>
<p>第二个过程是 BeanDefinition 的载入。这个载入过程是把用户定义好的 Bean 表示成 IoC 容器内部的数据结构，而这个容器内部的数据结构就是 BeanDefinition。</p>
</blockquote>
<p>BeanDefinition 是 POJO 对象在 IoC 容器中的抽象，通过此定义的数据结构使 IoC 容器能够方便对 Bean进行管理。</p>
<blockquote>
<p>第三个过程是向 IoC 容器注册这些 BeanDefinition 的过程。这个过程是通过调用 BeanDefinitionRegistry 接口的实现来完成的。这个注册过程把载入过程中解析得到的 BeanDefinition 向 IoC 容器进行注册。</p>
</blockquote>
<p>IoC 容器内部将 BeanDefinition 注入到 HashMap 中去， IoC 容器就是通过这个 HashMap 来持有这些 BeanDefinition 数据的。</p>
<h1 id="postscript">Postscript</h1>
<p>开始看的时候才发现，内部的东西真的好多，目前先到这里，以后会继续学习 Spring IoC 相关更多内容。</p>
<h1 id="references">References</h1>
<p><a href="http://blog.csdn.net/bubaxiu/article/details/41380683">Spring源码阅读&ndash;AbstractApplicationContext refresh()方法调用</a></p>
<p>Spring 技术内幕</p>
]]></content>
        </item>
        
        <item>
            <title>Source Code in Java -- ArrayList</title>
            <link>http://keltoy.github.io/posts/source-code-in-java-arraylist/</link>
            <pubDate>Tue, 25 Oct 2016 23:46:28 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/source-code-in-java-arraylist/</guid>
            <description>前言 ArrayList，相信大家都不陌生了，它的源码网上也是到处都是，但是我还是想看看，也许会有不一样的发现。
初识 ArrayList ArrayList，顺序列表，非线程安全的，基本用法和数组类似，但是可以扩容。默认初始大小为 10， 扩容大小为 1.5 倍。基本上就这么多。本身构造也简单。
思考 ArrayList 为什么会出现 ArrayList 这个类呢，数组不能够满足要求吗？除了可以扩容，他跟数组有什么区别呢？ 扩容为什么是 1.5 倍？ 初始大小为什么是 10？
ArrayList 源码 ArrayList 变量 基于 1.8 的源码，基本上也没太多可说的，主要针对查找、添加、删除、以及扩容方面进行了解。 首先是 ArrayList 的属性。
public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances.</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>ArrayList，相信大家都不陌生了，它的源码网上也是到处都是，但是我还是想看看，也许会有不一样的发现。</p>
<h1 id="初识-arraylist">初识 ArrayList</h1>
<p>ArrayList，顺序列表，非线程安全的，基本用法和数组类似，但是可以扩容。默认初始大小为 10， 扩容大小为  1.5 倍。基本上就这么多。本身构造也简单。</p>
<h1 id="思考-arraylist">思考 ArrayList</h1>
<p>为什么会出现 ArrayList 这个类呢，数组不能够满足要求吗？除了可以扩容，他跟数组有什么区别呢？
扩容为什么是 1.5 倍？
初始大小为什么是 10？</p>
<h1 id="arraylist-源码">ArrayList 源码</h1>
<h2 id="arraylist-变量">ArrayList 变量</h2>
<p>基于 1.8 的源码，基本上也没太多可说的，主要针对查找、添加、删除、以及扩容方面进行了解。
首先是 ArrayList 的属性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> AbstractList<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>
        <span style="color:#66d9ef">implements</span> List<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;,</span> RandomAccess<span style="color:#f92672">,</span> Cloneable<span style="color:#f92672">,</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> serialVersionUID <span style="color:#f92672">=</span> 8683452581122892189L<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Default initial capacity.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_CAPACITY <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Shared empty array instance used for empty instances.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Object<span style="color:#f92672">[]</span> EMPTY_ELEMENTDATA <span style="color:#f92672">=</span> <span style="color:#f92672">{};</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Shared empty array instance used for default sized empty instances. We
</span><span style="color:#75715e">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
</span><span style="color:#75715e">     * first element is added.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Object<span style="color:#f92672">[]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span style="color:#f92672">=</span> <span style="color:#f92672">{};</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The array buffer into which the elements of the ArrayList are stored.
</span><span style="color:#75715e">     * The capacity of the ArrayList is the length of this array buffer. Any
</span><span style="color:#75715e">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
</span><span style="color:#75715e">     * will be expanded to DEFAULT_CAPACITY when the first element is added.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">transient</span> Object<span style="color:#f92672">[]</span> elementData<span style="color:#f92672">;</span> <span style="color:#75715e">// non-private to simplify nested class access
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The size of the ArrayList (the number of elements it contains).
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @serial
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>
</code></pre></div><p>可以看出，ArrayList 支持随机访问，支持序列化，以及拷贝；serialVersionUID 这个变量就是用来实现序列化的。</p>
<blockquote>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。</p>
</blockquote>
<p>DEFAULT_CAPACITY 定义了初始化容器的大小为 10。也没说为什么，可能和经验有关系。
EMPTY_ELEMENTDATA 定义了一个空数据。DEFAULTCAPACITY_EMPTY_ELEMENTDATA 定义了默认容器空数据。
这俩参数通过注释得知，EMPTY_ELEMENTDATA 是保证所有空数据共享；DEFAULTCAPACITY_EMPTY_ELEMENTDATA 是共享默认大小的空实例。这个实例与之前 EMPTY_ELEMENTDATA 的实例区别在在第一次扩容的时候这个实例才会有所更改。我的理解可能会节省不少空间吧？而且放在 Method Area 中的 runtime constant pool 中，也节约了 gc 的时间？ 以上是我的猜测。
elementData 应该是真正放置数据的地方，注意到的是这个变量使用了 <code>transient</code> 也就是数据不会被序列化/反序列化。这么一来，是不能使用序列化对数据进行传输了。然而，根据经验，ArrayList事实上是可以序列化的。个人猜测，可能是重写了序列化实现的方法。
不过我看了看 Serializable 的接口发现里面其实没有申明方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> java.io<span style="color:#f92672">;</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Serializability of a class is enabled by the class implementing the
</span><span style="color:#75715e"> * java.io.Serializable interface. Classes that do not implement this
</span><span style="color:#75715e"> * interface will not have any of their state serialized or
</span><span style="color:#75715e"> * deserialized.  All subtypes of a serializable class are themselves
</span><span style="color:#75715e"> * serializable.  The serialization interface has no methods or fields
</span><span style="color:#75715e"> * and serves only to identify the semantics of being serializable. &lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * To allow subtypes of non-serializable classes to be serialized, the
</span><span style="color:#75715e"> * subtype may assume responsibility for saving and restoring the
</span><span style="color:#75715e"> * state of the supertype&#39;s public, protected, and (if accessible)
</span><span style="color:#75715e"> * package fields.  The subtype may assume this responsibility only if
</span><span style="color:#75715e"> * the class it extends has an accessible no-arg constructor to
</span><span style="color:#75715e"> * initialize the class&#39;s state.  It is an error to declare a class
</span><span style="color:#75715e"> * Serializable if this is not the case.  The error will be detected at
</span><span style="color:#75715e"> * runtime. &lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * During deserialization, the fields of non-serializable classes will
</span><span style="color:#75715e"> * be initialized using the public or protected no-arg constructor of
</span><span style="color:#75715e"> * the class.  A no-arg constructor must be accessible to the subclass
</span><span style="color:#75715e"> * that is serializable.  The fields of serializable subclasses will
</span><span style="color:#75715e"> * be restored from the stream. &lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * When traversing a graph, an object may be encountered that does not
</span><span style="color:#75715e"> * support the Serializable interface. In this case the
</span><span style="color:#75715e"> * NotSerializableException will be thrown and will identify the class
</span><span style="color:#75715e"> * of the non-serializable object. &lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * Classes that require special handling during the serialization and
</span><span style="color:#75715e"> * deserialization process must implement special methods with these exact
</span><span style="color:#75715e"> * signatures:
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;PRE&gt;
</span><span style="color:#75715e"> * private void writeObject(java.io.ObjectOutputStream out)
</span><span style="color:#75715e"> *     throws IOException
</span><span style="color:#75715e"> * private void readObject(java.io.ObjectInputStream in)
</span><span style="color:#75715e"> *     throws IOException, ClassNotFoundException;
</span><span style="color:#75715e"> * private void readObjectNoData()
</span><span style="color:#75715e"> *     throws ObjectStreamException;
</span><span style="color:#75715e"> * &lt;/PRE&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;p&gt;The writeObject method is responsible for writing the state of the
</span><span style="color:#75715e"> * object for its particular class so that the corresponding
</span><span style="color:#75715e"> * readObject method can restore it.  The default mechanism for saving
</span><span style="color:#75715e"> * the Object&#39;s fields can be invoked by calling
</span><span style="color:#75715e"> * out.defaultWriteObject. The method does not need to concern
</span><span style="color:#75715e"> * itself with the state belonging to its superclasses or subclasses.
</span><span style="color:#75715e"> * State is saved by writing the individual fields to the
</span><span style="color:#75715e"> * ObjectOutputStream using the writeObject method or by using the
</span><span style="color:#75715e"> * methods for primitive data types supported by DataOutput.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;p&gt;The readObject method is responsible for reading from the stream and
</span><span style="color:#75715e"> * restoring the classes fields. It may call in.defaultReadObject to invoke
</span><span style="color:#75715e"> * the default mechanism for restoring the object&#39;s non-static and
</span><span style="color:#75715e"> * non-transient fields.  The defaultReadObject method uses information in
</span><span style="color:#75715e"> * the stream to assign the fields of the object saved in the stream with the
</span><span style="color:#75715e"> * correspondingly named fields in the current object.  This handles the case
</span><span style="color:#75715e"> * when the class has evolved to add new fields. The method does not need to
</span><span style="color:#75715e"> * concern itself with the state belonging to its superclasses or subclasses.
</span><span style="color:#75715e"> * State is saved by writing the individual fields to the
</span><span style="color:#75715e"> * ObjectOutputStream using the writeObject method or by using the
</span><span style="color:#75715e"> * methods for primitive data types supported by DataOutput.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
</span><span style="color:#75715e"> * the object for its particular class in the event that the serialization
</span><span style="color:#75715e"> * stream does not list the given class as a superclass of the object being
</span><span style="color:#75715e"> * deserialized.  This may occur in cases where the receiving party uses a
</span><span style="color:#75715e"> * different version of the deserialized instance&#39;s class than the sending
</span><span style="color:#75715e"> * party, and the receiver&#39;s version extends classes that are not extended by
</span><span style="color:#75715e"> * the sender&#39;s version.  This may also occur if the serialization stream has
</span><span style="color:#75715e"> * been tampered; hence, readObjectNoData is useful for initializing
</span><span style="color:#75715e"> * deserialized objects properly despite a &#34;hostile&#34; or incomplete source
</span><span style="color:#75715e"> * stream.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;p&gt;Serializable classes that need to designate an alternative object to be
</span><span style="color:#75715e"> * used when writing an object to the stream should implement this
</span><span style="color:#75715e"> * special method with the exact signature:
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;PRE&gt;
</span><span style="color:#75715e"> * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;
</span><span style="color:#75715e"> * &lt;/PRE&gt;&lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * This writeReplace method is invoked by serialization if the method
</span><span style="color:#75715e"> * exists and it would be accessible from a method defined within the
</span><span style="color:#75715e"> * class of the object being serialized. Thus, the method can have private,
</span><span style="color:#75715e"> * protected and package-private access. Subclass access to this method
</span><span style="color:#75715e"> * follows java accessibility rules. &lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * Classes that need to designate a replacement when an instance of it
</span><span style="color:#75715e"> * is read from the stream should implement this special method with the
</span><span style="color:#75715e"> * exact signature.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;PRE&gt;
</span><span style="color:#75715e"> * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;
</span><span style="color:#75715e"> * &lt;/PRE&gt;&lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * This readResolve method follows the same invocation rules and
</span><span style="color:#75715e"> * accessibility rules as writeReplace.&lt;p&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * The serialization runtime associates with each serializable class a version
</span><span style="color:#75715e"> * number, called a serialVersionUID, which is used during deserialization to
</span><span style="color:#75715e"> * verify that the sender and receiver of a serialized object have loaded
</span><span style="color:#75715e"> * classes for that object that are compatible with respect to serialization.
</span><span style="color:#75715e"> * If the receiver has loaded a class for the object that has a different
</span><span style="color:#75715e"> * serialVersionUID than that of the corresponding sender&#39;s class, then
</span><span style="color:#75715e"> * deserialization will result in an {@link InvalidClassException}.  A
</span><span style="color:#75715e"> * serializable class can declare its own serialVersionUID explicitly by
</span><span style="color:#75715e"> * declaring a field named &lt;code&gt;&#34;serialVersionUID&#34;&lt;/code&gt; that must be static,
</span><span style="color:#75715e"> * final, and of type &lt;code&gt;long&lt;/code&gt;:
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * &lt;PRE&gt;
</span><span style="color:#75715e"> * ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
</span><span style="color:#75715e"> * &lt;/PRE&gt;
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * If a serializable class does not explicitly declare a serialVersionUID, then
</span><span style="color:#75715e"> * the serialization runtime will calculate a default serialVersionUID value
</span><span style="color:#75715e"> * for that class based on various aspects of the class, as described in the
</span><span style="color:#75715e"> * Java(TM) Object Serialization Specification.  However, it is &lt;em&gt;strongly
</span><span style="color:#75715e"> * recommended&lt;/em&gt; that all serializable classes explicitly declare
</span><span style="color:#75715e"> * serialVersionUID values, since the default serialVersionUID computation is
</span><span style="color:#75715e"> * highly sensitive to class details that may vary depending on compiler
</span><span style="color:#75715e"> * implementations, and can thus result in unexpected
</span><span style="color:#75715e"> * &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization.  Therefore, to
</span><span style="color:#75715e"> * guarantee a consistent serialVersionUID value across different java compiler
</span><span style="color:#75715e"> * implementations, a serializable class must declare an explicit
</span><span style="color:#75715e"> * serialVersionUID value.  It is also strongly advised that explicit
</span><span style="color:#75715e"> * serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where
</span><span style="color:#75715e"> * possible, since such declarations apply only to the immediately declaring
</span><span style="color:#75715e"> * class--serialVersionUID fields are not useful as inherited members. Array
</span><span style="color:#75715e"> * classes cannot declare an explicit serialVersionUID, so they always have
</span><span style="color:#75715e"> * the default computed value, but the requirement for matching
</span><span style="color:#75715e"> * serialVersionUID values is waived for array classes.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @author  unascribed
</span><span style="color:#75715e"> * @see java.io.ObjectOutputStream
</span><span style="color:#75715e"> * @see java.io.ObjectInputStream
</span><span style="color:#75715e"> * @see java.io.ObjectOutput
</span><span style="color:#75715e"> * @see java.io.ObjectInput
</span><span style="color:#75715e"> * @see java.io.Externalizable
</span><span style="color:#75715e"> * @since   JDK1.1
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Serializable</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>很长很长的说明。大概看看突然想起来了，实现 <code>Serializable</code> 是需要重写 writeObject 和 readObject 等方法。我猜测是重写了该方法。</p>
<p>size 变量就是数据的大小了。</p>
<h2 id="arraylist-构造方法">ArrayList 构造方法</h2>
<p>继续查看源代码，可以看到 ArrayList 的 constructors：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Constructs an empty list with the specified initial capacity.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param  initialCapacity  the initial capacity of the list
</span><span style="color:#75715e"> * @throws IllegalArgumentException if the specified initial capacity
</span><span style="color:#75715e"> *         is negative
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> initialCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">elementData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">[</span>initialCapacity<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>initialCapacity <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">elementData</span> <span style="color:#f92672">=</span> EMPTY_ELEMENTDATA<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal Capacity: &#34;</span><span style="color:#f92672">+</span>
                                           initialCapacity<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Constructs an empty list with an initial capacity of ten.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">elementData</span> <span style="color:#f92672">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Constructs a list containing the elements of the specified
</span><span style="color:#75715e"> * collection, in the order they are returned by the collection&#39;s
</span><span style="color:#75715e"> * iterator.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param c the collection whose elements are to be placed into this list
</span><span style="color:#75715e"> * @throws NullPointerException if the specified collection is null
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> E<span style="color:#f92672">&gt;</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    elementData <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>size <span style="color:#f92672">=</span> elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// c.toArray might (incorrectly) not return Object[] (see 6260652)
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> Object<span style="color:#f92672">[].</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span>
            elementData <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOf</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> size<span style="color:#f92672">,</span> Object<span style="color:#f92672">[].</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// replace with empty array.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">elementData</span> <span style="color:#f92672">=</span> EMPTY_ELEMENTDATA<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>这里定义了三个 constructor， 我其实挺好奇默认构造方法的实现，和给定参数为 0 构造函数，这俩还不一样。默认的构造方法，是一个空对象数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p>
<h2 id="arraylist-扩容等方法">ArrayList 扩容等方法</h2>
<p>查看关于容量的源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if
</span><span style="color:#75715e">     * necessary, to ensure that it can hold at least the number of elements
</span><span style="color:#75715e">     * specified by the minimum capacity argument.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param   minCapacity   the desired minimum capacity
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ensureCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> minExpand <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>elementData <span style="color:#f92672">!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span style="color:#f92672">)</span>
            <span style="color:#75715e">// any size if not default element table
</span><span style="color:#75715e"></span>            <span style="color:#f92672">?</span> 0
            <span style="color:#75715e">// larger than default for default empty table. It&#39;s already
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// supposed to be at default size.
</span><span style="color:#75715e"></span>            <span style="color:#f92672">:</span> DEFAULT_CAPACITY<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minCapacity <span style="color:#f92672">&gt;</span> minExpand<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            ensureExplicitCapacity<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p>ensureCapacity 保证容量，如果不是默认空数据，那么 minExpand 为 0，否则为 DEFAULT_CAPACITY，也就是 10。 如果 minCapacity 大于 minExpand，也就是说需要扩展的大小比默认大小还大，那么就调用 ensureExplicitCapacity，显式扩容。
源码中并没有使用这个方法，而是下面的方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ensureCapacityInternal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>elementData <span style="color:#f92672">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        minCapacity <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>DEFAULT_CAPACITY<span style="color:#f92672">,</span> minCapacity<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    ensureExplicitCapacity<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>ensureCapacityInternal，这个方法在其他的方法中有所调用。跟之前的类似，也是比较默认容器大小和 minCapacity 的大小。不同的地方在于，不论如何这里都会进行 ensureExplicitCapacity，如果调用 ensureCapacity， 那么</p>
<p>$$
minCapacity \le  minExpand
$$</p>
<p>不会进行任何操作。我的理解是，在初始化的时候会省去很多不必要的开销。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ensureExplicitCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    modCount<span style="color:#f92672">++;</span>

    <span style="color:#75715e">// overflow-conscious code
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minCapacity <span style="color:#f92672">-</span> elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
        grow<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个方法才是保证扩容的真正方法。
modCount， 这个变量是从 AbstractList<!-- raw HTML omitted --> 继承过来的：</p>
<pre><code>protected transient int modCount = 0;
</code></pre>
<p>猜一下也知道，用来记录扩容次数的。不论是否扩容，都会加一。然后，如果需要的容量比现在的长度还大，就扩容。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * The maximum size of array to allocate.
</span><span style="color:#75715e"> * Some VMs reserve some header words in an array.
</span><span style="color:#75715e"> * Attempts to allocate larger arrays may result in
</span><span style="color:#75715e"> * OutOfMemoryError: Requested array size exceeds VM limit
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAX_ARRAY_SIZE <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">-</span> 8<span style="color:#f92672">;</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Increases the capacity to ensure that it can hold at least the
</span><span style="color:#75715e"> * number of elements specified by the minimum capacity argument.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param minCapacity the desired minimum capacity
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">grow</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// overflow-conscious code
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> oldCapacity <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>oldCapacity <span style="color:#f92672">&gt;&gt;</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> minCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
        newCapacity <span style="color:#f92672">=</span> minCapacity<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> MAX_ARRAY_SIZE <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
        newCapacity <span style="color:#f92672">=</span> hugeCapacity<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
    <span style="color:#75715e">// minCapacity is usually close to size, so this is a win:
</span><span style="color:#75715e"></span>    elementData <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOf</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里介绍的很清楚，MAX_ARRAY_SIZE 再大可能对某些虚拟机产生 OutOfMemoryError。为什么要减 8？因为要有 8 个自己去存储这个大小。
$$ 2^{31} = 2,147,483,648 $$
这个还是要存起来的。
grow 方法会对原油的数据大小进行扩容。新的大小是旧的大小的 1.5 倍（取下界）？如果这个大小比需要的大小还小，那么这个大小设置为需要的大小；如果超出了 MAX_ARRAY_SIZE，就更换策略，使用 hugeCapacity 进行扩容。
这里的扩容方式跟之前说的不太一样，我猜测是因为位运算比普通运算要快。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hugeCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#75715e">// overflow
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> OutOfMemoryError<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>minCapacity <span style="color:#f92672">&gt;</span> MAX_ARRAY_SIZE<span style="color:#f92672">)</span> <span style="color:#f92672">?</span>
        Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">:</span>
        MAX_ARRAY_SIZE<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>注意这里会引发 OutOfMemoryError 错误。这里最大也只能到整型的最大。</p>
<h2 id="arraylist-增删改查">ArrayList 增删改查</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">   * Returns the element at the specified position in this list.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param  index index of the element to return
</span><span style="color:#75715e">   * @return the element at the specified position in this list
</span><span style="color:#75715e">   * @throws IndexOutOfBoundsException {@inheritDoc}
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> E <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      rangeCheck<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>

      <span style="color:#66d9ef">return</span> elementData<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Replaces the element at the specified position in this list with
</span><span style="color:#75715e">   * the specified element.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param index index of the element to replace
</span><span style="color:#75715e">   * @param element element to be stored at the specified position
</span><span style="color:#75715e">   * @return the element previously at the specified position
</span><span style="color:#75715e">   * @throws IndexOutOfBoundsException {@inheritDoc}
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> E <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> E element<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      rangeCheck<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>

      E oldValue <span style="color:#f92672">=</span> elementData<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
      elementData<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> element<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Appends the specified element to the end of this list.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param e element to be appended to this list
</span><span style="color:#75715e">   * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      ensureCapacityInternal<span style="color:#f92672">(</span>size <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>  <span style="color:#75715e">// Increments modCount!!
</span><span style="color:#75715e"></span>      elementData<span style="color:#f92672">[</span>size<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Inserts the specified element at the specified position in this
</span><span style="color:#75715e">   * list. Shifts the element currently at that position (if any) and
</span><span style="color:#75715e">   * any subsequent elements to the right (adds one to their indices).
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param index index at which the specified element is to be inserted
</span><span style="color:#75715e">   * @param element element to be inserted
</span><span style="color:#75715e">   * @throws IndexOutOfBoundsException {@inheritDoc}
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> E element<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      rangeCheckForAdd<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>

      ensureCapacityInternal<span style="color:#f92672">(</span>size <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>  <span style="color:#75715e">// Increments modCount!!
</span><span style="color:#75715e"></span>      System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> index <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span>
                       size <span style="color:#f92672">-</span> index<span style="color:#f92672">);</span>
      elementData<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> element<span style="color:#f92672">;</span>
      size<span style="color:#f92672">++;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Removes the element at the specified position in this list.
</span><span style="color:#75715e">   * Shifts any subsequent elements to the left (subtracts one from their
</span><span style="color:#75715e">   * indices).
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param index the index of the element to be removed
</span><span style="color:#75715e">   * @return the element that was removed from the list
</span><span style="color:#75715e">   * @throws IndexOutOfBoundsException {@inheritDoc}
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> E <span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      rangeCheck<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>

      modCount<span style="color:#f92672">++;</span>
      E oldValue <span style="color:#f92672">=</span> elementData<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>

      <span style="color:#66d9ef">int</span> numMoved <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> index <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>numMoved <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
          System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span>
                           numMoved<span style="color:#f92672">);</span>
      elementData<span style="color:#f92672">[--</span>size<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// clear to let GC do its work
</span><span style="color:#75715e"></span>
      <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Removes the first occurrence of the specified element from this list,
</span><span style="color:#75715e">   * if it is present.  If the list does not contain the element, it is
</span><span style="color:#75715e">   * unchanged.  More formally, removes the element with the lowest index
</span><span style="color:#75715e">   * &lt;tt&gt;i&lt;/tt&gt; such that
</span><span style="color:#75715e">   * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;
</span><span style="color:#75715e">   * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list
</span><span style="color:#75715e">   * contained the specified element (or equivalently, if this list
</span><span style="color:#75715e">   * changed as a result of the call).
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param o element to be removed from this list, if present
</span><span style="color:#75715e">   * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>o <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> index <span style="color:#f92672">&lt;</span> size<span style="color:#f92672">;</span> index<span style="color:#f92672">++)</span>
              <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>elementData<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                  fastRemove<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
                  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
              <span style="color:#f92672">}</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
          <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> index <span style="color:#f92672">&lt;</span> size<span style="color:#f92672">;</span> index<span style="color:#f92672">++)</span>
              <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>o<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">[</span>index<span style="color:#f92672">]))</span> <span style="color:#f92672">{</span>
                  fastRemove<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
                  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
              <span style="color:#f92672">}</span>
      <span style="color:#f92672">}</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/*
</span><span style="color:#75715e">   * Private remove method that skips bounds checking and does not
</span><span style="color:#75715e">   * return the value removed.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fastRemove</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      modCount<span style="color:#f92672">++;</span>
      <span style="color:#66d9ef">int</span> numMoved <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> index <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>numMoved <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
          System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span>
                           numMoved<span style="color:#f92672">);</span>
      elementData<span style="color:#f92672">[--</span>size<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// clear to let GC do its work
</span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Removes all of the elements from this list.  The list will
</span><span style="color:#75715e">   * be empty after this call returns.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clear</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
      modCount<span style="color:#f92672">++;</span>

      <span style="color:#75715e">// clear to let GC do its work
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> size<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
          elementData<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

      size <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Appends all of the elements in the specified collection to the end of
</span><span style="color:#75715e">   * this list, in the order that they are returned by the
</span><span style="color:#75715e">   * specified collection&#39;s Iterator.  The behavior of this operation is
</span><span style="color:#75715e">   * undefined if the specified collection is modified while the operation
</span><span style="color:#75715e">   * is in progress.  (This implies that the behavior of this call is
</span><span style="color:#75715e">   * undefined if the specified collection is this list, and this
</span><span style="color:#75715e">   * list is nonempty.)
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param c collection containing elements to be added to this list
</span><span style="color:#75715e">   * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call
</span><span style="color:#75715e">   * @throws NullPointerException if the specified collection is null
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">addAll</span><span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> E<span style="color:#f92672">&gt;</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      Object<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">();</span>
      <span style="color:#66d9ef">int</span> numNew <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
      ensureCapacityInternal<span style="color:#f92672">(</span>size <span style="color:#f92672">+</span> numNew<span style="color:#f92672">);</span>  <span style="color:#75715e">// Increments modCount
</span><span style="color:#75715e"></span>      System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> size<span style="color:#f92672">,</span> numNew<span style="color:#f92672">);</span>
      size <span style="color:#f92672">+=</span> numNew<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">return</span> numNew <span style="color:#f92672">!=</span> 0<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Inserts all of the elements in the specified collection into this
</span><span style="color:#75715e">   * list, starting at the specified position.  Shifts the element
</span><span style="color:#75715e">   * currently at that position (if any) and any subsequent elements to
</span><span style="color:#75715e">   * the right (increases their indices).  The new elements will appear
</span><span style="color:#75715e">   * in the list in the order that they are returned by the
</span><span style="color:#75715e">   * specified collection&#39;s iterator.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @param index index at which to insert the first element from the
</span><span style="color:#75715e">   *              specified collection
</span><span style="color:#75715e">   * @param c collection containing elements to be added to this list
</span><span style="color:#75715e">   * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call
</span><span style="color:#75715e">   * @throws IndexOutOfBoundsException {@inheritDoc}
</span><span style="color:#75715e">   * @throws NullPointerException if the specified collection is null
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">addAll</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> Collection<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> E<span style="color:#f92672">&gt;</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      rangeCheckForAdd<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>

      Object<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">();</span>
      <span style="color:#66d9ef">int</span> numNew <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
      ensureCapacityInternal<span style="color:#f92672">(</span>size <span style="color:#f92672">+</span> numNew<span style="color:#f92672">);</span>  <span style="color:#75715e">// Increments modCount
</span><span style="color:#75715e"></span>
      <span style="color:#66d9ef">int</span> numMoved <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> index<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>numMoved <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
          System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> index <span style="color:#f92672">+</span> numNew<span style="color:#f92672">,</span>
                           numMoved<span style="color:#f92672">);</span>

      System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span> numNew<span style="color:#f92672">);</span>
      size <span style="color:#f92672">+=</span> numNew<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">return</span> numNew <span style="color:#f92672">!=</span> 0<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Removes from this list all of the elements whose index is between
</span><span style="color:#75715e">   * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
</span><span style="color:#75715e">   * Shifts any succeeding elements to the left (reduces their index).
</span><span style="color:#75715e">   * This call shortens the list by {@code (toIndex - fromIndex)} elements.
</span><span style="color:#75715e">   * (If {@code toIndex==fromIndex}, this operation has no effect.)
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * @throws IndexOutOfBoundsException if {@code fromIndex} or
</span><span style="color:#75715e">   *         {@code toIndex} is out of range
</span><span style="color:#75715e">   *         ({@code fromIndex &lt; 0 ||
</span><span style="color:#75715e">   *          fromIndex &gt;= size() ||
</span><span style="color:#75715e">   *          toIndex &gt; size() ||
</span><span style="color:#75715e">   *          toIndex &lt; fromIndex})
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeRange</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> fromIndex<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> toIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      modCount<span style="color:#f92672">++;</span>
      <span style="color:#66d9ef">int</span> numMoved <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> toIndex<span style="color:#f92672">;</span>
      System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> toIndex<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> fromIndex<span style="color:#f92672">,</span>
                       numMoved<span style="color:#f92672">);</span>

      <span style="color:#75715e">// clear to let GC do its work
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">int</span> newSize <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>toIndex<span style="color:#f92672">-</span>fromIndex<span style="color:#f92672">);</span>
      <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> newSize<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> size<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
          elementData<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>
      size <span style="color:#f92672">=</span> newSize<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Checks if the given index is in range.  If not, throws an appropriate
</span><span style="color:#75715e">   * runtime exception.  This method does *not* check if the index is
</span><span style="color:#75715e">   * negative: It is always used immediately prior to an array access,
</span><span style="color:#75715e">   * which throws an ArrayIndexOutOfBoundsException if index is negative.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rangeCheck</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index <span style="color:#f92672">&gt;=</span> size<span style="color:#f92672">)</span>
          <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IndexOutOfBoundsException<span style="color:#f92672">(</span>outOfBoundsMsg<span style="color:#f92672">(</span>index<span style="color:#f92672">));</span>
  <span style="color:#f92672">}</span>

</code></pre></div><p>以上的代码基本上没有特别难懂的，基本上都是依靠 Arrays 的方法实现的，没有特别说明的。</p>
<h2 id="arraylist-其他方法">ArrayList 其他方法</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">    * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that
</span><span style="color:#75715e">    * is, serialize it).
</span><span style="color:#75715e">    *
</span><span style="color:#75715e">    * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;
</span><span style="color:#75715e">    *             instance is emitted (int), followed by all of its elements
</span><span style="color:#75715e">    *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.
</span><span style="color:#75715e">    */</span>
   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">ObjectOutputStream</span> s<span style="color:#f92672">)</span>
       <span style="color:#66d9ef">throws</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">IOException</span><span style="color:#f92672">{</span>
       <span style="color:#75715e">// Write out element count, and any hidden stuff
</span><span style="color:#75715e"></span>       <span style="color:#66d9ef">int</span> expectedModCount <span style="color:#f92672">=</span> modCount<span style="color:#f92672">;</span>
       s<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultWriteObject</span><span style="color:#f92672">();</span>

       <span style="color:#75715e">// Write out size as capacity for behavioural compatibility with clone()
</span><span style="color:#75715e"></span>       s<span style="color:#f92672">.</span><span style="color:#a6e22e">writeInt</span><span style="color:#f92672">(</span>size<span style="color:#f92672">);</span>

       <span style="color:#75715e">// Write out all elements in the proper order.
</span><span style="color:#75715e"></span>       <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>size<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
           s<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
       <span style="color:#f92672">}</span>

       <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>modCount <span style="color:#f92672">!=</span> expectedModCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
           <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ConcurrentModificationException<span style="color:#f92672">();</span>
       <span style="color:#f92672">}</span>
   <span style="color:#f92672">}</span>

   <span style="color:#75715e">/**
</span><span style="color:#75715e">    * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,
</span><span style="color:#75715e">    * deserialize it).
</span><span style="color:#75715e">    */</span>
   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">readObject</span><span style="color:#f92672">(</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">ObjectInputStream</span> s<span style="color:#f92672">)</span>
       <span style="color:#66d9ef">throws</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">IOException</span><span style="color:#f92672">,</span> ClassNotFoundException <span style="color:#f92672">{</span>
       elementData <span style="color:#f92672">=</span> EMPTY_ELEMENTDATA<span style="color:#f92672">;</span>

       <span style="color:#75715e">// Read in size, and any hidden stuff
</span><span style="color:#75715e"></span>       s<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultReadObject</span><span style="color:#f92672">();</span>

       <span style="color:#75715e">// Read in capacity
</span><span style="color:#75715e"></span>       s<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span> <span style="color:#75715e">// ignored
</span><span style="color:#75715e"></span>
       <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
           <span style="color:#75715e">// be like clone(), allocate array based upon size not capacity
</span><span style="color:#75715e"></span>           ensureCapacityInternal<span style="color:#f92672">(</span>size<span style="color:#f92672">);</span>

           Object<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> elementData<span style="color:#f92672">;</span>
           <span style="color:#75715e">// Read in all elements in the proper order.
</span><span style="color:#75715e"></span>           <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>size<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
               a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">readObject</span><span style="color:#f92672">();</span>
           <span style="color:#f92672">}</span>
       <span style="color:#f92672">}</span>
   <span style="color:#f92672">}</span>
</code></pre></div><p>与之前猜测的一样，这里确实重写了 writeObject 和 readObject，用来实现序列化。</p>
<p>除此之外还有 SubList 和 Iterator 的实现，没有太多需要说明的，因为本身就比较简单。</p>
<h1 id="总结">总结</h1>
<p>ArrayList 在所有集合中应该算是比较简单的，没有同步，没有复杂的分块，也是用的最多的一种集合。需要注意的地方一个是它的最大值，一个是扩容的机制。</p>
<h1 id="参考">参考</h1>
<p><a href="http://www.cnblogs.com/guanghuiqq/archive/2012/07/18/2597036.html">serialVersionUID的作用</a></p>
<p><a href="http://stackoverflow.com/questions/35756277/why-the-maximum-array-size-of-arraylist-is-integer-max-value-8">Why the maximum array size of ArrayList is Integer.MAX_VALUE - 8?</a></p>
]]></content>
        </item>
        
        <item>
            <title>Spring Configuration-applicationContext-service.xml &amp; SqlMapConfig.xml</title>
            <link>http://keltoy.github.io/posts/spring-configuration-applicationcontext-service-xml-sqlmapconfig-xml/</link>
            <pubDate>Wed, 19 Oct 2016 22:29:47 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/spring-configuration-applicationcontext-service-xml-sqlmapconfig-xml/</guid>
            <description>前言 配置的问题就到尾声了。使用和了解还是不一样，内部原理实现更是复杂，因此我觉得主要问题还是要放到源码的阅读上。
applicationContext.xml 基本上该配置的都配置了，service 是提供服务的，也不用配别的了，就是配置一下包扫描器，扫描一下 service 包：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.summer.service&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 还有redis 的配置：
&amp;lt;bean class=&amp;#34;redis.clients.jedis.JedisCluster&amp;#34; id=&amp;#34;jedisCluster&amp;#34;&amp;gt; &amp;lt;constructor-arg&amp;gt; &amp;lt;set&amp;gt; &amp;lt;bean class=&amp;#34;redis.clients.jedis.HostAndPort&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;host&amp;#34; value=&amp;#34;172.21.14.118&amp;#34; /&amp;gt; &amp;lt;constructor-arg name=&amp;#34;port&amp;#34; value=&amp;#34;7001&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean class=&amp;#34;redis.clients.jedis.HostAndPort&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;host&amp;#34; value=&amp;#34;172.21.14.118&amp;#34; /&amp;gt; &amp;lt;constructor-arg name=&amp;#34;port&amp;#34; value=&amp;#34;7002&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean class=&amp;#34;redis.clients.jedis.HostAndPort&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;host&amp;#34; value=&amp;#34;172.21.14.118&amp;#34; /&amp;gt; &amp;lt;constructor-arg name=&amp;#34;port&amp;#34; value=&amp;#34;7003&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean class=&amp;#34;redis.clients.jedis.HostAndPort&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;host&amp;#34; value=&amp;#34;172.21.14.118&amp;#34; /&amp;gt; &amp;lt;constructor-arg name=&amp;#34;port&amp;#34; value=&amp;#34;7004&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean class=&amp;#34;redis.clients.jedis.HostAndPort&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;host&amp;#34; value=&amp;#34;172.</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>配置的问题就到尾声了。使用和了解还是不一样，内部原理实现更是复杂，因此我觉得主要问题还是要放到源码的阅读上。</p>
<h1 id="applicationcontextxml">applicationContext.xml</h1>
<p>基本上该配置的都配置了，service 是提供服务的，也不用配别的了，就是配置一下包扫描器，扫描一下 service 包：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style="color:#f92672">&lt;beans</span> <span style="color:#a6e22e">xmlns=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans&#34;</span>
       <span style="color:#a6e22e">xmlns:xsi=</span><span style="color:#e6db74">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
       <span style="color:#a6e22e">xmlns:context=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/context&#34;</span>
       <span style="color:#a6e22e">xsi:schemaLocation=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans
</span><span style="color:#e6db74">        http://www.springframework.org/schema/beans/spring-beans.xsd
</span><span style="color:#e6db74">        http://www.springframework.org/schema/context
</span><span style="color:#e6db74">         http://www.springframework.org/schema/context/spring-context.xsd&#34;</span><span style="color:#f92672">&gt;</span>

    <span style="color:#f92672">&lt;context:component-scan</span> <span style="color:#a6e22e">base-package=</span><span style="color:#e6db74">&#34;com.summer.service&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/beans&gt;</span>
</code></pre></div><p>还有redis 的配置：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;redis.clients.jedis.JedisCluster&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;jedisCluster&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;constructor-arg&gt;</span>
        <span style="color:#f92672">&lt;set&gt;</span>
            <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;redis.clients.jedis.HostAndPort&#34;</span><span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;host&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;172.21.14.118&#34;</span> <span style="color:#f92672">/&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;port&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;7001&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;/bean&gt;</span>
            <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;redis.clients.jedis.HostAndPort&#34;</span><span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;host&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;172.21.14.118&#34;</span> <span style="color:#f92672">/&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;port&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;7002&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;/bean&gt;</span>
            <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;redis.clients.jedis.HostAndPort&#34;</span><span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;host&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;172.21.14.118&#34;</span> <span style="color:#f92672">/&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;port&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;7003&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;/bean&gt;</span>
            <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;redis.clients.jedis.HostAndPort&#34;</span><span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;host&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;172.21.14.118&#34;</span> <span style="color:#f92672">/&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;port&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;7004&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;/bean&gt;</span>
            <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;redis.clients.jedis.HostAndPort&#34;</span><span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;host&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;172.21.14.118&#34;</span> <span style="color:#f92672">/&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;port&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;7005&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;/bean&gt;</span>
            <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;redis.clients.jedis.HostAndPort&#34;</span><span style="color:#f92672">&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;host&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;172.21.14.118&#34;</span> <span style="color:#f92672">/&gt;</span>
                <span style="color:#f92672">&lt;constructor-arg</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;port&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;7006&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;/bean&gt;</span>
        <span style="color:#f92672">&lt;/set&gt;</span>
    <span style="color:#f92672">&lt;/constructor-arg&gt;</span>
<span style="color:#f92672">&lt;/bean&gt;</span>
<span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;com.summer.rest.component.impl.JedisClientCluster&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;jedisClient&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/beans&gt;</span>
</code></pre></div><h1 id="sqlmapconfigxml">SqlMapConfig.xml</h1>
<p>这个配置文件是在 applicationContext-dao.xml 文件中，配置 SqlSessionFactoryBean的时候需要注入的文件
这个配置文件是 Mybatis 的配置文件，具体配置了有关 Mybatis 的参数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style="color:#75715e">&lt;!DOCTYPE configuration
</span><span style="color:#75715e">        PUBLIC &#34;-//mybatis.org//DTD Config 3.0//EN&#34;
</span><span style="color:#75715e">        &#34;http://mybatis.org/dtd/mybatis-3-config.dtd&#34;&gt;</span>
<span style="color:#f92672">&lt;configuration&gt;</span>

    <span style="color:#f92672">&lt;settings&gt;</span>
        <span style="color:#75715e">&lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt;</span>
        <span style="color:#f92672">&lt;setting</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;cacheEnabled&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
        <span style="color:#75715e">&lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt;</span>
        <span style="color:#f92672">&lt;setting</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;defaultStatementTimeout&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;3000&#34;</span><span style="color:#f92672">/&gt;</span>
        <span style="color:#75715e">&lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt;</span>
        <span style="color:#f92672">&lt;setting</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;mapUnderscoreToCamelCase&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
        <span style="color:#75715e">&lt;!-- Allows JDBC support for generated keys. A compatible driver is required.
</span><span style="color:#75715e">        This setting forces generated keys to be used if set to true,
</span><span style="color:#75715e">         as some drivers deny compatibility but still work --&gt;</span>
        <span style="color:#f92672">&lt;setting</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;useGeneratedKeys&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/settings&gt;</span>

    <span style="color:#f92672">&lt;plugins&gt;</span>
        <span style="color:#f92672">&lt;plugin</span> <span style="color:#a6e22e">interceptor=</span><span style="color:#e6db74">&#34;com.github.pagehelper.PageHelper&#34;</span><span style="color:#f92672">&gt;</span>
            <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;dialect&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;mariadb&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;/plugin&gt;</span>
    <span style="color:#f92672">&lt;/plugins&gt;</span>
    <span style="color:#75715e">&lt;!-- Continue going here --&gt;</span>

<span style="color:#f92672">&lt;/configuration&gt;</span>
</code></pre></div><p>也不长，无非就是连接状态超时时间，是否使用缓存这些。
插件是自己配置的，配置一个分页插件，配置一下 使用的数据库是什么就行了。</p>
<h1 id="总结">总结</h1>
<p>这里实际上就配置了：</p>
<ul>
<li>包扫描器，context:component-scan，用来扫描包的</li>
<li>redis 的集群设置。</li>
<li>在 Mybatis的配置文件中配置了一个分页插件。</li>
</ul>
<p>这么算下来感觉整个网站的东西其实还可以，但是做的时候是一个学习的过程，很痛苦，现在好了。其实里面还会配置一些自己写的 Bean 也可以使用注解，当时学习的时候主要是使用注解。</p>
]]></content>
        </item>
        
        <item>
            <title>Spring Configuration-applicationContext-trans.xml</title>
            <link>http://keltoy.github.io/posts/spring-configuration-applicationcontext-trans-xml/</link>
            <pubDate>Wed, 19 Oct 2016 22:12:27 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/spring-configuration-applicationcontext-trans-xml/</guid>
            <description>前言 数据库的操作，一般都少不了事务，单独一个文件配置事务，是因为确实比较重要。
applicationContext.xml 这里配置的时候需要用到aop的切面操作还有通知，注意要加上正确的地址，否则总会报错。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:tx=&amp;#34;http://www.springframework.org/schema/tx&amp;#34; xmlns:aop=&amp;#34;http://www.springframework.org/schema/aop&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&amp;#34;&amp;gt; 基本上就是注意 xmlns:tx 和 xmlns:aop 的位置。 开始配置事务。 先配置事务管理，需要把之前在 dao 层配置的数据库连接池引用过来。
&amp;lt;bean class=&amp;#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;#34; id=&amp;#34;dataSourceTransactionManager&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;dataSource&amp;#34; ref=&amp;#34;dataSource&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; 然后配置通知，配置哪些方法需要通知，这些方法使用什么传播形式。传播形式和会话紧密相关。
&amp;lt;tx:advice transaction-manager=&amp;#34;dataSourceTransactionManager&amp;#34; id=&amp;#34;txAdvice&amp;#34;&amp;gt; &amp;lt;tx:attributes&amp;gt; &amp;lt;tx:method name=&amp;#34;save*&amp;#34; propagation=&amp;#34;REQUIRED&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;insert*&amp;#34; propagation=&amp;#34;REQUIRED&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;add*&amp;#34; propagation=&amp;#34;REQUIRED&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;create*&amp;#34; propagation=&amp;#34;REQUIRED&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;delete*&amp;#34; propagation=&amp;#34;REQUIRED&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;update*&amp;#34; propagation=&amp;#34;REQUIRED&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;find*&amp;#34; propagation=&amp;#34;SUPPORTS&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;select*&amp;#34; propagation=&amp;#34;SUPPORTS&amp;#34;/&amp;gt; &amp;lt;tx:method name=&amp;#34;get*&amp;#34; propagation=&amp;#34;SUPPORTS&amp;#34;/&amp;gt; &amp;lt;/tx:attributes&amp;gt; &amp;lt;/tx:advice&amp;gt; 然后配置 aop，使用什执行哪些包的什么返回值的 什么参数需要使用以上的通知。</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>数据库的操作，一般都少不了事务，单独一个文件配置事务，是因为确实比较重要。</p>
<h1 id="applicationcontextxml">applicationContext.xml</h1>
<p>这里配置的时候需要用到aop的切面操作还有通知，注意要加上正确的地址，否则总会报错。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style="color:#f92672">&lt;beans</span> <span style="color:#a6e22e">xmlns=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans&#34;</span>
       <span style="color:#a6e22e">xmlns:xsi=</span><span style="color:#e6db74">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span> <span style="color:#a6e22e">xmlns:tx=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/tx&#34;</span>
       <span style="color:#a6e22e">xmlns:aop=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/aop&#34;</span>
       <span style="color:#a6e22e">xsi:schemaLocation=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&#34;</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>基本上就是注意 xmlns:tx 和 xmlns:aop 的位置。
开始配置事务。
先配置事务管理，需要把之前在 dao 层配置的数据库连接池引用过来。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;dataSourceTransactionManager&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;dataSource&#34;</span> <span style="color:#a6e22e">ref=</span><span style="color:#e6db74">&#34;dataSource&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/bean&gt;</span>
</code></pre></div><p>然后配置通知，配置哪些方法需要通知，这些方法使用什么传播形式。传播形式和会话紧密相关。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;tx:advice</span> <span style="color:#a6e22e">transaction-manager=</span><span style="color:#e6db74">&#34;dataSourceTransactionManager&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;txAdvice&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;tx:attributes&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;save*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;REQUIRED&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;insert*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;REQUIRED&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;add*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;REQUIRED&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;create*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;REQUIRED&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;delete*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;REQUIRED&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;update*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;REQUIRED&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;find*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;SUPPORTS&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;select*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;SUPPORTS&#34;</span><span style="color:#f92672">/&gt;</span>
            <span style="color:#f92672">&lt;tx:method</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;get*&#34;</span> <span style="color:#a6e22e">propagation=</span><span style="color:#e6db74">&#34;SUPPORTS&#34;</span><span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;/tx:attributes&gt;</span>
    <span style="color:#f92672">&lt;/tx:advice&gt;</span>
</code></pre></div><p>然后配置 aop，使用什执行哪些包的什么返回值的 什么参数需要使用以上的通知。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;aop:config&gt;</span>
        <span style="color:#f92672">&lt;aop:advisor</span> <span style="color:#a6e22e">advice-ref=</span><span style="color:#e6db74">&#34;txAdvice&#34;</span>
                     <span style="color:#a6e22e">pointcut=</span><span style="color:#e6db74">&#34;execution(* com.summer.service.*.*(..))&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/aop:config&gt;</span>
<span style="color:#f92672">&lt;/beans&gt;</span>
</code></pre></div><h1 id="总结">总结</h1>
<p>这个配置文件配置了：</p>
<ul>
<li>配置管理， Bean，DataSourceTransactionManager，用来管理事务，这里要注入连接池。</li>
<li>通知， tx:advice， 用于配置方法的传播方式。</li>
<li>aop 配置，aop:config，用于配置 aop 的切点在哪，以及使用通知。</li>
</ul>
<p>这里说的很简单，因为我想以后详细记录一下源码部分，现在只是一个整理思路的过程。自己在搭建的时候，遇到了很多坑，还是希望自己有所收获吧。</p>
<h1 id="参考">参考</h1>
<p><a href="https://github.com/TomorrowOnceMore/SummerMVC/blob/master/summer-manager/summer-manager-web/src/main/resources/spring/applicationContext-trans.xml">我的项目</a></p>
]]></content>
        </item>
        
        <item>
            <title>Spring Configuration-applicationContext-dao.xml</title>
            <link>http://keltoy.github.io/posts/spring-configuration-applicationcontext-dao-xml/</link>
            <pubDate>Wed, 19 Oct 2016 21:23:55 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/spring-configuration-applicationcontext-dao-xml/</guid>
            <description>前言 原本 applicationContext.xml 是一个文件，这里将它拆开是为了更好了解业务的配置。
applicationContext.xml 这里才是真正开始配置 Spring 的参数。 首先还是 xml 文件的头。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd &amp;#34; default-lazy-init=&amp;#34;false&amp;#34;&amp;gt; 依然注意 default-lazy-init=&amp;quot;false&amp;quot; 这一句，有人说不加也可以，是默认的，但是我使用的 Spring4， IDEA 搭建的时候不行。 接下来要配置外在配置，属性持有。这里有一个问题，那就是，在 Spring MVC 我已经配过了，为什么这里还要配一次？这个实际上就是父子容器的问题。
&amp;lt;context:property-placeholder location=&amp;#34;classpath:properties/*.properties&amp;#34;/&amp;gt; 既然是 dao 层配置，那么还需要配置数据库连接池。前两天翻书的时候，发现 druid 还支持 storm。
&amp;lt;bean class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34; id=&amp;#34;dataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;${jdbc.driver}&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;${jdbc.username}&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;${jdbc.password}&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;${jdbc.url}&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;maxActive&amp;#34; value=&amp;#34;10&amp;#34; /&amp;gt; &amp;lt;property name=&amp;#34;minIdle&amp;#34; value=&amp;#34;5&amp;#34; /&amp;gt; &amp;lt;/bean&amp;gt; 配置完数据库连接池，还需要配置 SqlSessionFactory, 用来与数据库创建会话。这让我想起来 Hibernate 的一级缓存 session 和二级缓存 sessionFactory。总的来说，就是把连接池和数据库的配置注入进来。</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>原本 applicationContext.xml 是一个文件，这里将它拆开是为了更好了解业务的配置。</p>
<h1 id="applicationcontextxml">applicationContext.xml</h1>
<p>这里才是真正开始配置 Spring 的参数。
首先还是 xml 文件的头。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style="color:#f92672">&lt;beans</span> <span style="color:#a6e22e">xmlns=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans&#34;</span>
       <span style="color:#a6e22e">xmlns:xsi=</span><span style="color:#e6db74">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
       <span style="color:#a6e22e">xmlns:context=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/context&#34;</span>
       <span style="color:#a6e22e">xsi:schemaLocation=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans
</span><span style="color:#e6db74">       http://www.springframework.org/schema/beans/spring-beans.xsd
</span><span style="color:#e6db74">       http://www.springframework.org/schema/context
</span><span style="color:#e6db74">       http://www.springframework.org/schema/context/spring-context.xsd
</span><span style="color:#e6db74">       &#34;</span>
       <span style="color:#a6e22e">default-lazy-init=</span><span style="color:#e6db74">&#34;false&#34;</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>依然注意 <code>default-lazy-init=&quot;false&quot;</code> 这一句，有人说不加也可以，是默认的，但是我使用的 Spring4， IDEA 搭建的时候不行。
接下来要配置外在配置，属性持有。这里有一个问题，那就是，在 Spring MVC 我已经配过了，为什么这里还要配一次？这个实际上就是父子容器的问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;context:property-placeholder</span> <span style="color:#a6e22e">location=</span><span style="color:#e6db74">&#34;classpath:properties/*.properties&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>既然是 dao 层配置，那么还需要配置数据库连接池。前两天翻书的时候，发现 druid 还支持 storm。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;com.alibaba.druid.pool.DruidDataSource&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;dataSource&#34;</span> <span style="color:#a6e22e">destroy-method=</span><span style="color:#e6db74">&#34;close&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;driverClassName&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;${jdbc.driver}&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;username&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;${jdbc.username}&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;password&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;${jdbc.password}&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;url&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;${jdbc.url}&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;maxActive&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;10&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;minIdle&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;5&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/bean&gt;</span>
</code></pre></div><p>配置完数据库连接池，还需要配置 SqlSessionFactory, 用来与数据库创建会话。这让我想起来 Hibernate 的一级缓存 session 和二级缓存 sessionFactory。总的来说，就是把连接池和数据库的配置注入进来。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;org.mybatis.spring.SqlSessionFactoryBean&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;sessionFactory&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;dataSource&#34;</span> <span style="color:#a6e22e">ref=</span><span style="color:#e6db74">&#34;dataSource&#34;</span><span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;configLocation&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;classpath:mybatis/SqlMapConfig.xml&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/bean&gt;</span>
</code></pre></div><p>数据库连接池和SqlSessionFactory都配置完成了，那么还需要将数据库配置注入到 Spring 中。使用 scannerConfigurer 自动扫描包，设置 dao 层目录，和刚才设置的 SqlSessionFactory。这里要注意的是属性的名字，好像是类名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;org.mybatis.spring.mapper.MapperScannerConfigurer&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;scannerConfigurer&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;basePackage&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;com.summer.mapper&#34;</span><span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;sqlSessionFactoryBeanName&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;sessionFactory&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/bean&gt;</span>
<span style="color:#f92672">&lt;/beans&gt;</span>
</code></pre></div><h1 id="总结">总结</h1>
<p>配置 dao 层的配置文件，配置了以下几个模块:</p>
<ul>
<li>属性持有， placeholder， 用于注入外在属性。</li>
<li>数据库连接池，Bean， DataSource，这里可能会使用到 placeholder 里面的参数。</li>
<li>会话缓存，Bean，SqlSessionFactory，初始化 Mybatis。</li>
<li>扫描配置， Bean，用来把Mybatis 注入 Spring，并且指定扫描的包名。</li>
</ul>
<p>不过感觉好像少了点什么&hellip;.</p>
<h1 id="参考">参考</h1>
<p><a href="https://github.com/TomorrowOnceMore/SummerMVC/blob/master/summer-manager/summer-manager-web/src/main/resources/spring/applicationContext-dao.xml">我的项目</a></p>
]]></content>
        </item>
        
        <item>
            <title>Spring Configuration-springmvc.xml</title>
            <link>http://keltoy.github.io/posts/spring-configuration-springmvc-xml/</link>
            <pubDate>Wed, 19 Oct 2016 14:25:28 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/spring-configuration-springmvc-xml/</guid>
            <description>前言 web.xml 配置好了之后（实际上也可以最后配置），还需要配置 web.xml 里面的涉及到一些文件。 先配置 servlet 标签中涉及到的 springmvc.xml。 DispatcherServlet 是前端控制器设计模式的实现，对于前段控制对应的就是 Spring MVC。
springmvc.xml springmvc.xml 的配置是在 web.xml 中的 servlet 标签中的 init-param 中设置。这里可以更改 xml 的位置和名称。我记得如果不配，默认是会在 WEB-INF 中创建一个 DispatcherServlet 的文件。现在我指定在了 resources 目录里面，将 Spring 的配置都放在一起。
首先都是 Spring MVC 的头，
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xmlns:mvc=&amp;#34;http://www.springframework.org/schema/mvc&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&amp;#34; default-lazy-init=&amp;#34;false&amp;#34;&amp;gt; 这里还是要注意这个 default-lazy-init=&amp;quot;false&amp;quot; 这句。
配置外在应用参数。有些参数写在xml虽然可以，但是经常会更改，这些数据可以放到 properties 的文件里，比如用户名，管理员密码等。
&amp;lt;context:property-placeholder location=&amp;#34;classpath:properties/resource.properties&amp;#34;/&amp;gt; 配组件扫描。由于这个项目使用的是注解形式搭建的，所以需要组件扫描器扫描特定包中的注解。这里要说明的是，因为 Spring MVC 主要面向的是前段控制层，所以 Spring MVC 扫描的是 Controller 包的注解。
&amp;lt;context:component-scan base-package=&amp;#34;com.summer.controller&amp;#34;/&amp;gt; 接下来配置的是注解驱动。这个还是蛮重要的，如果不配置，导致注解不能被解析，@RequestMapping 不能使用。</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>web.xml 配置好了之后（实际上也可以最后配置），还需要配置 web.xml 里面的涉及到一些文件。
先配置 <code>servlet</code> 标签中涉及到的 springmvc.xml。
DispatcherServlet 是前端控制器设计模式的实现，对于前段控制对应的就是 Spring MVC。</p>
<h1 id="springmvcxml">springmvc.xml</h1>
<p>springmvc.xml 的配置是在 <code>web.xml</code> 中的 <code>servlet</code> 标签中的 <code>init-param</code> 中设置。这里可以更改 xml 的位置和名称。我记得如果不配，默认是会在 WEB-INF 中创建一个 DispatcherServlet 的文件。现在我指定在了 resources 目录里面，将 Spring 的配置都放在一起。</p>
<p>首先都是 Spring MVC 的头，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style="color:#f92672">&lt;beans</span> <span style="color:#a6e22e">xmlns=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans&#34;</span>
       <span style="color:#a6e22e">xmlns:xsi=</span><span style="color:#e6db74">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
       <span style="color:#a6e22e">xmlns:context=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/context&#34;</span>
       <span style="color:#a6e22e">xmlns:mvc=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/mvc&#34;</span>
       <span style="color:#a6e22e">xsi:schemaLocation=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&#34;</span>
        <span style="color:#a6e22e">default-lazy-init=</span><span style="color:#e6db74">&#34;false&#34;</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>这里还是要注意这个 <code>default-lazy-init=&quot;false&quot;</code> 这句。</p>
<p>配置外在应用参数。有些参数写在xml虽然可以，但是经常会更改，这些数据可以放到 properties 的文件里，比如用户名，管理员密码等。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;context:property-placeholder</span> <span style="color:#a6e22e">location=</span><span style="color:#e6db74">&#34;classpath:properties/resource.properties&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>配组件扫描。由于这个项目使用的是注解形式搭建的，所以需要组件扫描器扫描特定包中的注解。这里要说明的是，因为 Spring MVC 主要面向的是前段控制层，所以 Spring MVC 扫描的是 Controller 包的注解。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;context:component-scan</span> <span style="color:#a6e22e">base-package=</span><span style="color:#e6db74">&#34;com.summer.controller&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>接下来配置的是注解驱动。这个还是蛮重要的，如果不配置，导致注解不能被解析，<code>@RequestMapping</code> 不能使用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;mvc:annotation-driven</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>接下来配置视图解析器，个人理解就是读取 jsp 文件的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;org.springframework.web.servlet.view.InternalResourceViewResolver&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;viewResolver&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;prefix&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;/WEB-INF/jsp/&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;suffix&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;.jsp&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/bean&gt;</span>
</code></pre></div><p>然后设置静态资源映射，就是 css 和 js 文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;mvc:resources</span> <span style="color:#a6e22e">mapping=</span><span style="color:#e6db74">&#34;/js/**&#34;</span> <span style="color:#a6e22e">location=</span><span style="color:#e6db74">&#34;/WEB-INF/js/&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;mvc:resources</span> <span style="color:#a6e22e">mapping=</span><span style="color:#e6db74">&#34;/css/**&#34;</span> <span style="color:#a6e22e">location=</span><span style="color:#e6db74">&#34;/WEB-INF/css/&#34;</span> <span style="color:#f92672">/&gt;</span>
</code></pre></div><p>如果需要上传文件，还需要配置多部分解析器（可选）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;org.springframework.web.multipart.commons.CommonsMultipartResolver&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;multipartResolver&#34;</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;defaultEncoding&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;UTF-8&#34;</span> <span style="color:#f92672">/&gt;</span>
        <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;maxUploadSize&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;5242880&#34;</span> <span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/bean&gt;</span>
<span style="color:#f92672">&lt;/beans&gt;</span>
</code></pre></div><h1 id="注意">注意</h1>
<p>在配置 Spring MVC 的配置文件时会牵扯到一些父子容器的问题。简单的说就是子容器(Spring MVC) 可以访问父容器（Spring）的对象，而父容器不能访问子容器的对象。使用 <code>@Value</code> 对参数进行注入。</p>
<h1 id="总结">总结</h1>
<p>很简单的一个配置文件。这个文件主要配置的都是控制和视图方面的 <code>bean</code>。这个文件中一共配置了：</p>
<ul>
<li>属性持有，context:property-placeholder，用来加载外在参数。</li>
<li>组件扫描，context:component-scan，用来注册注解。</li>
<li>注解驱动，mvc:annotation-driven，用来解析注解。</li>
<li>资源视图解析器，bean，InternalResourceViewResolver就行，用来加载jsp的。</li>
<li>静态资源映射，mvc:resources，用来配置 js 和 css 文件。</li>
<li>多部分解析器（可选），bean， CommonsMultipartResolver，用于上传文件。</li>
</ul>
<h1 id="参考">参考</h1>
<p><a href="https://github.com/TomorrowOnceMore/SummerMVC/blob/master/summer-manager/summer-manager-web/src/main/resources/spring/springmvc.xml">我的项目</a></p>
<p><a href="http://www.cnblogs.com/zyzcj/p/5286190.html">Spring 和SpringMVC 的父子容器关系</a></p>
]]></content>
        </item>
        
        <item>
            <title>Spring Configuration - web.xml</title>
            <link>http://keltoy.github.io/posts/spring-configuration-web-xml/</link>
            <pubDate>Tue, 18 Oct 2016 23:46:34 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/spring-configuration-web-xml/</guid>
            <description>前言 关于 Spring 这个框架无需多说了，很经典了，这里先复习一下它的配置。话说不复习还真容易忘了。
Spring 配置 主要还是通过学习的项目，对 Spring, Spring MVC 和 Mybatis 这三大框架的配置进行复习，主要对 Spring的框架配置进行复习。
web.xml 此文件的目录是 src/main/webapp/WEB-INF/，该目录下还有 css, js, jsp 这三个目录。
&amp;lt;!DOCTYPE web-app PUBLIC &amp;#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&amp;#34; &amp;#34;http://java.sun.com/dtd/web-app_2_3.dtd&amp;#34; &amp;gt; &amp;lt;web-app xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns=&amp;#34;http://java.sun.com/xml/ns/javaee&amp;#34; xsi:schemaLocation=&amp;#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&amp;#34; id=&amp;#34;WebApp_ID&amp;#34; version=&amp;#34;2.5&amp;#34;&amp;gt; 以上内容基本不怎么更改，使用默认的就行。 设置项目名称：
&amp;lt;display-name&amp;gt;summer&amp;lt;/display-name&amp;gt; 定制欢迎页，就是设置首页方式，首次访问的时候就会跳转到 welcome-file 设置的文件中。
&amp;lt;welcome-file-list&amp;gt; &amp;lt;welcome-file&amp;gt;index.html&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;index.htm&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;default.html&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;default.htm&amp;lt;/welcome-file&amp;gt; &amp;lt;welcome-file&amp;gt;default.jsp&amp;lt;/welcome-file&amp;gt; &amp;lt;/welcome-file-list&amp;gt; context-param 用来声明应用范围(整个WEB项目)内的上下文初始化参数。个人理解就是加载 Spring 配置文件，初始化 Spring 容器。 param-name 设定上下文的参数名称。必须是唯一名称。 param-value 设定的参数名称的值，可以设置为目录文件。
&amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:spring/applicationContext*.xml&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; 设置监听器。引用他人的介绍：
 ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。 因为它实现了ServletContextListener这个接口，在web.</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>关于 Spring 这个框架无需多说了，很经典了，这里先复习一下它的配置。话说不复习还真容易忘了。</p>
<h1 id="spring-配置">Spring 配置</h1>
<p>主要还是通过学习的项目，对 Spring, Spring MVC 和 Mybatis 这三大框架的配置进行复习，主要对 Spring的框架配置进行复习。</p>
<h2 id="webxml">web.xml</h2>
<p>此文件的目录是 <code>src/main/webapp/WEB-INF/</code>，该目录下还有 css, js, jsp 这三个目录。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;!DOCTYPE web-app PUBLIC
</span><span style="color:#75715e">        &#34;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&#34;
</span><span style="color:#75715e">        &#34;http://java.sun.com/dtd/web-app_2_3.dtd&#34; &gt;</span>

<span style="color:#f92672">&lt;web-app</span> <span style="color:#a6e22e">xmlns:xsi=</span><span style="color:#e6db74">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span> <span style="color:#a6e22e">xmlns=</span><span style="color:#e6db74">&#34;http://java.sun.com/xml/ns/javaee&#34;</span> <span style="color:#a6e22e">xsi:schemaLocation=</span><span style="color:#e6db74">&#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&#34;</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;WebApp_ID&#34;</span> <span style="color:#a6e22e">version=</span><span style="color:#e6db74">&#34;2.5&#34;</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>以上内容基本不怎么更改，使用默认的就行。
设置项目名称：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;display-name&gt;</span>summer<span style="color:#f92672">&lt;/display-name&gt;</span>
</code></pre></div><p>定制欢迎页，就是设置首页方式，首次访问的时候就会跳转到 <code>welcome-file</code> 设置的文件中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;welcome-file-list&gt;</span>
        <span style="color:#f92672">&lt;welcome-file&gt;</span>index.html<span style="color:#f92672">&lt;/welcome-file&gt;</span>
        <span style="color:#f92672">&lt;welcome-file&gt;</span>index.htm<span style="color:#f92672">&lt;/welcome-file&gt;</span>
        <span style="color:#f92672">&lt;welcome-file&gt;</span>index.jsp<span style="color:#f92672">&lt;/welcome-file&gt;</span>
        <span style="color:#f92672">&lt;welcome-file&gt;</span>default.html<span style="color:#f92672">&lt;/welcome-file&gt;</span>
        <span style="color:#f92672">&lt;welcome-file&gt;</span>default.htm<span style="color:#f92672">&lt;/welcome-file&gt;</span>
        <span style="color:#f92672">&lt;welcome-file&gt;</span>default.jsp<span style="color:#f92672">&lt;/welcome-file&gt;</span>
    <span style="color:#f92672">&lt;/welcome-file-list&gt;</span>
</code></pre></div><p><code>context-param</code> 用来声明应用范围(整个WEB项目)内的上下文初始化参数。个人理解就是加载 Spring 配置文件，初始化 Spring 容器。
<code>param-name</code> 设定上下文的参数名称。必须是唯一名称。
<code>param-value</code> 设定的参数名称的值，可以设置为目录文件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;context-param&gt;</span>
        <span style="color:#f92672">&lt;param-name&gt;</span>contextConfigLocation<span style="color:#f92672">&lt;/param-name&gt;</span>
        <span style="color:#f92672">&lt;param-value&gt;</span>classpath:spring/applicationContext*.xml<span style="color:#f92672">&lt;/param-value&gt;</span>
    <span style="color:#f92672">&lt;/context-param&gt;</span>
</code></pre></div><p>设置监听器。引用他人的介绍：</p>
<blockquote>
<p>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。
因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。
ContextLoaderListener启动的上下文为根上下文，DispatcherServlet所创建的上下文的的父上下文即为此根上下文，可在FrameworkServlet中的initWebApplicationContext中看出。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;listener&gt;</span>
        <span style="color:#f92672">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span style="color:#f92672">&lt;/listener-class&gt;</span>
    <span style="color:#f92672">&lt;/listener&gt;</span>
</code></pre></div><p>设置过滤器。这里需要说明的就是过滤器和Spring AOP 中的拦截器的区别和联系。</p>
<p>Spring的拦截器与Servlet的Filter有相似之处，比如二者都是AOP编程思想的体现，都能实现权限检查、日志记录等。</p>
<ul>
<li>
<p>使用范围不同：Filter是Servlet规范规定的，只能用于Web程序中。而拦截器既可以用于Web程序，也可以用于Application、Swing程序中。</p>
</li>
<li>
<p>规范不同：Filter是在Servlet规范中定义的，是Servlet容器支持的。而拦截器是在Spring容器内的，是Spring框架支持的。</p>
</li>
<li>
<p>使用的资源不同：同其他的代码块一样，拦截器也是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如Service对象、数据源、事务管理等，通过IoC注入到拦截器即可；而Filter则不能。</p>
</li>
<li>
<p>深度不同：Filter在只在Servlet前后起作用。而拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。所以在Spring构架的程序中，要优先使用拦截器。</p>
</li>
</ul>
<p>可以看出</p>
<table>
<thead>
<tr>
<th></th>
<th>Filter</th>
<th>Interceptor</th>
</tr>
</thead>
<tbody>
<tr>
<td>规范</td>
<td>Servlet 规范规定的</td>
<td>Spring 容器规定的</td>
</tr>
<tr>
<td>使用范围</td>
<td>只能用于 Web</td>
<td>可以用去其他程序</td>
</tr>
<tr>
<td>使用资源</td>
<td>基本不能使用资源</td>
<td>可以使用 Spring 配置的任何资源</td>
</tr>
<tr>
<td>深度</td>
<td>只在 Servlet 前后起作用</td>
<td>可以深入到方法，异常前后</td>
</tr>
</tbody>
</table>
<p>还有他人总结的区别：</p>
<ol>
<li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li>
<li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li>
<li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li>
<li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li>
<li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li>
<li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li>
</ol>
<p>我的理解是，拦截器因为是Spring的一个模块，因此可以不在 Web 中使用，可以调用 Spring 的资源，可以升入到方法；
而过滤器要依赖于 Servlet， 所以只呢个在 Web 中使用，初始化容器，初始化 Servlet 的时候调用。</p>
<p>主要顺序是：</p>
<pre><code>Filter pre -&gt; service -&gt; dispatcher -&gt; preHandle -&gt; Controller -&gt; postHandle -&gt; afterCompletion -&gt; Filter after
</code></pre><p>当客户端发出Web资源的请求时，Web服务器根据应用程序配置文件设置的过滤规则进行检查，若客户请求满足过滤规则，则对客户请求／响应进行拦截，对请求头和请求数据进行检查或改动，并依次通过过滤器链，最后把请求／响应交给请求的Web资源处理。请求信息在过滤器链中可以被修改，也可以根据条件让请求不发往资源处理器，并直接向客户机发回一个响应。当资源处理器完成了对资源的处理后，响应信息将逐级逆向返回。同样在这个过程中，用户可以修改响应信息，从而完成一定的任务。
基本上过滤器也是在拦截请求和响应，过滤 request 和 response 信息。
这里就配置了字符编码的信息，过滤掉乱码的情况 <code>url-pattern</code> 设置所有情况。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;filter&gt;</span>
        <span style="color:#f92672">&lt;filter-name&gt;</span>characterEncodingFilter<span style="color:#f92672">&lt;/filter-name&gt;</span>
        <span style="color:#f92672">&lt;filter-class&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span style="color:#f92672">&lt;/filter-class&gt;</span>
    <span style="color:#f92672">&lt;/filter&gt;</span>
    <span style="color:#f92672">&lt;filter-mapping&gt;</span>
        <span style="color:#f92672">&lt;filter-name&gt;</span>characterEncodingFilter<span style="color:#f92672">&lt;/filter-name&gt;</span>
        <span style="color:#f92672">&lt;url-pattern&gt;</span>/*<span style="color:#f92672">&lt;/url-pattern&gt;</span>
    <span style="color:#f92672">&lt;/filter-mapping&gt;</span>
</code></pre></div><p>接下来配置 servlet。
DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点，而且负责职责的分派，而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处。
前段控制使用的是 Spring MVC，因此这里要配置 Spring MVC 的配置文件。<code>load-on-startup</code> 也需要配置，否则服务器也启动不起来。
然后对配置的 servlet 配置映射。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;servlet&gt;</span>
        <span style="color:#f92672">&lt;servlet-name&gt;</span>dispatcherServlet<span style="color:#f92672">&lt;/servlet-name&gt;</span>
        <span style="color:#f92672">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span style="color:#f92672">&lt;/servlet-class&gt;</span>
        <span style="color:#f92672">&lt;init-param&gt;</span>
            <span style="color:#f92672">&lt;param-name&gt;</span>contextConfigLocation<span style="color:#f92672">&lt;/param-name&gt;</span>
            <span style="color:#f92672">&lt;param-value&gt;</span>classpath:spring/springmvc.xml<span style="color:#f92672">&lt;/param-value&gt;</span>
        <span style="color:#f92672">&lt;/init-param&gt;</span>
        <span style="color:#f92672">&lt;load-on-startup&gt;</span>1<span style="color:#f92672">&lt;/load-on-startup&gt;</span>
    <span style="color:#f92672">&lt;/servlet&gt;</span>
    <span style="color:#f92672">&lt;servlet-mapping&gt;</span>
        <span style="color:#f92672">&lt;servlet-name&gt;</span>dispatcherServlet<span style="color:#f92672">&lt;/servlet-name&gt;</span>
        <span style="color:#f92672">&lt;url-pattern&gt;</span>/<span style="color:#f92672">&lt;/url-pattern&gt;</span>
    <span style="color:#f92672">&lt;/servlet-mapping&gt;</span>
<span style="color:#f92672">&lt;/web-app&gt;</span>
</code></pre></div><h1 id="总结">总结</h1>
<p>在 web.xml 文件中，我配置了这几项内容：</p>
<ul>
<li>项目名称，display-name。</li>
<li>定制欢迎页方式，welcome-file-list。</li>
<li>设置上下文初始化参数（加载 Spring 配置文件，初始化 Spring 容器），context-param。</li>
<li>设置监听器（默认的Context就行），listener。</li>
<li>设置过滤器和过滤器映射，filter， filter-mapping。</li>
<li>还有设置servlet（servletDispatcher）。</li>
</ul>
<h1 id="参考">参考</h1>
<p><a href="https://github.com/TomorrowOnceMore/SummerMVC/blob/master/summer-manager/summer-manager-web/src/main/resources/spring/springmvc.xml">我的项目</a></p>
<p><a href="http://blog.csdn.net/zjw10wei321/article/details/40145241">SpringMVC容器初始化篇&mdash;-ContextLoaderListener</a></p>
<p><a href="http://blog.csdn.net/chenleixing/article/details/44573495">Java过滤器与SpringMVC拦截器之间的关系与区别</a></p>
]]></content>
        </item>
        
        <item>
            <title>Class Loaders in Java</title>
            <link>http://keltoy.github.io/posts/class-loaders-in-java/</link>
            <pubDate>Thu, 13 Oct 2016 12:13:07 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/class-loaders-in-java/</guid>
            <description>前言 好像一直没搞明白，但是每次都会被问到，总结总结，看看自己的理解到哪一步了。
初识 Class Loaders 首先，类加载器的架构：
+-----------------+ | | | +-------------+ | +--------------------------------+ | | Bootstrap | | &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; | Load JRE/lib/rt.jar | | | ClassLoader | | &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; | specified by -Xbootclasspath | | +-------------+ | +--------------------------------+ | | | +-------------+ | +--------------------------------+ | | Extension | | &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; | Load JRE/lib/ext/*.jar | | | ClassLoader | | &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; | specified by -Djava.ext.dirs | | +-------------+ | +--------------------------------+ | | | +-------------+ | +--------------------------------+ | | App | | &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; | Load CLASSPATH | | | ClassLoader | | &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; | specified by -Djava.</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>好像一直没搞明白，但是每次都会被问到，总结总结，看看自己的理解到哪一步了。</p>
<h1 id="初识-class-loaders">初识 Class Loaders</h1>
<p>首先，类加载器的架构：</p>
<pre><code>+-----------------+
|                 |
| +-------------+ |              +--------------------------------+
| | Bootstrap   | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Load JRE/lib/rt.jar            |
| | ClassLoader | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | specified by -Xbootclasspath   |
| +-------------+ |              +--------------------------------+
|                 |
| +-------------+ |              +--------------------------------+
| | Extension   | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Load JRE/lib/ext/*.jar         |
| | ClassLoader | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | specified by -Djava.ext.dirs   |
| +-------------+ |              +--------------------------------+
|                 |
| +-------------+ |              +--------------------------------+
| | App         | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Load CLASSPATH                 |
| | ClassLoader | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | specified by -Djava.class.path |
| +-------------+ |              +--------------------------------+
|                 |
| +-------------+ |              +--------------------------------+
| | Custom      | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Use subclass of                |
| | ClassLoader | | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | java.lang.ClassLoader          |
| +-------------+ |              +--------------------------------+
|                 |
+-----------------+
</code></pre><ul>
<li>
<p>Bootstrap ClassLoader
负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类;</p>
</li>
<li>
<p>Extension ClassLoader
负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包;</p>
</li>
<li>
<p>App ClassLoader
负责记载classpath中指定的jar包及目录中class;</p>
</li>
<li>
<p>Custom ClassLoader
属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据J2EE规范自行实现ClassLoader.</p>
</li>
</ul>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。这个过程叫做双亲委派制度。</p>
<h1 id="思考-class-loaders">思考 Class Loaders</h1>
<p>看起来就是这么回事。既然知道了有这么多 ClassLoader 类，那我忍不住要问类是如何加载的？翻一翻讲 ClassLoader 的书，或者博客，他们都会告诉我分为三个部分：</p>
<ol>
<li>加载：查找并加载类的二进制数据；</li>
<li>链接，分为三步；</li>
</ol>
<ul>
<li>验证：确保被加载类的正确性；</li>
<li>准备：为类的静态变量分配内存，并将其初始化为默认值；</li>
<li>解析：把类中的符号引用转换为直接引用；</li>
</ul>
<ol start="3">
<li>初始化：为类的静态变量赋予正确的初始值。</li>
</ol>
<p>嗯嗯。</p>
<h1 id="再识-class-loaders">再识 Class Loaders</h1>
<p>我们知道，Java 类的生命周期分为 7 个阶段：</p>
<pre><code>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载
</code></pre>
<p>这个其实我才知道&hellip;
而这其中，验证、准备和解析统称为链接。
加载、验证、准备、初始化还有卸载这五个阶段的顺序是确定的。
解析有可能在初始化后才执行，说是为了执行 java 类的运行时绑定，呃，说是什么就是什么吧&hellip;
这里说一下，Java 在编译过程中，实际上只是生成 .class 文件，也就是生成了字节码，然后再使用JVM进行解释。虽然有JIT优化，把 .class 文件的二进制代码编译成本地代码直接运行，但是从原理来讲，还是解释型的。</p>
<h2 id="加载">加载</h2>
<p>什么情况下对类加载？这个我在 <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/index.html">Java 虚拟机规范 (The Java® Virtual Machine Specification)</a> 没有找到确定的情况，但是这个操作是在初始化之前的。有人说加载过程交给 JVM 实现自由把握，不论怎么说，类的加载就是在虚拟机开始后，通过调用 Class Loaders 加载了类。</p>
<h2 id="链接">链接</h2>
<p>链接分为验证、准备和解析三个部分，JVMS 中原话是这么说的：</p>
<blockquote>
<p>Linking a class or interface involves verifying and preparing that class or interface, its direct superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Resolution of symbolic references in the class or interface is an optional part of linking.
This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that all of the following properties are maintained:
A class or interface is completely loaded before it is linked.
A class or interface is completely verified and prepared before it is initialized.
Errors detected during linkage are thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.
For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used (&ldquo;lazy&rdquo; or &ldquo;late&rdquo; resolution), or to resolve them all at once when the class is being verified (&ldquo;eager&rdquo; or &ldquo;static&rdquo; resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized. Whichever strategy is followed, any error detected during resolution must be thrown at a point in the program that (directly or indirectly) uses a symbolic reference to the class or interface.
Because linking involves the allocation of new data structures, it may fail with an OutOfMemoryError.</p>
</blockquote>
<p>大概意思就是说，链接包括验证和准备这两个类或接口，以及他们的直接父类和接口，还有数组类型的元素类型。解析不一定在链接里。
链接的时机灵活，但必须满足以下几点：</p>
<ul>
<li>类或接口链接之前，必须被成功加载过；</li>
<li>类或接口初始化之前， 必须被成功验证和准备过；</li>
<li>程序执行了某种可能需要直接或间接链接一个类或接口的动作，在链接该类或接口过程中检测到了错误，错误的抛出点应该是执行动作的那个点。</li>
</ul>
<p>这个过程可能会引发OutOfMemoryError。</p>
<p>我的理解就是，链接的开始必须在加载开始之后，在初始化之前完成。</p>
<h2 id="验证">验证</h2>
<p>以下的内容是我在网上找到的一些内容，虚拟机规范是在太长了，等慢慢看完了再来了解这方面的内容。</p>
<blockquote>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
Java语言本身是相对安全的语言，使用Java编码是无法做到如访问数组边界以外的数据、将一个对象转型为它并未实现的类型等，如果这样做了，编译器将拒绝编译。但是，Class文件并不一定是由Java源码编译而来，可以使用任何途径，包括用十六进制编辑器(如UltraEdit)直接编写。如果直接编写了有害的“代码”(字节流)，而虚拟机在加载该Class时不进行检查的话，就有可能危害到虚拟机或程序的安全。
不同的虚拟机，对类验证的实现可能有所不同，但大致都会完成下面四个阶段的验证 ：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<ol>
<li>文件格式验证，是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。如验证魔数是否0xCAFEBABE；主、次版本号是否正在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型……该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区中，经过这个阶段的验证后，字节流才会进入内存的方法区中存储，所以后面的三个验证阶段都是基于方法区的存储结构进行的。</li>
<li>元数据验证，是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。可能包括的验证如：这个类是否有父类；这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法……</li>
<li>字节码验证，主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</li>
<li>符号引用验证，发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在“解析阶段”中发生。验证符号引用中通过字符串描述的权限定名是否能找到对应的类；在指定类中是否存在符合方法字段的描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问。</li>
</ol>
</blockquote>
<blockquote>
<p>验证阶段对于虚拟机的类加载机制来说，不一定是必要的阶段。如果所运行的全部代码确认是安全的， 可以使用 -Xverify：none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。</p>
</blockquote>
<h2 id="准备">准备</h2>
<p>继续查看规范：</p>
<blockquote>
<p>Preparation involves creating the static fields for a class or interface and initializing such fields to their default values (§2.3, §2.4). This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (§5.5), not preparation.</p>
</blockquote>
<p>这个阶段是创建类或接口的静态字段，不执行任何字节码指令。初始化阶段会有显示的初始化器来初始化这些字段，所以准备阶段不初始化字段。
这里有个小问题就是，准备阶段不初始化，但是他会给定这些静态字段的缺省值，比如 0，null。
静态代码实际上是存在 Method Area 中的。</p>
<h2 id="解析">解析</h2>
<p>继续查看规范：</p>
<blockquote>
<p>The Java Virtual Machine instructions anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, and putstatic make symbolic references to the run-time constant pool. Execution of any of these instructions requires resolution of its symbolic reference.
Resolution is the process of dynamically determining concrete values from symbolic references in the run-time constant pool.</p>
</blockquote>
<p>虚拟机指令将符号引用指向 run-time constant pool。
解析就是根据 run-time constant pool 里的符号引用来动态决定具体值的过程。
好绕口，什么是符号引用？
看一看别人的博客，是这么介绍的：</p>
<blockquote>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</p>
</blockquote>
<h2 id="初始化">初始化</h2>
<p>什么情况初始化，虚拟机规范有明确的要求：</p>
<blockquote>
<p>Initialization of a class or interface consists of executing its class or interface initialization method (§2.9).</p>
</blockquote>
<blockquote>
<p>A class or interface C may be initialized only as a result of:</p>
</blockquote>
<blockquote>
<p>· The execution of any one of the Java Virtual Machine instructions new, getstatic, putstatic, or invokestatic that references C (§new, §getstatic, §putstatic, §invokestatic). These instructions reference a class or interface directly or indirectly through either a field reference or a method reference.
Upon execution of a new instruction, the referenced class is initialized if it has not been initialized already.
Upon execution of a getstatic, putstatic, or invokestatic instruction, the class or interface that declared the resolved field or method is initialized if it has not been initialized already.
·The first invocation of a java.lang.invoke.MethodHandle instance which was the result of method handle resolution (§5.4.3.5) for a method handle of kind 2 (REF_getStatic), 4 (REF_putStatic), 6 (REF_invokeStatic), or 8 (REF_newInvokeSpecial).
This implies that the class of a bootstrap method is initialized when the bootstrap method is invoked for an invokedynamic instruction (§invokedynamic), as part of the continuing resolution of the call site specifier.
· Invocation of certain reflective methods in the class library (§2.12), for example, in class Class or in package java.lang.reflect.
· If C is a class, the initialization of one of its subclasses.
· If C is an interface that declares a non-abstract, non-static method, the initialization of a class that implements C directly or indirectly.
· If C is a class, its designation as the initial class at Java Virtual Machine startup (§5.2).
Prior to initialization, a class or interface must be linked, that is, verified, prepared, and optionally resolved.</p>
</blockquote>
<p>就是说有这么几种情况，类或者接口会初始化：</p>
<ul>
<li>Java 虚拟机调用这些指令 new, getstatic, putstatic, or invokestatic,使用一个字段引用。个人理解就是创建实例的过程，例如 <code>Object obj = new Object</code> 这样。new 指令在引用的时候就初始化， 其他指令在申明解析字段和方法的时候进行初始化。</li>
<li>java.lang.invoke.MethodHandle 实例的第一次调用，调用执行的结果为 JVM 解析出的方法句柄。</li>
<li>调用反射方法。</li>
<li>子类初始化之前，父类要初始化。</li>
<li>作为 JVM 启动初始类。</li>
</ul>
<p>对于第二条关于 java.lang.invoke.MethodHandle 这一条不是很明白什么意思，所链接的 5.4.3.5 的介绍也都是在介绍解析。不过从方法上可以看出来，这一条应该是跟静态方法，或者说类方法有很大关系。这里偷个懒，从之前的博客中找到了一些蛛丝马迹：</p>
<blockquote>
<p>访问类的静态变量 (除常量【 被final修辞的静态变量】 原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。
访问类的静态方法</p>
</blockquote>
<p>也就是说，静态方法和静态变量的调用也会初始化类。</p>
<blockquote>
<p>类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。
初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。&lt;clinit&gt;()方法是由编译器自动 收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的 。</p>
</blockquote>
<h1 id="运行-class-loaders">运行 Class Loaders</h1>
<p>我们知道，类加载过程：
<code>父类静态初始化块 -&gt; 子类静态初始化块 -&gt; 父类非静态初始化块 -&gt;父类的构造方法 -&gt; 子类非静态初始化块 -&gt; 子类的构造方法</code>
不过我还是想试试，这里借用别人的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parent</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> parentStaticMethod2<span style="color:#f92672">();</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;父类非静态初始化块&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">static</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;父类静态初始化块&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Parent</span><span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;父类的构造方法&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">parentStaticMethod</span><span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;父类类的静态方法&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> 10<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">parentStaticMethod2</span><span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;父类的静态方法2&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> 9<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">finalize</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Throwable
    <span style="color:#f92672">{</span>
        <span style="color:#75715e">// TODO Auto-generated method stub
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">finalize</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;销毁父类&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Child</span> <span style="color:#66d9ef">extends</span> Parent <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticVirable <span style="color:#f92672">=</span> childStaticMethod2<span style="color:#f92672">();</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;子类非静态初始化块&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">static</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;子类静态初始化块&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Child</span><span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;子类的构造方法&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">childStaticMethod</span><span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;子类的静态方法&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> 1000<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">childStaticMethod2</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;子类静态方法2&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">finalize</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Throwable
    <span style="color:#f92672">{</span>
        <span style="color:#75715e">// TODO Auto-generated method stub
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">finalize</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;销毁子类&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@org.junit.Test</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testLoadOrder</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Child<span style="color:#f92672">.</span><span style="color:#a6e22e">parentStaticMethod</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>很有意思的情况，它的输出是：</p>
<pre><code>父类的静态方法2
父类静态初始化块
父类类的静态方法
</code></pre><p>虽然我调用的是 Child 类的方法，但是 Child 貌似并没有初始化。我个人觉得，这里的设计是不是跟 C++ 的 virtual table 差不多，只不过 Java 中所有的对象都是引用，因此都要建立这一张表呢？
不论如何，我们知道了调用父类的方法只会初始化父类，而不会初始化当前类。
继续观察结果，还会发现一些有意思的地方。我调用的是 parentStaticMethod，但是首先输出的是 parentStaticMethod2 的内容。也就是说，在类初始化之前，就已经调用了。因为 parentStaticMethod2 在静态变量中调用的，，也就说明了，静态变量要比类的初始化先完成。
原因是什么，我猜想是，静态变量应该是放在 Method Area 中，跟类的初始化是分离的，调用了静态变量之后，才会初始化类。
这里有人作出了解释：</p>
<blockquote>
<p>这是因为在编译的时候，常量（static final 修饰的）会存入调用类的常量池【一般说的是main函数所在的类的常量池】，调用的时候本质上没有引用到定义常量的类，而是直接访问了自己的常量池。所以，这里调用的时候，并没有初始化。</p>
</blockquote>
<p>不过经过测试，貌似静态变量调用的时候也不会立即初始化。
那么更改一下输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@org.junit.Test</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testLoadOrder</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Child<span style="color:#f92672">.</span><span style="color:#a6e22e">parentStaticMethod2</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>现加载常量池的变量
可以发现结果应该跟我们想的一样：</p>
<pre><code>父类的静态方法2
父类静态初始化块
父类的静态方法2
</code></pre><p>现在引入子类的调用方法，写一个 Test ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@org.junit.Test</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testLoadOrder2</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Child child <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Child<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>输出的结果：</p>
<pre><code>父类的静态方法2
父类静态初始化块
子类静态方法2
子类静态初始化块
父类非静态初始化块
父类的构造方法
子类非静态初始化块
子类的构造方法
</code></pre><p>可以看出，static 变量 和 static 块先进行初始化，然后再执行非静态和构造函数。必须等待 static 的数据父类和子类都处理结束，才会进行非 static 的初始化，也就是实例的初始化是在所有类 初始化的后面。</p>
<h1 id="再思-class-loaders">再思 Class Loaders</h1>
<p>初始化顺序的问题结束了，还需要总结一下。这里我就不总结了，直接拿别人的总结，不过这些内容我没有在 Java虚拟机规范中找到。</p>
<blockquote>
<p>触发类初始化的上述的几条的引用称为“主动引用” ，除此情况之外，均不会触发类的初始化，称为 “被动引用”。
接口的加载过程与类的加载过程稍有不同。接口中不能使用static{}块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。
子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。 。 对于静态字段，只有直接定义这个字段的类才会被初始化.
通过数组定义来引用类，不会触发类的初始化
访问类的常量，不会初始化类</p>
</blockquote>
<h1 id="三识-class-loaders">三识 Class Loaders</h1>
<p>既然明白了这些，感觉应该很透彻了。
那么，执行这样一段代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClassLoaderSingleton</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> ClassLoaderSingleton singleton <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ClassLoaderSingleton<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count2 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">ClassLoaderSingleton</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        count1<span style="color:#f92672">++;</span>
        count2<span style="color:#f92672">++;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ClassLoaderSingleton <span style="color:#a6e22e">getInstance</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> singleton<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ClassLoaderSingleton singleton <span style="color:#f92672">=</span> ClassLoaderSingleton<span style="color:#f92672">.</span><span style="color:#a6e22e">getInstance</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;count1=&#34;</span> <span style="color:#f92672">+</span> singleton<span style="color:#f92672">.</span><span style="color:#a6e22e">count1</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;count2=&#34;</span> <span style="color:#f92672">+</span> singleton<span style="color:#f92672">.</span><span style="color:#a6e22e">count2</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>输出的结果为：</p>
<pre><code>count1=1
count2=0
</code></pre><p>这样应该不会再出错了。</p>
<ul>
<li>singleton 调用 getInstance()， 调用了静态类方法，触发类初始化。</li>
<li>准备过程中为变量赋默认值。</li>
<li>类的静态变量分配内存并且执行静态方法，这个时候， singleton = null; count1 = 0; count2 = 0;</li>
<li>类初始化，为静态变量和执行静态代码块。然后执行构造方法。调用构造方法后 count1 = 1; count2 = 1;</li>
<li>然后继续赋值，此时 count1 没有赋值操作，所以 count1 = 1; count2 有值，所以 count2 = 0;</li>
</ul>
<h1 id="三思-class-loaders">三思 Class Loaders</h1>
<p>本以为看到这里应该不会再出现问题了，发现自己太连清了&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClassLoaderLimit</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 4<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
        b <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;init&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>b<span style="color:#f92672">);</span> <span style="color:#75715e">// 编译错误
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String hello <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello World&#34;</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这样是不能编译的，原因是：</p>
<blockquote>
<p>这是因为在类初始化的时候，就规定了，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的，只能赋值，不能访问。</p>
</blockquote>
<p>也就是说 static 块是要保证顺序的，只要把 static int b 放到 static 块之前就可以了。</p>
<h1 id="总结">总结</h1>
<p>原本只是想写写执行顺序和运行周期，然后发现越拉越长，遇到的问题也越来越多&hellip;.代码都是拷贝他人的，但是能够解决问题就好。
最后盗了一张图，看图说话&hellip;
<img src="http://odzz59auo.bkt.clouddn.com/classloader.png" alt="Java 编译和运行"></p>
<h1 id="参考">参考</h1>
<p><a href="http://docs.oracle.com/javase/specs/jvms/se8/html/">The Java® Virtual Machine Specification</a></p>
<p><a href="http://www.tuicool.com/articles/QZnENv">从一道面试题来认识java类加载时机与过程 - 天魂地煞</a></p>
<p><a href="http://blog.csdn.net/imzoer/article/details/8038249">Java 类的加载时机</a></p>
<p><a href="http://www.cnblogs.com/guoyuqiangf8/archive/2012/10/31/2748909.html">Java 中类的加载顺序</a></p>
<p><a href="http://www.360doc.com/content/14/0218/23/9440338_353675002.shtml">Java 程序编译和运行的过程</a></p>
]]></content>
        </item>
        
        <item>
            <title>Source Code in Java -- Integer</title>
            <link>http://keltoy.github.io/posts/source-code-in-java-integer/</link>
            <pubDate>Tue, 11 Oct 2016 00:41:30 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/source-code-in-java-integer/</guid>
            <description>前言  Most of you are familiar with the virtues of a programmer. There are three, of course: laziness, impatience, and hubris. &amp;ndash; Larry Wall
 细细数来，我好像还没有做过源码的东西，不看看优秀的源码，如何才能够有长远的进步呢？就从 Java 开始，边看边总结这些源码。先看Integer。
初识 Integer 首先Integer是一个类，包装 int 的类，为了更好地和其他方法和范型配合，所以需要把基础类型包装成一个类。既然是类当然就可以设置为 null，这是基本类型做不到的，基本类型初始化也只能是 0。 Integer 和 int 在实际操作过程中是可以相等的，Integer 在匹配 int 类型的数据的时候，就会自动装箱和拆箱。 基本上，我对 Integer 的理解也就到这个程度。这样就可以理解为什么以下的结果有所不同：
int i = 0; Integer i2 = 0; Integer i3 = new Integer(0); Integer i4 = new Integer(0); Integer i5 = 0; System.out.println(i == i2); // true System.</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>Most of you are familiar with the virtues of a programmer. There are three, of course: laziness, impatience, and hubris.
&ndash; Larry Wall</p>
</blockquote>
<p>细细数来，我好像还没有做过源码的东西，不看看优秀的源码，如何才能够有长远的进步呢？就从 Java 开始，边看边总结这些源码。先看Integer。</p>
<h1 id="初识-integer">初识 Integer</h1>
<p>首先Integer是一个类，包装 int 的类，为了更好地和其他方法和范型配合，所以需要把基础类型包装成一个类。既然是类当然就可以设置为 null，这是基本类型做不到的，基本类型初始化也只能是 0。
Integer 和 int 在实际操作过程中是可以相等的，Integer 在匹配 int 类型的数据的时候，就会自动装箱和拆箱。
基本上，我对 Integer 的理解也就到这个程度。这样就可以理解为什么以下的结果有所不同：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> i  <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
Integer i2 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
Integer i3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
Integer i4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
Integer i5 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> i2<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> i3<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i4 <span style="color:#f92672">==</span> i3<span style="color:#f92672">);</span> <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i5 <span style="color:#f92672">==</span> i2<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span></code></pre></div><p>理由其实很简单，每次和整型的操作都有装箱或者拆箱的过程，实际上的值比的就是值；而 new 一个实例这时候就是一个对象，则不完成自动拆箱的过程，也就不会相等了。</p>
<h1 id="思考-integer">思考 Integer</h1>
<p>但是，就这样还不够。Integer 的内部原理都没有出来，内部的自动装箱和拆箱是如何实现的。这些问题都没看过，很容易出问题。比如说：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">int</span> i0 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> j0 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        Integer i1 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        Integer i2 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        Integer i3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        Integer i4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        Integer j1 <span style="color:#f92672">=</span> 128<span style="color:#f92672">;</span>
        Integer j2 <span style="color:#f92672">=</span> 128<span style="color:#f92672">;</span>
        Integer j3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>128<span style="color:#f92672">);</span>
        Integer j4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>128<span style="color:#f92672">);</span>

        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i0 == i1: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i0 <span style="color:#f92672">==</span> i1<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i0 == i3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i0 <span style="color:#f92672">==</span> i3<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i1 == i2: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i2 <span style="color:#f92672">==</span> i1<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i1 == i3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i1 <span style="color:#f92672">==</span> i3<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i3 == i4: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i3 <span style="color:#f92672">==</span> i4<span style="color:#f92672">));</span>


        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j0 == j1: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j0 <span style="color:#f92672">==</span> j1<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j0 == j3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j0 <span style="color:#f92672">==</span> j3<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j1 == j2: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j2 <span style="color:#f92672">==</span> j1<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j1 == j3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j1 <span style="color:#f92672">==</span> j3<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j3 == j4: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j3 <span style="color:#f92672">==</span> j4<span style="color:#f92672">));</span>
</code></pre></div><p>结果是：</p>
<pre><code>i0 == i1: true
i0 == i3: true
i1 == i2: true
i1 == i3: false
i3 == i4: false
j0 == j1: false
j0 == j3: false
j1 == j2: false
j1 == j3: false
j3 == j4: false
</code></pre>
<p>说明一下，测试数据的时候，我的 JDK 版本为 1.8。
我当时觉得很奇妙，按理说 i0 == i1 和 j0 == j1 应该没有什么区别，为什么一个是 true，一个是 false？我当时的理解是，肯定有一个做了拆箱操作，另一个实际上是对象的比较。如果这样的猜测是正确的，那么也就是说拆箱操作是有选择的。
于是，对于这样的猜测，我看了一下字节码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">        <span style="color:#66d9ef">byte</span> i0 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">byte</span> j0 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        Integer i1 <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        Integer i2 <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        Integer i3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        Integer i4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        Integer j1 <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>128<span style="color:#f92672">);</span>
        Integer j2 <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>128<span style="color:#f92672">);</span>
        Integer j3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>128<span style="color:#f92672">);</span>
        Integer j4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>128<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i0 == i1: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i0 <span style="color:#f92672">==</span> i1<span style="color:#f92672">.</span><span style="color:#a6e22e">intValue</span><span style="color:#f92672">()));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i0 == i3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i0 <span style="color:#f92672">==</span> i3<span style="color:#f92672">.</span><span style="color:#a6e22e">intValue</span><span style="color:#f92672">()));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i1 == i2: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i2 <span style="color:#f92672">==</span> i1<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i1 == i3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i1 <span style="color:#f92672">==</span> i3<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i3 == i4: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>i3 <span style="color:#f92672">==</span> i4<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j0 == j1: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j0 <span style="color:#f92672">==</span> j1<span style="color:#f92672">.</span><span style="color:#a6e22e">intValue</span><span style="color:#f92672">()));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j0 == j3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j0 <span style="color:#f92672">==</span> j3<span style="color:#f92672">.</span><span style="color:#a6e22e">intValue</span><span style="color:#f92672">()));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j1 == j2: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j2 <span style="color:#f92672">==</span> j1<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j1 == j3: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j1 <span style="color:#f92672">==</span> j3<span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;j3 == j4: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>j3 <span style="color:#f92672">==</span> j4<span style="color:#f92672">));</span>
</code></pre></div><p>可以看出拆箱的过程就是使用 Integer.valueOf()的过程。现在转入 Integer 类中查看这是如何操作的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">     * Returns an {@code Integer} instance representing the specified
</span><span style="color:#75715e">     * {@code int} value.  If a new {@code Integer} instance is not
</span><span style="color:#75715e">     * required, this method should generally be used in preference to
</span><span style="color:#75715e">     * the constructor {@link #Integer(int)}, as this method is likely
</span><span style="color:#75715e">     * to yield significantly better space and time performance by
</span><span style="color:#75715e">     * caching frequently requested values.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * This method will always cache values in the range -128 to 127,
</span><span style="color:#75715e">     * inclusive, and may cache other values outside of this range.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * @param  i an {@code int} value.
</span><span style="color:#75715e">     * @return an {@code Integer} instance representing {@code i}.
</span><span style="color:#75715e">     * @since  1.5
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Integer <span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">low</span> <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&lt;=</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">high</span><span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">cache</span><span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> <span style="color:#f92672">(-</span>IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">low</span><span style="color:#f92672">)];</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>这段代码倒是简单，上面的注释看起来好像很重要。大概意思是说<code>从 1.5以后java的包装类支持自动装箱操作了，时间和空间都还不错，调用这个方法总是缓存 -128 到 127 的结果，也可以韩村这个范围之外的其他值。</code>
为什么是 -128 到 127， 还有，IntegerCache又是什么？围绕这两个问题，继续跳转，发现 IntegerCache实际上就在当前文件里，属于 Integer的一个内部类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">     * Cache to support the object identity semantics of autoboxing for values between
</span><span style="color:#75715e">     * -128 and 127 (inclusive) as required by JLS.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * The cache is initialized on first usage.  The size of the cache
</span><span style="color:#75715e">     * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.
</span><span style="color:#75715e">     * During VM initialization, java.lang.Integer.IntegerCache.high property
</span><span style="color:#75715e">     * may be set and saved in the private system properties in the
</span><span style="color:#75715e">     * sun.misc.VM class.
</span><span style="color:#75715e">     */</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IntegerCache</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>128<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> high<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Integer cache<span style="color:#f92672">[];</span>

        <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// high value may be configured by property
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> 127<span style="color:#f92672">;</span>
            String integerCacheHighPropValue <span style="color:#f92672">=</span>
                sun<span style="color:#f92672">.</span><span style="color:#a6e22e">misc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">VM</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getSavedProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;java.lang.Integer.IntegerCache.high&#34;</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>integerCacheHighPropValue <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> parseInt<span style="color:#f92672">(</span>integerCacheHighPropValue<span style="color:#f92672">);</span>
                    i <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> 127<span style="color:#f92672">);</span>
                    <span style="color:#75715e">// Maximum array size is Integer.MAX_VALUE
</span><span style="color:#75715e"></span>                    h <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">-</span> <span style="color:#f92672">(-</span>low<span style="color:#f92672">)</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span> NumberFormatException nfe<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// If the property cannot be parsed into an int, ignore it.
</span><span style="color:#75715e"></span>                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            high <span style="color:#f92672">=</span> h<span style="color:#f92672">;</span>

            cache <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">[(</span>high <span style="color:#f92672">-</span> low<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> low<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;</span> cache<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span>
                cache<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>j<span style="color:#f92672">++);</span>

            <span style="color:#75715e">// range [-128, 127] must be interned (JLS7 5.1.7)
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">assert</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">high</span> <span style="color:#f92672">&gt;=</span> 127<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">IntegerCache</span><span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p>还是先看注释，上来就说 <code>cache 是支持自动装包的对象同等语义，Java语言规范 (Java Language Specification, JLS) 规定了其范围是-128, 127，cache在第一次使用的时候初始化，可以使用 -XX:AutoBoxCacheMax=&lt;size&gt; 更改cache的high，保存到 sun.misc.VM 类中。</code>
代码开起来比较简单，就是初始化一下。
那就是说，如果是 大于 -128， 小于 127，那么valueOf直接从 cache 中取出值，否则呢就创建一个Integer的对象：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e">    * The value of the {@code Integer}.
</span><span style="color:#75715e">    *
</span><span style="color:#75715e">    * @serial
</span><span style="color:#75715e">    */</span>
   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">;</span>

   <span style="color:#75715e">/**
</span><span style="color:#75715e">    * Constructs a newly allocated {@code Integer} object that
</span><span style="color:#75715e">    * represents the specified {@code int} value.
</span><span style="color:#75715e">    *
</span><span style="color:#75715e">    * @param   value   the value to be represented by the
</span><span style="color:#75715e">    *                  {@code Integer} object.
</span><span style="color:#75715e">    */</span>
   <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Integer</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
       <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>

   <span style="color:#75715e">/**
</span><span style="color:#75715e">        * Returns the value of this {@code Integer} as an
</span><span style="color:#75715e">        * {@code int}.
</span><span style="color:#75715e">        */</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">intValue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
</code></pre></div><p>没啥说的。</p>
<h1 id="再识-integer">再识 Integer</h1>
<p>貌似解决了上面的例子为什么会产生不同值，到这里应该不会再出错了。但是还没有结束。这么做有什么好处？为什么要这样设计？
如果使用 Integer 装箱的值超出了 cache 的范围，那么就会创建一个 Integer 对象，那么这个对象应该会被放到 JVM 的 Heap 上；而 cache 本身，因为是 final 类型，本身也是存在于 内部静态类中，所以我想应该是放在了 Method Area 的 Runtime Constant pool 中了吧？ 如果是这样的话，确实在范围内的速度要比范围外的稍微快一些。注意到这里的cache 使用了 flyweight pattern，也就是说，这么做带来的好处应该有是如果是更快地装箱和拆箱，节省内存，往大了说，减少 GC 的工作。那么为什么这么设计？我在 <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7">JLS</a> 中找到了这么一段话。</p>
<p>If the value p being boxed is an integer literal of type int between -128 and 127 inclusive (§3.10.1), or the boolean literal true or false (§3.10.3), or a character literal between &lsquo;\u0000&rsquo; and &lsquo;\u007f&rsquo; inclusive (§3.10.4), then let a and b be the results of any two boxing conversions of p. It is always the case that a == b.</p>
<p>Ideally, boxing a primitive value would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. The rule above is a pragmatic compromise, requiring that certain common values always be boxed into indistinguishable objects. The implementation may cache these, lazily or eagerly. For other values, the rule disallows any assumptions about the identity of the boxed values on the programmer&rsquo;s part. This allows (but does not require) sharing of some or all of these references. Notice that integer literals of type long are allowed, but not required, to be shared.</p>
<p>This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices. Less memory-limited implementations might, for example, cache all char and short values, as well as int and long values in the range of -32K to +32K.</p>
<p>A boxing conversion may result in an OutOfMemoryError if a new instance of one of the wrapper classes (Boolean, Byte, Character, Short, Integer, Long, Float, or Double) needs to be allocated and insufficient storage is available.</p>
<p>大概就是为了兼容一些小型设备吧&hellip;.</p>
<h1 id="三识-integer">三识 Integer</h1>
<p>那么为什么要设计 Integer 这个类呢，原因貌似挺简单的，因为 Java 并不是一个纯面向对象的语言，如果是 ruby 应该不用这么麻烦，但是为了兼容基本类型，所以才需要这样的包装类。</p>
<p>那么既然要设计这样一个类，为什么还是个不变的类型？虽然不变类型有很多好处，但是像 i++ 这样的操作还需要拆箱、新建、装箱繁琐的操作后才行，为什么设计的时候不能设计成可变的类型呢？
我觉得既然 Integer 是 int 的包装类，是不是也要兼容 int 的一些属性呢？因为常识中，1 != 2 ，不管怎么说 1 也变不到 2 吧；如果设计成了可变的，那么多线程就会出现很多问题，需要考虑线程安全，有可能会出现 race condition 吧；还有就是，String 是不变的，为了兼容这一堆的转换，也不能设计成可变的吧。如果真想用可变的，其实 concurrent.atomic 包下的 AtomicInteger 应该能够满足需求了吧？</p>
<h1 id="结语">结语</h1>
<p>以前一直以为源码是很晦涩很难懂的，所以一直没有勇气把源码读完，今天这个是一个尝试，以后还会读取更多的源码。个人虽然不是很喜欢Java的臃肿，但是它的设计的确很好，能够学到很多东西。这次只是介绍了几个方法，其实这个类中的方法还挺多的，但我觉得这个还是要自己看看，其他方法大同小异，主要是吸取它的优秀思想和设计。</p>
<h1 id="参考">参考</h1>
<p><a href="http://www.4byte.cn/question/645476/java-integer-pool-why.html">java integer pool why</a></p>
<p><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7">JLS</a></p>
<p><a href="https://www.quora.com/In-Java-why-do-we-have-both-Integer-and-int">why do we have both Integer and int </a></p>
<p><a href="http://stackoverflow.com/questions/22793616/why-integer-in-java-is-immutable">why integer in java is immutable</a></p>
]]></content>
        </item>
        
        <item>
            <title>How to display grid in Pandas</title>
            <link>http://keltoy.github.io/posts/how-to-display-grid-in-pandas/</link>
            <pubDate>Sat, 08 Oct 2016 17:07:57 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/how-to-display-grid-in-pandas/</guid>
            <description>前言  “Life is short, You need Python.” &amp;ndash; Bruce Eckel
 Manager说是要把处理的数据展示出来&amp;hellip;&amp;hellip;我就想偷个懒直接使用Matplotlib实现得了，省着使用 D3.js 了，当然如果需要的话，还是很好转过来的。
首先吧，因为不仅需要展示，还需要处理后的数据，所以为了其他人方便，就吧结果存成了csv格式的了。其他格式都大同小异，js还在学习过程中，而且公司的本调试起来非常不方便，所以才使用的 Python&amp;hellip;
使用DataFrame展示 一开始想的就是调用 matplotlib.pylab 画图，表里面的一个 column 作为横轴，另一个column作为纵轴然后就可以了。但是后来我发现没那么复杂，DataFrame 直接就可以调用 plot&amp;hellip;.
import pandas as import pd df = pd.read_csv(filename) df.plot() 发现了这个之后感觉我的代码又一次简化了&amp;hellip;.
显示网格 这个其实没啥说的， 看一下 plot 的 api 有一个参数就叫做 grid，把这个赋值成 True，就行了。
df.plot(grid=True) 显示点 然后我就给了我的Manager。Manager说，不行啊，图上的点都没有突出&amp;hellip; 于是图形再次修改，查到 plot 函数是实现 matplotlib 的 plotting 方法的，所以可以使用 marker 参数的，于是又有了如下修改。
df.plot(marker=&amp;#39;o&amp;#39;, grid=True) 其中 &amp;lsquo;o&amp;rsquo; 代表的就是每个点使用圆圈标注。
调整刻度 这下应该可以了吧？ Manager 又来传话：网格的间距太大，能不能缩小一点？ 呃&amp;hellip;. 我看了看 API，貌似没有什么可以把网格缩小的方法&amp;hellip;. 于是，我又一次把问题想复杂了&amp;hellip;. 网格的大小实际上就是刻度的大小，如果刻度数量太多了，那么 DataFrame 自己会进行调整，但是这样的调整可能太大了，不符合人眼观测。所以，调整轴间距就可以完全满足。xticks 和 yticks，这里我只使用了xticks。调整完毕之后发现一连串的问题，生成的图片太小，根本看不清楚，横轴的标识全都挤在了一起无法辨认，很临界点看着不舒服&amp;hellip;.</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>“Life is short, You need Python.”
&ndash; Bruce Eckel</p>
</blockquote>
<p>Manager说是要把处理的数据展示出来&hellip;&hellip;我就想偷个懒直接使用Matplotlib实现得了，省着使用 <a href="https://d3js.org/">D3.js</a> 了，当然如果需要的话，还是很好转过来的。</p>
<p>首先吧，因为不仅需要展示，还需要处理后的数据，所以为了其他人方便，就吧结果存成了csv格式的了。其他格式都大同小异，js还在学习过程中，而且公司的本调试起来非常不方便，所以才使用的 Python&hellip;</p>
<h1 id="使用dataframe展示">使用DataFrame展示</h1>
<p>一开始想的就是调用 matplotlib.pylab 画图，表里面的一个 column 作为横轴，另一个column作为纵轴然后就可以了。但是后来我发现没那么复杂，DataFrame 直接就可以调用 plot&hellip;.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> pandas <span style="color:#f92672">as</span> import pd
df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(filename)
df<span style="color:#f92672">.</span>plot()
</code></pre></div><p>发现了这个之后感觉我的代码又一次简化了&hellip;.</p>
<h1 id="显示网格">显示网格</h1>
<p>这个其实没啥说的， 看一下 plot 的 api 有一个参数就叫做 grid，把这个赋值成 True，就行了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">df<span style="color:#f92672">.</span>plot(grid<span style="color:#f92672">=</span>True)
</code></pre></div><h1 id="显示点">显示点</h1>
<p>然后我就给了我的Manager。Manager说，不行啊，图上的点都没有突出&hellip;
于是图形再次修改，查到 plot 函数是实现 matplotlib 的 plotting 方法的，所以可以使用 marker 参数的，于是又有了如下修改。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">df<span style="color:#f92672">.</span>plot(marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>, grid<span style="color:#f92672">=</span>True)
</code></pre></div><p>其中 &lsquo;o&rsquo; 代表的就是每个点使用圆圈标注。</p>
<h1 id="调整刻度">调整刻度</h1>
<p>这下应该可以了吧？ Manager 又来传话：网格的间距太大，能不能缩小一点？
呃&hellip;. 我看了看 API，貌似没有什么可以把网格缩小的方法&hellip;.
于是，我又一次把问题想复杂了&hellip;.
网格的大小实际上就是刻度的大小，如果刻度数量太多了，那么 DataFrame 自己会进行调整，但是这样的调整可能太大了，不符合人眼观测。所以，调整轴间距就可以完全满足。xticks 和 yticks，这里我只使用了xticks。调整完毕之后发现一连串的问题，生成的图片太小，根本看不清楚，横轴的标识全都挤在了一起无法辨认，很临界点看着不舒服&hellip;.
还好，plot 函数还是很强大的，有参数都能解决。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">df<span style="color:#f92672">.</span>plot(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">25</span>,<span style="color:#ae81ff">15</span>), marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>, grid<span style="color:#f92672">=</span>True, xticks<span style="color:#f92672">=</span>[n <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(df), <span style="color:#ae81ff">10</span>)], rot<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span>)
</code></pre></div><p>基本上就满足了所有的要求，感觉不错，就交给了 Manager，Manager也觉得不错。</p>
<h1 id="注意的地方">注意的地方</h1>
<p>因为一次需要生成的图很多，所以我写了一个循环，针对每一个 item 生成一幅图。如果使用 jupyter 编写的时候需要图片嵌入到浏览器中，&quot;%matplotlib inline&quot; 这句不能少。
我的横轴坐标是时间轴，不是数组，一开始困扰我的是，如何才能把刻度写成一个列表。后来查了一些资料，好像明白了，DataFrame 在运行的时候，实际上会把横轴的刻度转换成数组，所以，横轴的处理只需要像数组一样处理，就可以&hellip;</p>
<p>基本上源码长成这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">%</span>matplotlib inline
<span style="color:#f92672">import</span> os
<span style="color:#f92672">import</span> pandas <span style="color:#f92672">as</span> pd
<span style="color:#f92672">import</span> matplotlib.pylab <span style="color:#f92672">as</span> plt

ls <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>listdir(os<span style="color:#f92672">.</span>getcwd())

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> ls:
    df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(i, index_col<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;date&#39;</span>])
    <span style="color:#66d9ef">try</span>:
      plot <span style="color:#f92672">=</span> df<span style="color:#f92672">.</span>plot(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">15</span>), marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>, grid<span style="color:#f92672">=</span>True, xticks<span style="color:#f92672">=</span>[n <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(df), <span style="color:#ae81ff">10</span>)], rot<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span>)
      fig <span style="color:#f92672">=</span> plot<span style="color:#f92672">.</span>get_figure()
      fig<span style="color:#f92672">.</span>savefig(i<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;.jpg&#39;</span>)
      plt<span style="color:#f92672">.</span>close()
    <span style="color:#66d9ef">except</span>:
      <span style="color:#66d9ef">print</span> (<span style="color:#e6db74">&#34;omit...&#34;</span> <span style="color:#f92672">+</span> i)

</code></pre></div><ul>
<li>每次生成图片的时候需要关闭 matplotlib.pylab，一开始的时候没注意，没有 close，导致循环中的图片是不断累加的，到最后已经无法辨识。</li>
<li>figsize的默认单位是英寸 (inch)。我还以为是厘米，结果画的图都超大&hellip;</li>
<li>xticks 里的参数 n 和 外层循环的 i 不能重名，原因是像 [i for i in range (42)] 这样的表达式不是使用闭包实现的，所以同名会有冲突</li>
<li>xticks 中 不能写成 [n+10 for n in range(len(df))] 这样的形式，我试过，只是从第 11 个开始，具体原因，我猜想可能跟 Python 后绑定变量有关系，有待考量。</li>
</ul>
<h1 id="结语">结语</h1>
<p>可视化的东西之前接触的比较少，一上来就让我使用 D3.js 去实现，一开始感觉蛮吃力的，因为没有 js 基础。后来慢慢发现 js 的强大，转而比较 Python 发现各有利弊。这是我第一次使用 matplotlib 画图，如果没有 D3.js 基础，或者条件不允许使用 D3.js，matplotlib 快速生成批量图片还是蛮方便的。</p>
]]></content>
        </item>
        
        <item>
            <title>Mathematics for Thinking Code</title>
            <link>http://keltoy.github.io/posts/mathematics-for-thinking-code/</link>
            <pubDate>Sun, 02 Oct 2016 14:42:21 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/mathematics-for-thinking-code/</guid>
            <description>Preface  Histories make men wise; poets, witty; the mathematics, subtle; natural philosophy, deep; moral, grave; logic and rhetoric, able to contend. &amp;ndash; Francis Bacon, The Collected Works of Sir Francis Bacon
 It is very significant that mathematics for programmer. A skilled programmer, who is good at mathematics, is able to simplify problems whatever in life or engineering. A textbook, Mathematics for Computer Science, makes me learn a lot.</description>
            <content type="html"><![CDATA[<h1 id="preface">Preface</h1>
<blockquote>
<p>Histories make men wise; poets, witty; the mathematics, subtle; natural philosophy, deep; moral, grave; logic and rhetoric, able to contend.
&ndash; Francis Bacon, The Collected Works of Sir Francis Bacon</p>
</blockquote>
<p>It is very significant that mathematics for programmer. A skilled programmer, who is good at mathematics, is able to simplify problems whatever in life or engineering.
A textbook, <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/readings/MIT6_042JS15_textbook.pdf">Mathematics for Computer Science</a>, makes me learn a lot.</p>
<h1 id="proofs">Proofs</h1>
<p>Soon</p>
<h1 id="structures">Structures</h1>
<p>not prepared</p>
<h1 id="counting">Counting</h1>
<h2 id="greatest-common-divisor">Greatest Common Divisor</h2>
<p>$$
GCD(m, n) =
\begin{cases}
GCD(n, m MOD n), &amp; m \gt n
\ m, &amp; m &amp; MOD &amp; n = 0
\ GCD(n, m) &amp; m \lt n
\end{cases}
$$</p>
<h2 id="least-common-multiple">Least Common Multiple</h2>
<p>$$
LCM(m, n) = (m * n)/GCD(m, n)
$$</p>
<h1 id="probability">Probability</h1>
<p>next version</p>
<h1 id="combinatorics">Combinatorics</h1>
<h2 id="formula">formula</h2>
<h3 id="permutations">Permutations</h3>
<p>$$ P_n^k = n(n-1)(n-2)\cdots(n-k+1) = \frac{n!}{(n-k)!} $$</p>
<h3 id="combinations">Combinations</h3>
<p>$$ C_n^k = C_{n-1}^{k-1} + C_{n-1}^{k} $$</p>
<p>$$ C_n^k = \frac{P_n^k}{k!} = \frac{n!}{k!(n-k)!)} = C_n^{n-k} $$</p>
<h1 id="conclusion">Conclusion</h1>
<p>It is not the end, It is just beginning&hellip;</p>
]]></content>
        </item>
        
        <item>
            <title>时间复杂度</title>
            <link>http://keltoy.github.io/posts/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
            <pubDate>Fri, 30 Sep 2016 11:45:33 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
            <description>所有的时间复杂度 其实是这个网站的图。。。感觉好用就拿来了。 还有一个是各类时间复杂度的比较。
   数据结构 时间复杂度 &amp;ndash; &amp;ndash; &amp;ndash; &amp;ndash; &amp;ndash; &amp;ndash; &amp;ndash; 空间复杂度      平均 &amp;ndash; &amp;ndash; &amp;ndash; 最快 &amp;ndash; &amp;ndash; &amp;ndash; 最坏    访问 查找 插入 删除 访问 查找 插入 删除    Array $$\theta(1)$$ $$\theta(n)$$ $$\theta(n)$$ $$\theta(n)$$ $$O(1)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$   Stack $$\theta(n)$$ $$\theta(n)$$ $$\theta(1)$$ $$\theta(1)$$ $$O(n)$$ $$O(n)$$ $$O(1)$$ $$O(1)$$ $$O(n)$$   Queue $$\theta(n)$$ $$\theta(n)$$ $$\theta(1)$$ $$\theta(1)$$ $$O(n)$$ $$O(n)$$ $$O(1)$$ $$O(1)$$ $$O(n)$$   Singly-Linked List $$\theta(n)$$ $$\theta(n)$$ $$\theta(1)$$ $$\theta(1)$$ $$O(n)$$ $$O(n)$$ $$O(1)$$ $$O(1)$$ $$O(n)$$   Doubly-Linked List $$\theta(n)$$ $$\theta(n)$$ $$\theta(1)$$ $$\theta(1)$$ $$O(n)$$ $$O(n)$$ $$O(1)$$ $$O(1)$$ $$O(n)$$   Skip List $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n\log_2(n))$$   Hash Table N/A $$\theta(1)$$ $$\theta(1)$$ $$\theta(1)$$ N/A $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$   Binary Search Tree $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$   Cartesian Tree N/A $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ N/A $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$   B-Tree $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(n)$$   Red-Black Tree $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(n)$$   Splay Tree N/A $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ N/A $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(n)$$   AVL Tree $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(\log_2(n))$$ $$O(n)$$   KD Tree $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$\theta(\log_2(n))$$ $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$ $$O(n)$$    还有排序时间复杂度：</description>
            <content type="html"><![CDATA[<h1 id="所有的时间复杂度">所有的时间复杂度</h1>
<p>其实是<a href="http://bigocheatsheet.com/">这个网站</a>的图。。。感觉好用就拿来了。
<img src="http://odzz59auo.bkt.clouddn.com/big-o-cheat-sheet-poster.png" alt="alt 时间复杂度" title="时间复杂度"></p>
<p>还有一个是<a href="http://odzz59auo.bkt.clouddn.com/big-o-cheatsheet.pdf">各类时间复杂度的比较</a>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据结构</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">平均</td>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center">最快</td>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center">最坏</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">访问</td>
<td style="text-align:center">查找</td>
<td style="text-align:center">插入</td>
<td style="text-align:center">删除</td>
<td style="text-align:center">访问</td>
<td style="text-align:center">查找</td>
<td style="text-align:center">插入</td>
<td style="text-align:center">删除</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Array</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Stack</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Queue</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Singly-Linked List</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Doubly-Linked List</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(n)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(1)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Skip List</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n\log_2(n))$$</td>
</tr>
<tr>
<td style="text-align:center">Hash Table</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">$$\theta(1)$$</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Binary Search Tree</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Cartesian Tree</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">B-Tree</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Red-Black Tree</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Splay Tree</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">AVL Tree</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">KD Tree</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$\theta(\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
</tbody>
</table>
<p>还有排序时间复杂度：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">&ndash;</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">最好</td>
<td style="text-align:center">平局</td>
<td style="text-align:center">最坏</td>
<td style="text-align:center">最坏</td>
</tr>
<tr>
<td style="text-align:center">Quicksort</td>
<td style="text-align:center">$$\Omega(n\log_2(n))$$</td>
<td style="text-align:center">$$\Theta(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(\log_2(n))$$</td>
</tr>
<tr>
<td style="text-align:center">Mergesort</td>
<td style="text-align:center">$$\Omega(n\log_2(n))$$</td>
<td style="text-align:center">$$\Theta(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Timsort</td>
<td style="text-align:center">$$\Omega(n)$$</td>
<td style="text-align:center">$$\Theta(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Heapsort</td>
<td style="text-align:center">$$\Omega(n\log_2(n))$$</td>
<td style="text-align:center">$$\Theta(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n\log_2(n))$$</td>
<td style="text-align:center">$$O(1)$$</td>
</tr>
<tr>
<td style="text-align:center">Bubblesort</td>
<td style="text-align:center">$$\Omega(n)$$</td>
<td style="text-align:center">$$\Theta(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
</tr>
<tr>
<td style="text-align:center">Insertion Sort</td>
<td style="text-align:center">$$\Omega(n)$$</td>
<td style="text-align:center">$$\Theta(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
</tr>
<tr>
<td style="text-align:center">Selection Sort</td>
<td style="text-align:center">$$\Omega(n^2)$$</td>
<td style="text-align:center">$$\Theta(n^2)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
</tr>
<tr>
<td style="text-align:center">Tree Sort</td>
<td style="text-align:center">$$\Omega(n\log_2(n))$$</td>
<td style="text-align:center">$$\Theta(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Shell Sort</td>
<td style="text-align:center">$$\Omega(n\log_2(n))$$</td>
<td style="text-align:center">$$\Theta(n(\log_2(n))^2))$$</td>
<td style="text-align:center">$$O(n(\log_2(n))^2)$$</td>
<td style="text-align:center">$$O(1)$$</td>
</tr>
<tr>
<td style="text-align:center">Bucket Sort</td>
<td style="text-align:center">$$\Omega(n+k)$$</td>
<td style="text-align:center">$$\Theta(n+k)$$</td>
<td style="text-align:center">$$O(n^2)$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
<tr>
<td style="text-align:center">Radix Sort</td>
<td style="text-align:center">$$\Omega(nk)$$</td>
<td style="text-align:center">$$\Theta(nk)$$</td>
<td style="text-align:center">$$O(nk)$$</td>
<td style="text-align:center">$$O(n+k)$$</td>
</tr>
<tr>
<td style="text-align:center">Counting Sort</td>
<td style="text-align:center">$$\Omega(n+k)$$</td>
<td style="text-align:center">$$\Theta(n+k)$$</td>
<td style="text-align:center">$$O(n+k)$$</td>
<td style="text-align:center">$$O(k)$$</td>
</tr>
<tr>
<td style="text-align:center">Cubesort</td>
<td style="text-align:center">$$\Omega(n)$$</td>
<td style="text-align:center">$$\Theta(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n\log_2(n))$$</td>
<td style="text-align:center">$$O(n)$$</td>
</tr>
</tbody>
</table>
]]></content>
        </item>
        
        <item>
            <title>编程中的临界值</title>
            <link>http://keltoy.github.io/posts/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%B4%E7%95%8C%E5%80%BC/</link>
            <pubDate>Sun, 25 Sep 2016 12:51:55 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%B4%E7%95%8C%E5%80%BC/</guid>
            <description>前言 刷题、面试、OJ 过程中，总是被编程题所困扰，往往是有思路能解答，但是不能 100% AC，看着刷子和cheater们拿走offer，心里有种说不出的感觉，内心下定决心，一定要完成 100% AC &amp;hellip;
于是我稳稳心态，吃根辣条压压惊，刷刷OJ，找找感觉，在这里总结一下如何能够考虑到所有的情况。
不能 100% AC 顾名思义，基本上我所出现的问题都是，思路正确，编程问题不大，但是不够严谨，很多时候不能够考虑到所有的情况，导致 AC 的通过率总是在 60%~90% 徘徊。如何才能够考虑到所有情况，才是我所要解决的关键。
通常情况 通常情况一般就是 OJ 里面所举例说明的案例，这个案例如果过不了则说明所选的算法可能本身就有问题。不论是 hash，backtrack，dp，recursion 还是其他，首先考虑所选用的方法是否合适解决此类问题。如果能够通过说明案例，至少说明方法应该不会错太多。
临界值 临界值这个首先要看清楚题目所给出的范围，比如说： $$0 &amp;lt;= m &amp;lt;= 10^5$$ 这里就要注意两边注意两边的值一个是可以取到 0 的， 而另一边，要看看是否大于了int类型的临界值 (Integer.MAX_VALUE()) 等等。 输出也是需要有临界值的，所以输出也是需要判断的。 还有一类就是自己加的一些参数，这些参数也可能影响结果&amp;hellip; 比如说，给定的输入只有一个n，但是我要的方法需要 recursion，需要在方法中添加一个 res, 和 ix，这时候需要注意这两个值有没有临界值。
void solution(int n, int res, int ix) { if (res &amp;gt; SOMEVALUE) { // my code...  } if (ix &amp;gt; SOMEINDEX) { // my code...  } // my code.</description>
            <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>刷题、面试、OJ 过程中，总是被编程题所困扰，往往是有思路能解答，但是不能 100% AC，看着刷子和cheater们拿走offer，心里有种说不出的感觉，内心下定决心，一定要完成 100% AC &hellip;</p>
<p>于是我稳稳心态，吃根辣条压压惊，刷刷OJ，找找感觉，在这里总结一下如何能够考虑到所有的情况。</p>
<h1 id="不能-100-ac">不能 100% AC</h1>
<p>顾名思义，基本上我所出现的问题都是，思路正确，编程问题不大，但是不够严谨，很多时候不能够考虑到所有的情况，导致 AC 的通过率总是在  60%~90% 徘徊。如何才能够考虑到所有情况，才是我所要解决的关键。</p>
<h2 id="通常情况">通常情况</h2>
<p>通常情况一般就是 OJ 里面所举例说明的案例，这个案例如果过不了则说明所选的算法可能本身就有问题。不论是 hash，backtrack，dp，recursion 还是其他，首先考虑所选用的方法是否合适解决此类问题。如果能够通过说明案例，至少说明方法应该不会错太多。</p>
<h2 id="临界值">临界值</h2>
<p>临界值这个首先要看清楚题目所给出的范围，比如说：
$$0 &lt;= m &lt;= 10^5$$
这里就要注意两边注意两边的值一个是可以取到 0 的， 而另一边，要看看是否大于了int类型的临界值 (Integer.MAX_VALUE()) 等等。
输出也是需要有临界值的，所以输出也是需要判断的。
还有一类就是自己加的一些参数，这些参数也可能影响结果&hellip;
比如说，给定的输入只有一个n，但是我要的方法需要 recursion，需要在方法中添加一个 res, 和 ix，这时候需要注意这两个值有没有临界值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solution</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> res<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> ix<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>res <span style="color:#f92672">&gt;</span> SOMEVALUE<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// my code...
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ix <span style="color:#f92672">&gt;</span> SOMEINDEX<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// my code...
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        <span style="color:#75715e">// my code...
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><p>就像这样，需要判断一下。</p>
<h2 id="特殊值">特殊值</h2>
<p>在输入过程中会有一些特殊值，他们也属于正确答案，但是在我们的方法中不能满足，需要提取出来单个返回。常见的特殊值有，0, 1, max_value,负数等&hellip;</p>
<h2 id="输入可能性">输入可能性</h2>
<p>其实最容易忽略的地方就是在这一块。输入的时候往往我会受到案例的影响，举例的时候都是同一种例子。这时候我个人认为可以使用全排列，使用一个小例子把所有的情况都列举出来，比如给定一个很大的数m和一个数n，求出去掉n个数量的m的最大值例如：</p>
<pre><code>123
1
</code></pre>
<p>输出：</p>
<pre><code>23
</code></pre>
<p>那么考虑到m是一个很大的数，就不能使用int去存储了，是该用array、string，还是unsigned long long，这个需要看看如何处理起来方便。然后，考虑一下临界值，如果n比m的个数还要多怎么办，n等于0， n小于0怎么办&hellip;接着考虑一下案例中的 123，全排列试试：</p>
<pre><code>123 -&gt; 23
132 -&gt; 32
213 -&gt; 23
231 -&gt; 31
312 -&gt; 32
321 -&gt; 32
</code></pre>
<p>我当时没有全排列出来，简单以为就是去除最小的就行了，但是</p>
<pre><code>231 -&gt; 31
</code></pre>
<p>明显不是这样的&hellip;.所以考虑方式也要全面，到位，才能做对题目。</p>
<h2 id="数据量变得超大的时候">数据量变得超大的时候</h2>
<p>一些经典的题目，比如 0-1 背包问题，字符串匹配问题，当题目的范围给的非常之大，比如给定的一个数远远大于了2147483647，这时候需要考虑是否使用long，unsigned long long，或者直接使用字符串接收；或者，改变思路，从另外一个方向考虑。 比如给定的两个参数：
$$
\begin{array}{}
0 &lt; n &lt; 10^{18}\<br>
0 &lt; m &lt; 20
\end{array}
$$
可以先从m入手开始考虑算法；或者变换思路，想想可不可以把 n 想像成一个位，使用类似 bitmap 的形式进行处理；如果实在不行，那么可能真的就没什么好方法，那就考虑考虑分块，归并，流数据，map-filter-reduce 等方法吧&hellip;.</p>
<h1 id="结语">结语</h1>
<p>自己在 <a href="http://leetcode.com">leetcode</a> 其实也刷了一些题目了，但是一个是对IO不熟练，浪费了很多时间；一个是leetcode都有调试，虽然我写的时候没有使用IDE，但是借助于强大的调试能力，也解决了很多问题。现在笔试过程中，没有调试功能，只告诉我通过的百分之几，也没有多余案例可以测试，这些东西都要自己在脑子里想清楚再编程&hellip;
记录一下，以免自己再次遗忘，能够在接下来的面试中尽量多做对题！！！</p>
]]></content>
        </item>
        
        <item>
            <title>Hello World</title>
            <link>http://keltoy.github.io/posts/hello-world/</link>
            <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
            
            <guid>http://keltoy.github.io/posts/hello-world/</guid>
            <description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing
Run server $ hexo server More info: Server
Generate static files $ hexo generate More info: Generating
Deploy to remote sites $ hexo deploy More info: Deployment</description>
            <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ hexo new <span style="color:#e6db74">&#34;My New Post&#34;</span>
</code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ hexo server
</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ hexo generate
</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ hexo deploy
</code></pre></div><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
        </item>
        
    </channel>
</rss>
